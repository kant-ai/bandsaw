{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bandsaw \ud83d\udd17 Bandsaw is a library for defining and structuring Python workflows, that can span across multiple python interpreters and machines. It is currently under development by Kantai GmbH and licensed under MIT License . Interested in first steps using bandsaw? \ud83d\udd17 Take a look at our Getting started documentation . Want to learn more about the details? \ud83d\udd17 Read through our User guide to understand how it works. You have questions? \ud83d\udd17 Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"Home"},{"location":"#bandsaw","text":"Bandsaw is a library for defining and structuring Python workflows, that can span across multiple python interpreters and machines. It is currently under development by Kantai GmbH and licensed under MIT License .","title":"Bandsaw"},{"location":"#interested-in-first-steps-using-bandsaw","text":"Take a look at our Getting started documentation .","title":"Interested in first steps using bandsaw?"},{"location":"#want-to-learn-more-about-the-details","text":"Read through our User guide to understand how it works.","title":"Want to learn more about the details?"},{"location":"#you-have-questions","text":"Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"You have questions?"},{"location":"api/","text":"A library for splitting python workflows into separate tasks advice \ud83d\udd17 Contains classes and functions for advising tasks. Advice ( Protocol ) \ud83d\udd17 Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, before(session) and after(session) , that are called during the process of advising a task execution. Both take a single argument session which contains an instance of the class Session . This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result. after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def after ( self , session ): \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def before ( self , session ): \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () advise_task_with_chain ( task , run , configuration , advice_chain = 'default' ) \ud83d\udd17 Executes an Task with additional advices. Parameters: Name Type Description Default task bandsaw.tasks.Task The task to be executed. required run bandsaw.run.Run The run definition for the task. required configuration bandsaw.config.Configuration The configuration which should be used during advising. required advice_chain str The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. 'default' Returns: Type Description bandsaw.result.Result The result of the task execution. Source code in bandsaw/advice.py def advise_task_with_chain ( task , run , configuration , advice_chain = 'default' ): \"\"\" Executes an `Task` with additional advices. Args: task (bandsaw.tasks.Task): The task to be executed. run (bandsaw.run.Run): The run definition for the task. configuration (bandsaw.config.Configuration): The configuration which should be used during advising. advice_chain (str): The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. Returns: bandsaw.result.Result: The result of the task execution. \"\"\" session = Session ( task , run , configuration , advice_chain ) return session . initiate () advices special \ud83d\udd17 Package that contains reusable Advice classes cache \ud83d\udd17 Contains Advice that can cache task results in a local file system. CachingAdvice ( Advice ) \ud83d\udd17 Advice that caches results in a local filesystem. Attributes: Name Type Description directory Path The path to the directory where the results are cached. __init__ ( self , directory ) special \ud83d\udd17 Initialize self. See help(type(self)) for accurate signature. Source code in bandsaw/advices/cache.py def __init__ ( self , directory ): self . directory = pathlib . Path ( directory ) logger . info ( \"Caching artifacts in storage ' %s '\" , self . directory ) super () . __init__ () after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def before ( self , session ): artifact_id = session . task . task_id revision_id = session . run . run_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed () logging \ud83d\udd17 Contains an Advice implementation which adds logging LoggingAdvice ( Advice ) \ud83d\udd17 An Advice which adds additional logging after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/logging.py def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . run . run_id , session . context , ) session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/logging.py def before ( self , session ): logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . run . run_id , session . context , ) session . proceed () subprocess \ud83d\udd17 Contains Advice implementation that runs the execution in a subprocess SubprocessAdvice ( Advice ) \ud83d\udd17 Advice that runs in a subprocess __init__ ( self , directory = None , interpreter = None ) special \ud83d\udd17 Create a new instance. Parameters: Name Type Description Default directory str The directory where temporary files are stored to exchange data between both processes. If None a temporary directory is used. None interpreter bandsaw.interpreter.Interpreter The interpreter to use in the subprocess. If None the same interpreter will be used. None Source code in bandsaw/advices/subprocess.py def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = pathlib . Path ( tempfile . mkdtemp ()) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ () after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) session_out_path = session . context [ 'subprocess' ][ 'session_out.path' ] logger . info ( \"Writing session with result to %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'w' ) as stream : session . save ( stream ) before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) session_id = session . run . run_id session_in_file , session_in_path = tempfile . mkstemp ( '.zip' , 'in-' + session_id + '-' , self . directory ) session_out_file , session_out_path = tempfile . mkstemp ( '.zip' , 'out-' + session_id + '-' , self . directory ) session . context [ 'subprocess' ] = { 'session_in.path' : session_in_path , 'session_out.path' : session_out_path , } logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_file , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Running subprocess using interpreter %s \" , self . interpreter . executable ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , '-m' , 'bandsaw.advices.subprocess' , '--input' , session_in_path , '--output' , session_out_path , ], env = environment , ) logger . info ( \"Sub process exited\" ) with io . FileIO ( session_out_file , mode = 'r' ) as stream : session . restore ( stream ) session . proceed () config \ud83d\udd17 Contains the class and functions to configure bandsaw. Configuration \ud83d\udd17 Class that represents a configuration for bandsaw. add_advice_chain ( self , * advices , * , name = 'default' ) \ud83d\udd17 Add a new advice chain to the configuration. Each advice chain has a unique name . If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Parameters: Name Type Description Default *advices bandsaw.advice.Advice A tuple of advices for this chain. () name str The name of the advice chain, defaults to 'default' if not specified. 'default' Returns: Type Description bandsaw.config.Configuration The configuration to which the chain was added. Source code in bandsaw/config.py def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self add_extension ( self , extension ) \ud83d\udd17 Add an Extension to the configuration. Extensions are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Parameters: Name Type Description Default extension bandsaw.extension.Extension An object implementing the Extension . required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self get_advice_chain ( self , name ) \ud83d\udd17 Returns the advice chain with the given name. Parameters: Name Type Description Default name str Name of the wanted advice chain. required Returns: Type Description List[bandsaw.advice.Advice] The advice chain with the given name. Exceptions: Type Description KeyError If no chain with the specified name is configured. Source code in bandsaw/config.py def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name ) set_serializer ( self , serializer ) \ud83d\udd17 Sets the serialize which defines how tasks and results will be serialized. Parameters: Name Type Description Default serializer bandsaw.serialization.Serializer The serializer to use for serializing objects. required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self get_configuration ( configuration_module = None ) \ud83d\udd17 Return a configuration. Parameters: Name Type Description Default configuration_module str The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of Configuration . If no module name is given, a default configuration is returned based on the value of the BANDSAW_CONFIG_MODULE environment variable. If this variable is not set, we default to 'bandsaw_config'. None Returns: Type Description bandsaw.config.Configuration The configuration. Exceptions: Type Description ModuleNotFoundError If no module exists with name configuration_module . LookupError If the module doesn't contain a variable 'configuration`. TypeError If the variable configuration is not of type Configuration . Source code in bandsaw/config.py def get_configuration ( configuration_module = None ): \"\"\" Return a configuration. Args: configuration_module (str): The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of `Configuration`. If no module name is given, a default configuration is returned based on the value of the `BANDSAW_CONFIG_MODULE` environment variable. If this variable is not set, we default to 'bandsaw_config'. Returns: bandsaw.config.Configuration: The configuration. Raises: ModuleNotFoundError: If no module exists with name `configuration_module`. LookupError: If the module doesn't contain a variable 'configuration`. TypeError: If the variable `configuration` is not of type `Configuration`. \"\"\" if configuration_module is None : default_configuration_module_name = os . getenv ( CONFIGURATION_MODULE_ENV_VARIABLE , CONFIGURATION_MODULE_DEFAULT , ) configuration_module = default_configuration_module_name if configuration_module not in _configurations : try : _load_configuration_module ( configuration_module ) except ModuleNotFoundError : logger . warning ( \"No module found for config %s \" , configuration_module , ) raise return _configurations [ configuration_module ] context \ud83d\udd17 Classes that represent the context used in advising tasks. Context ( SerializableValue ) \ud83d\udd17 Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the Advice classes to store state or communicate with other advices. attributes property readonly \ud83d\udd17 A set of arbitrary key-value mappings for the Advice classes. Advice can add to this mapping and use this as a way of keeping state. deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/context.py @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ]) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/context.py def serialized ( self ): data = { 'attributes' : self . _attributes , } return data decorator \ud83d\udd17 Contains decorators that allow to define individual tasks task ( * task_args , * , config = None , chain = None , ** task_kwargs ) \ud83d\udd17 Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Examples: >>> @task ... def my_task_function (): ... pass or with additional configuration. Examples: >>> @task ( config = 'my.config' ) ... def my_task_function (): ... pass Parameters: Name Type Description Default config str The name of the configuration module to use for this task. If not given, the default configuration is used. None chain str The name of the advice chain to use for advising this task. If not given, 'default' is used. None *task_args Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, task_args contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, task_args contains the positional arguments of the call of the decorator. () **task_kwargs Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, task_kwargs is an empty dictionary. If there is additional configuration given, task_kwargs contains the keyword arguments of the call of the decorator. {} Returns: Type Description Callable Returns a callable that wraps the decorated function. Exceptions: Type Description ModuleNotFoundError If the configured configuration module does not exist. ValueError If the specified advice chain does not exist. RuntimeError If the task is configured with multiple positional arguments. Source code in bandsaw/decorator.py def task ( * task_args , config = None , chain = None , ** task_kwargs ): \"\"\" Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Example: >>> @task ... def my_task_function(): ... pass or with additional configuration. Example: >>> @task(config='my.config') ... def my_task_function(): ... pass Args: config (str): The name of the configuration module to use for this task. If not given, the default configuration is used. chain (str): The name of the advice chain to use for advising this task. If not given, 'default' is used. *task_args: Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, `task_args` contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, `task_args` contains the positional arguments of the call of the decorator. **task_kwargs: Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, `task_kwargs` is an empty dictionary. If there is additional configuration given, `task_kwargs`contains the keyword arguments of the call of the decorator. Returns: Callable: Returns a callable that wraps the decorated function. Raises: ModuleNotFoundError: If the configured configuration module does not exist. ValueError: If the specified advice chain does not exist. RuntimeError: If the task is configured with multiple positional arguments. \"\"\" config_module = config configuration = get_configuration ( config_module ) chain_name = chain or 'default' chain = configuration . get_advice_chain ( chain_name ) if chain is None : raise ValueError ( f \"Unknown advice chain { chain_name } \" ) def decorate_function ( func ): logger . info ( \"Decorate function ' %s '\" , func ) logger . info ( \"Creating task for function ' %s '\" , func ) the_task = Task . create_task ( func ) def inner ( * func_args , ** func_kwargs ): run_id = _calculate_run_id ( func_args , func_kwargs , configuration . serializer , ) run = Run ( run_id , func_args , func_kwargs ) result = advise_task_with_chain ( the_task , run , configuration , chain_name , ) if result . exception : raise result . exception return result . value inner . __wrapped__ = func inner . bandsaw_task = the_task inner . bandsaw_configuration = configuration return inner if len ( task_args ) == 1 and len ( task_kwargs ) == 0 : return decorate_function ( task_args [ 0 ]) if len ( task_args ) == 0 and len ( task_kwargs ) > 0 : return decorate_function # This shouldn't happen if the decorator is properly used. raise RuntimeError ( \"Invalid 'task' decorator.\" ) extensions \ud83d\udd17 Contains an API for extensions that can be used in bandsaw Extension \ud83d\udd17 Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than Advice , an Extension is globally defined in a config and therefore applies to all tasks. on_after_advice ( self , task , run , context , result ) \ud83d\udd17 Called after bandsaw advises a task. Parameters: Name Type Description Default task bandsaw.tasks.Task The task which was advised. required run bandsaw.run.Run The run which contains the parametrization of the task. required context bandsaw.context.Context The context which was used during the advice. required result bandsaw.result.Result The result of the call. required Source code in bandsaw/extensions.py def on_after_advice ( self , task , run , context , result ): \"\"\" Called after bandsaw advises a task. Args: task (bandsaw.tasks.Task): The task which was advised. run (bandsaw.run.Run): The run which contains the parametrization of the task. context (bandsaw.context.Context): The context which was used during the advice. result (bandsaw.result.Result): The result of the call. \"\"\" on_before_advice ( self , task , run , context ) \ud83d\udd17 Called before bandsaw advises a task. Parameters: Name Type Description Default task bandsaw.tasks.Task The task which will be advised. required run bandsaw.run.Run The run which contains the parametrization of the task. required context bandsaw.context.Context The context which will be used during the advice. The context can be extended by the extension. required Source code in bandsaw/extensions.py def on_before_advice ( self , task , run , context ): \"\"\" Called before bandsaw advises a task. Args: task (bandsaw.tasks.Task): The task which will be advised. run (bandsaw.run.Run): The run which contains the parametrization of the task. context (bandsaw.context.Context): The context which will be used during the advice. The context can be extended by the extension. \"\"\" on_init ( self , configuration ) \ud83d\udd17 Called when a bandsaw configuration has been initialized. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration object which contains the config that has been loaded. required Source code in bandsaw/extensions.py def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\" identifier \ud83d\udd17 Functions for generating identifier for arbitrary python objects. identifier_from_bytes ( buffer ) \ud83d\udd17 Derive an identifier from a bytebuffer. Parameters: Name Type Description Default buffer Union[bytes,bytearray] The binary data from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_bytes ( buffer ): \"\"\" Derive an identifier from a bytebuffer. Args: buffer (Union[bytes,bytearray]): The binary data from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = hashlib . sha256 ( buffer ) . hexdigest () return identifier identifier_from_string ( string ) \ud83d\udd17 Derive an identifier from a string. Parameters: Name Type Description Default string str The string from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_string ( string ): \"\"\" Derive an identifier from a string. Args: string (str): The string from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = identifier_from_bytes ( string . encode ( 'utf-8' )) return identifier interpreter \ud83d\udd17 Contains classes regarding python interpreters Interpreter ( SerializableValue ) \ud83d\udd17 Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined. environment property readonly \ud83d\udd17 The environment variables to be set for the interpreter. path property readonly \ud83d\udd17 The python path items that will be used. __init__ ( self , path = None , executable = None ) special \ud83d\udd17 Create a new interpreter instance. Parameters: Name Type Description Default path List[str] A list of directory paths, to be used as $PYTHONPATH. If None the current sys.path is used. None executable str The path to the python executable for this interpreter. If None the current sys.executable is used. None Source code in bandsaw/interpreter.py def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" self . _path = path or tuple ( sys . path ) self . executable = executable or sys . executable self . _environment = {} deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/interpreter.py @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ]) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/interpreter.py def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , } set_environment ( self , ** environment ) \ud83d\udd17 Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Parameters: Name Type Description Default **environment Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. {} Source code in bandsaw/interpreter.py def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self io \ud83d\udd17 Contains classes related to input/output of data. BytearrayGeneratorToStream ( RawIOBase ) \ud83d\udd17 Stream that reads from a generator that yields bytes/bytearrays. read_stream_to_generator ( stream , buffer_size = 8192 ) \ud83d\udd17 Read from a stream into a generator yielding bytes . Parameters: Name Type Description Default stream io.Stream The stream to read bytes from. required buffer_size int The buffer size to read. Each individual bytes buffer returned by the generator has a maximum size of buffer_size . Defaults to 8192 if not set. 8192 !!! yields bytes: A byte buffer of maximum size of buffer_size . Source code in bandsaw/io.py def read_stream_to_generator ( stream , buffer_size = 8192 ): \"\"\" Read from a stream into a generator yielding `bytes`. Args: stream (io.Stream): The stream to read bytes from. buffer_size (int): The buffer size to read. Each individual `bytes` buffer returned by the generator has a maximum size of `buffer_size`. Defaults to `8192` if not set. Yields: bytes: A byte buffer of maximum size of `buffer_size`. \"\"\" buffer = bytearray ( buffer_size ) while True : read = stream . readinto ( buffer ) if read : yield buffer [: read ] else : break modules \ud83d\udd17 Utility functions for handling python modules. get_loaded_module_name_by_path ( file_path ) \ud83d\udd17 Determine the name of an already loaded module by its file path. Parameters: Name Type Description Default file_path str File path of the python file containing the module. required Returns: Type Description str The name of the module, or None if the file isn't loaded as a module. Source code in bandsaw/modules.py def get_loaded_module_name_by_path ( file_path ): \"\"\" Determine the name of an already loaded module by its file path. Args: file_path (str): File path of the python file containing the module. Returns: str: The name of the module, or `None` if the file isn't loaded as a module. \"\"\" real_path = os . path . realpath ( file_path ) for name , module in sys . modules . items (): if hasattr ( module , '__file__' ): module_path = os . path . realpath ( module . __file__ ) if module_path == real_path : return name return None import_object ( object_name , module_name ) \ud83d\udd17 Import a python object from a module. Parameters: Name Type Description Default object_name str The name under which the object is defined in the module. required module_name str The name of the module from which the object should be imported. required Returns: Type Description object The python object defined under the name. Exceptions: Type Description AttributeError If nothing is defined with name object_name in the referenced module. ModuleNotFoundError If no module exists with the name module_name . Source code in bandsaw/modules.py def import_object ( object_name , module_name ): \"\"\" Import a python object from a module. Args: object_name (str): The name under which the object is defined in the module. module_name (str): The name of the module from which the object should be imported. Returns: object: The python object defined under the name. Raises: AttributeError: If nothing is defined with name `object_name` in the referenced module. ModuleNotFoundError: If no module exists with the name `module_name`. \"\"\" module = importlib . import_module ( module_name ) return getattr ( module , object_name ) object_as_import ( obj ) \ud83d\udd17 Returns the name and module of an object, which can be used for importing it. Parameters: Name Type Description Default obj object An arbitrary Python object. required Returns: Type Description Tuple(str, str) Returns a tuple of the object name and the module name in which the object is defined. Exceptions: Type Description ValueError If obj doesn't have a name that can be directly imported, e.g. because it is defined within a local class. !!! note If obj is defined within the __main__ script, the function tries to determine a name for the __main__ module, under which it could be imported from other scripts. Source code in bandsaw/modules.py def object_as_import ( obj ): \"\"\" Returns the name and module of an object, which can be used for importing it. Args: obj (object): An arbitrary Python object. Returns: Tuple(str, str): Returns a tuple of the object name and the module name in which the object is defined. Raises: ValueError: If `obj` doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note: If `obj` is defined within the `__main__` script, the function tries to determine a name for the `__main__` module, under which it could be imported from other scripts. \"\"\" object_name = obj . __name__ module_name = obj . __module__ if module_name == '__main__' : module_file_path = sys . modules [ '__main__' ] . __file__ module_name = _guess_module_name_by_path ( module_file_path , sys . path ) if '<locals>' in obj . __qualname__ : raise ValueError ( \"Can't import local functions.\" ) return object_name , module_name result \ud83d\udd17 Contains code for representing the result of tasks. Result ( SerializableValue ) \ud83d\udd17 Class to encapsulate the result of a task execution. Attributes: Name Type Description value Any The value that is returned by the task. None is the task raised an exception during execution. exception Exception The exception that was raised during execution, None if no exception was raised. deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/result.py @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception ) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/result.py def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values run \ud83d\udd17 Contains classes and functions around a run of tasks Run ( SerializableValue ) \ud83d\udd17 Class that defines a run of a Task . Attributes: Name Type Description run_id str A string identifying this run. args tuple[Any] The positional arguments for the task to use in this execution. kwargs Dict[Any,Any] The keyword arguments for the task to use in this execution. deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/run.py @classmethod def deserialize ( cls , values ): return Run ( values [ 'run_id' ], values [ 'args' ], values [ 'kwargs' ], ) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/run.py def serialized ( self ): return { 'run_id' : self . run_id , 'args' : self . args , 'kwargs' : self . kwargs , } serialization special \ud83d\udd17 Module for the package bandsaw.serialization. Contains all public types. json \ud83d\udd17 Contains a Serializer that allows to serialize objects to JSON. JsonSerializer ( Serializer ) \ud83d\udd17 A Serializer which serializes objects to JSON. Attributes: Name Type Description value_serializers List[ValueSerializer] A list of serializers that are used for serialization of custom types. deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/json.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/json.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach () pickle \ud83d\udd17 Contains a Serializer which uses pickle for serializing values. PickleSerializer ( Serializer ) \ud83d\udd17 A Serializer which serializes objects using pickle. deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/pickle.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream ) serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/pickle.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream ) serializer \ud83d\udd17 Base classes for serializers which allow to serialize python values. Serializer ( ABC ) \ud83d\udd17 Interface for Serializer which serialize objects deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" values \ud83d\udd17 A collection of classes for serializing custom objects. ExceptionSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing exceptions. The serializer saves only the type and the args attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded. can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , Exception ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state SerializableValue ( ABC ) \ud83d\udd17 Interface for types that can serialize themselves. deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/serialization/values.py @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\" serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\" SerializableValueSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing subclasses of SerializableValue . The serializer uses the methods defined in SerializableValue and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information. can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state TupleSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly. can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , tuple ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state ValueSerializer ( ABC ) \ud83d\udd17 Interface for serializers that can serialize custom values. can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\" deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\" serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\" session \ud83d\udd17 Contains classes for representing an advising session Session \ud83d\udd17 Class that handles the advising of an execution. A Session object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like def proceed(self) to continue or conclude() to end with a result, the advices can influence the final result. Additionally, the session provides access to the context , which allows advices to keep state, the execution that is advised, the configuration that is used for advising and the result of the execution. Attributes: Name Type Description task bandsaw.tasks.Task The task that is executed. run bandsaw.run.Run The run definition for the task. context bandsaw.context.Context The context that can be used for advices to store state. result bandsaw.result.Result Result of the task if already computed. Otherwise None . _configuration bandsaw.config.Configuration The configuration that is being used for advising this task. serializer property readonly \ud83d\udd17 The serializer that can be used for serializing values. __init__ ( self , task = None , run = None , configuration = None , advice_chain = 'default' ) special \ud83d\udd17 Create a new session. Source code in bandsaw/session.py def __init__ ( self , task = None , run = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . run = run self . context = {} self . result = None self . _configuration = configuration self . _advice_chain = advice_chain self . _moderator = None conclude ( self , result ) \ud83d\udd17 Conclude the process of advising with a Result . This can be used in two cases: Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given result will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there after(session) method. Concluding AFTER the task was actually executed. This will just change the result of the session and continue will all following advices. Parameters: Name Type Description Default result bandsaw.result.Result The result to conclude with. required Source code in bandsaw/session.py def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self ) initiate ( self ) \ud83d\udd17 Start the process of advising an execution. Returns: Type Description bandsaw.result.Result The final result of the execution after all advices. Source code in bandsaw/session.py def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . _configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . _configuration . extensions : extension . on_before_advice ( self . task , self . run , self . context ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . _configuration . extensions : extension . on_after_advice ( self . task , self . run , self . context , self . result ) return self . result proceed ( self ) \ud83d\udd17 Continue the process of advising with the next advice. Source code in bandsaw/session.py def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self ) restore ( self , stream ) \ud83d\udd17 Resume a prior suspended session. Source code in bandsaw/session.py def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self save ( self , stream ) \ud83d\udd17 Suspend the session to be resumed later or elsewhere. Source code in bandsaw/session.py def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream ) tasks \ud83d\udd17 Contains classes and functions representing different types of tasks Task ( SerializableValue , ABC ) \ud83d\udd17 Base-class for different types of Tasks that can be executed Attributes: Name Type Description task_id str A unique identifier for the individual tasks. source str The python source code as string which defines the task. bytecode bytes The compiled byte code of the task definition. bytecode property readonly \ud83d\udd17 The compiled byte code of the task definition as bytes . source property readonly \ud83d\udd17 The python source code as str which defines the task. create_task ( obj ) classmethod \ud83d\udd17 Factory for creating a task for different Python objects. Parameters: Name Type Description Default obj Any Python object that should be run as a task. required Returns: Type Description bandsaw.tasks.Task Instance of Task class that allows to execute the task. Exceptions: Type Description TypeError If there is no support for this type of python object. Source code in bandsaw/tasks.py @classmethod def create_task ( cls , obj ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" ) execute_run ( self , run ) \ud83d\udd17 Execute the task with the arguments specified by the run. Parameters: Name Type Description Default run bandsaw.run.Run The run definition which contains how the task should be run. required Returns: Type Description bandsaw.result.Result A Result object with either the returned value from the task or an exception that was raised by the task. Source code in bandsaw/tasks.py def execute_run ( self , run ): \"\"\" Execute the task with the arguments specified by the run. Args: run (bandsaw.run.Run): The run definition which contains how the task should be run. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( run . args , run . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result","title":"API"},{"location":"api/#bandsaw.advice","text":"Contains classes and functions for advising tasks.","title":"advice"},{"location":"api/#bandsaw.advice.Advice","text":"Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, before(session) and after(session) , that are called during the process of advising a task execution. Both take a single argument session which contains an instance of the class Session . This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result.","title":"Advice"},{"location":"api/#bandsaw.advice.Advice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def after ( self , session ): \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advice.Advice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def before ( self , session ): \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advice.advise_task_with_chain","text":"Executes an Task with additional advices. Parameters: Name Type Description Default task bandsaw.tasks.Task The task to be executed. required run bandsaw.run.Run The run definition for the task. required configuration bandsaw.config.Configuration The configuration which should be used during advising. required advice_chain str The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. 'default' Returns: Type Description bandsaw.result.Result The result of the task execution. Source code in bandsaw/advice.py def advise_task_with_chain ( task , run , configuration , advice_chain = 'default' ): \"\"\" Executes an `Task` with additional advices. Args: task (bandsaw.tasks.Task): The task to be executed. run (bandsaw.run.Run): The run definition for the task. configuration (bandsaw.config.Configuration): The configuration which should be used during advising. advice_chain (str): The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. Returns: bandsaw.result.Result: The result of the task execution. \"\"\" session = Session ( task , run , configuration , advice_chain ) return session . initiate ()","title":"advise_task_with_chain()"},{"location":"api/#bandsaw.advices","text":"Package that contains reusable Advice classes","title":"advices"},{"location":"api/#bandsaw.advices.cache","text":"Contains Advice that can cache task results in a local file system.","title":"cache"},{"location":"api/#bandsaw.advices.cache.CachingAdvice","text":"Advice that caches results in a local filesystem. Attributes: Name Type Description directory Path The path to the directory where the results are cached.","title":"CachingAdvice"},{"location":"api/#bandsaw.advices.cache.CachingAdvice.__init__","text":"Initialize self. See help(type(self)) for accurate signature. Source code in bandsaw/advices/cache.py def __init__ ( self , directory ): self . directory = pathlib . Path ( directory ) logger . info ( \"Caching artifacts in storage ' %s '\" , self . directory ) super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.advices.cache.CachingAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advices.cache.CachingAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def before ( self , session ): artifact_id = session . task . task_id revision_id = session . run . run_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.logging","text":"Contains an Advice implementation which adds logging","title":"logging"},{"location":"api/#bandsaw.advices.logging.LoggingAdvice","text":"An Advice which adds additional logging","title":"LoggingAdvice"},{"location":"api/#bandsaw.advices.logging.LoggingAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/logging.py def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . run . run_id , session . context , ) session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advices.logging.LoggingAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/logging.py def before ( self , session ): logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . run . run_id , session . context , ) session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.subprocess","text":"Contains Advice implementation that runs the execution in a subprocess","title":"subprocess"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice","text":"Advice that runs in a subprocess","title":"SubprocessAdvice"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.__init__","text":"Create a new instance. Parameters: Name Type Description Default directory str The directory where temporary files are stored to exchange data between both processes. If None a temporary directory is used. None interpreter bandsaw.interpreter.Interpreter The interpreter to use in the subprocess. If None the same interpreter will be used. None Source code in bandsaw/advices/subprocess.py def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = pathlib . Path ( tempfile . mkdtemp ()) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) session_out_path = session . context [ 'subprocess' ][ 'session_out.path' ] logger . info ( \"Writing session with result to %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'w' ) as stream : session . save ( stream )","title":"after()"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) session_id = session . run . run_id session_in_file , session_in_path = tempfile . mkstemp ( '.zip' , 'in-' + session_id + '-' , self . directory ) session_out_file , session_out_path = tempfile . mkstemp ( '.zip' , 'out-' + session_id + '-' , self . directory ) session . context [ 'subprocess' ] = { 'session_in.path' : session_in_path , 'session_out.path' : session_out_path , } logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_file , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Running subprocess using interpreter %s \" , self . interpreter . executable ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , '-m' , 'bandsaw.advices.subprocess' , '--input' , session_in_path , '--output' , session_out_path , ], env = environment , ) logger . info ( \"Sub process exited\" ) with io . FileIO ( session_out_file , mode = 'r' ) as stream : session . restore ( stream ) session . proceed ()","title":"before()"},{"location":"api/#bandsaw.config","text":"Contains the class and functions to configure bandsaw.","title":"config"},{"location":"api/#bandsaw.config.Configuration","text":"Class that represents a configuration for bandsaw.","title":"Configuration"},{"location":"api/#bandsaw.config.Configuration.add_advice_chain","text":"Add a new advice chain to the configuration. Each advice chain has a unique name . If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Parameters: Name Type Description Default *advices bandsaw.advice.Advice A tuple of advices for this chain. () name str The name of the advice chain, defaults to 'default' if not specified. 'default' Returns: Type Description bandsaw.config.Configuration The configuration to which the chain was added. Source code in bandsaw/config.py def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self","title":"add_advice_chain()"},{"location":"api/#bandsaw.config.Configuration.add_extension","text":"Add an Extension to the configuration. Extensions are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Parameters: Name Type Description Default extension bandsaw.extension.Extension An object implementing the Extension . required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self","title":"add_extension()"},{"location":"api/#bandsaw.config.Configuration.get_advice_chain","text":"Returns the advice chain with the given name. Parameters: Name Type Description Default name str Name of the wanted advice chain. required Returns: Type Description List[bandsaw.advice.Advice] The advice chain with the given name. Exceptions: Type Description KeyError If no chain with the specified name is configured. Source code in bandsaw/config.py def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name )","title":"get_advice_chain()"},{"location":"api/#bandsaw.config.Configuration.set_serializer","text":"Sets the serialize which defines how tasks and results will be serialized. Parameters: Name Type Description Default serializer bandsaw.serialization.Serializer The serializer to use for serializing objects. required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self","title":"set_serializer()"},{"location":"api/#bandsaw.config.get_configuration","text":"Return a configuration. Parameters: Name Type Description Default configuration_module str The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of Configuration . If no module name is given, a default configuration is returned based on the value of the BANDSAW_CONFIG_MODULE environment variable. If this variable is not set, we default to 'bandsaw_config'. None Returns: Type Description bandsaw.config.Configuration The configuration. Exceptions: Type Description ModuleNotFoundError If no module exists with name configuration_module . LookupError If the module doesn't contain a variable 'configuration`. TypeError If the variable configuration is not of type Configuration . Source code in bandsaw/config.py def get_configuration ( configuration_module = None ): \"\"\" Return a configuration. Args: configuration_module (str): The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of `Configuration`. If no module name is given, a default configuration is returned based on the value of the `BANDSAW_CONFIG_MODULE` environment variable. If this variable is not set, we default to 'bandsaw_config'. Returns: bandsaw.config.Configuration: The configuration. Raises: ModuleNotFoundError: If no module exists with name `configuration_module`. LookupError: If the module doesn't contain a variable 'configuration`. TypeError: If the variable `configuration` is not of type `Configuration`. \"\"\" if configuration_module is None : default_configuration_module_name = os . getenv ( CONFIGURATION_MODULE_ENV_VARIABLE , CONFIGURATION_MODULE_DEFAULT , ) configuration_module = default_configuration_module_name if configuration_module not in _configurations : try : _load_configuration_module ( configuration_module ) except ModuleNotFoundError : logger . warning ( \"No module found for config %s \" , configuration_module , ) raise return _configurations [ configuration_module ]","title":"get_configuration()"},{"location":"api/#bandsaw.context","text":"Classes that represent the context used in advising tasks.","title":"context"},{"location":"api/#bandsaw.context.Context","text":"Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the Advice classes to store state or communicate with other advices.","title":"Context"},{"location":"api/#bandsaw.context.Context.attributes","text":"A set of arbitrary key-value mappings for the Advice classes. Advice can add to this mapping and use this as a way of keeping state.","title":"attributes"},{"location":"api/#bandsaw.context.Context.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/context.py @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ])","title":"deserialize()"},{"location":"api/#bandsaw.context.Context.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/context.py def serialized ( self ): data = { 'attributes' : self . _attributes , } return data","title":"serialized()"},{"location":"api/#bandsaw.decorator","text":"Contains decorators that allow to define individual tasks","title":"decorator"},{"location":"api/#bandsaw.decorator.task","text":"Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Examples: >>> @task ... def my_task_function (): ... pass or with additional configuration. Examples: >>> @task ( config = 'my.config' ) ... def my_task_function (): ... pass Parameters: Name Type Description Default config str The name of the configuration module to use for this task. If not given, the default configuration is used. None chain str The name of the advice chain to use for advising this task. If not given, 'default' is used. None *task_args Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, task_args contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, task_args contains the positional arguments of the call of the decorator. () **task_kwargs Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, task_kwargs is an empty dictionary. If there is additional configuration given, task_kwargs contains the keyword arguments of the call of the decorator. {} Returns: Type Description Callable Returns a callable that wraps the decorated function. Exceptions: Type Description ModuleNotFoundError If the configured configuration module does not exist. ValueError If the specified advice chain does not exist. RuntimeError If the task is configured with multiple positional arguments. Source code in bandsaw/decorator.py def task ( * task_args , config = None , chain = None , ** task_kwargs ): \"\"\" Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Example: >>> @task ... def my_task_function(): ... pass or with additional configuration. Example: >>> @task(config='my.config') ... def my_task_function(): ... pass Args: config (str): The name of the configuration module to use for this task. If not given, the default configuration is used. chain (str): The name of the advice chain to use for advising this task. If not given, 'default' is used. *task_args: Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, `task_args` contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, `task_args` contains the positional arguments of the call of the decorator. **task_kwargs: Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, `task_kwargs` is an empty dictionary. If there is additional configuration given, `task_kwargs`contains the keyword arguments of the call of the decorator. Returns: Callable: Returns a callable that wraps the decorated function. Raises: ModuleNotFoundError: If the configured configuration module does not exist. ValueError: If the specified advice chain does not exist. RuntimeError: If the task is configured with multiple positional arguments. \"\"\" config_module = config configuration = get_configuration ( config_module ) chain_name = chain or 'default' chain = configuration . get_advice_chain ( chain_name ) if chain is None : raise ValueError ( f \"Unknown advice chain { chain_name } \" ) def decorate_function ( func ): logger . info ( \"Decorate function ' %s '\" , func ) logger . info ( \"Creating task for function ' %s '\" , func ) the_task = Task . create_task ( func ) def inner ( * func_args , ** func_kwargs ): run_id = _calculate_run_id ( func_args , func_kwargs , configuration . serializer , ) run = Run ( run_id , func_args , func_kwargs ) result = advise_task_with_chain ( the_task , run , configuration , chain_name , ) if result . exception : raise result . exception return result . value inner . __wrapped__ = func inner . bandsaw_task = the_task inner . bandsaw_configuration = configuration return inner if len ( task_args ) == 1 and len ( task_kwargs ) == 0 : return decorate_function ( task_args [ 0 ]) if len ( task_args ) == 0 and len ( task_kwargs ) > 0 : return decorate_function # This shouldn't happen if the decorator is properly used. raise RuntimeError ( \"Invalid 'task' decorator.\" )","title":"task()"},{"location":"api/#bandsaw.extensions","text":"Contains an API for extensions that can be used in bandsaw","title":"extensions"},{"location":"api/#bandsaw.extensions.Extension","text":"Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than Advice , an Extension is globally defined in a config and therefore applies to all tasks.","title":"Extension"},{"location":"api/#bandsaw.extensions.Extension.on_after_advice","text":"Called after bandsaw advises a task. Parameters: Name Type Description Default task bandsaw.tasks.Task The task which was advised. required run bandsaw.run.Run The run which contains the parametrization of the task. required context bandsaw.context.Context The context which was used during the advice. required result bandsaw.result.Result The result of the call. required Source code in bandsaw/extensions.py def on_after_advice ( self , task , run , context , result ): \"\"\" Called after bandsaw advises a task. Args: task (bandsaw.tasks.Task): The task which was advised. run (bandsaw.run.Run): The run which contains the parametrization of the task. context (bandsaw.context.Context): The context which was used during the advice. result (bandsaw.result.Result): The result of the call. \"\"\"","title":"on_after_advice()"},{"location":"api/#bandsaw.extensions.Extension.on_before_advice","text":"Called before bandsaw advises a task. Parameters: Name Type Description Default task bandsaw.tasks.Task The task which will be advised. required run bandsaw.run.Run The run which contains the parametrization of the task. required context bandsaw.context.Context The context which will be used during the advice. The context can be extended by the extension. required Source code in bandsaw/extensions.py def on_before_advice ( self , task , run , context ): \"\"\" Called before bandsaw advises a task. Args: task (bandsaw.tasks.Task): The task which will be advised. run (bandsaw.run.Run): The run which contains the parametrization of the task. context (bandsaw.context.Context): The context which will be used during the advice. The context can be extended by the extension. \"\"\"","title":"on_before_advice()"},{"location":"api/#bandsaw.extensions.Extension.on_init","text":"Called when a bandsaw configuration has been initialized. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration object which contains the config that has been loaded. required Source code in bandsaw/extensions.py def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\"","title":"on_init()"},{"location":"api/#bandsaw.identifier","text":"Functions for generating identifier for arbitrary python objects.","title":"identifier"},{"location":"api/#bandsaw.identifier.identifier_from_bytes","text":"Derive an identifier from a bytebuffer. Parameters: Name Type Description Default buffer Union[bytes,bytearray] The binary data from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_bytes ( buffer ): \"\"\" Derive an identifier from a bytebuffer. Args: buffer (Union[bytes,bytearray]): The binary data from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = hashlib . sha256 ( buffer ) . hexdigest () return identifier","title":"identifier_from_bytes()"},{"location":"api/#bandsaw.identifier.identifier_from_string","text":"Derive an identifier from a string. Parameters: Name Type Description Default string str The string from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_string ( string ): \"\"\" Derive an identifier from a string. Args: string (str): The string from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = identifier_from_bytes ( string . encode ( 'utf-8' )) return identifier","title":"identifier_from_string()"},{"location":"api/#bandsaw.interpreter","text":"Contains classes regarding python interpreters","title":"interpreter"},{"location":"api/#bandsaw.interpreter.Interpreter","text":"Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined.","title":"Interpreter"},{"location":"api/#bandsaw.interpreter.Interpreter.environment","text":"The environment variables to be set for the interpreter.","title":"environment"},{"location":"api/#bandsaw.interpreter.Interpreter.path","text":"The python path items that will be used.","title":"path"},{"location":"api/#bandsaw.interpreter.Interpreter.__init__","text":"Create a new interpreter instance. Parameters: Name Type Description Default path List[str] A list of directory paths, to be used as $PYTHONPATH. If None the current sys.path is used. None executable str The path to the python executable for this interpreter. If None the current sys.executable is used. None Source code in bandsaw/interpreter.py def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" self . _path = path or tuple ( sys . path ) self . executable = executable or sys . executable self . _environment = {}","title":"__init__()"},{"location":"api/#bandsaw.interpreter.Interpreter.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/interpreter.py @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ])","title":"deserialize()"},{"location":"api/#bandsaw.interpreter.Interpreter.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/interpreter.py def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , }","title":"serialized()"},{"location":"api/#bandsaw.interpreter.Interpreter.set_environment","text":"Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Parameters: Name Type Description Default **environment Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. {} Source code in bandsaw/interpreter.py def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self","title":"set_environment()"},{"location":"api/#bandsaw.io","text":"Contains classes related to input/output of data.","title":"io"},{"location":"api/#bandsaw.io.BytearrayGeneratorToStream","text":"Stream that reads from a generator that yields bytes/bytearrays.","title":"BytearrayGeneratorToStream"},{"location":"api/#bandsaw.io.read_stream_to_generator","text":"Read from a stream into a generator yielding bytes . Parameters: Name Type Description Default stream io.Stream The stream to read bytes from. required buffer_size int The buffer size to read. Each individual bytes buffer returned by the generator has a maximum size of buffer_size . Defaults to 8192 if not set. 8192 !!! yields bytes: A byte buffer of maximum size of buffer_size . Source code in bandsaw/io.py def read_stream_to_generator ( stream , buffer_size = 8192 ): \"\"\" Read from a stream into a generator yielding `bytes`. Args: stream (io.Stream): The stream to read bytes from. buffer_size (int): The buffer size to read. Each individual `bytes` buffer returned by the generator has a maximum size of `buffer_size`. Defaults to `8192` if not set. Yields: bytes: A byte buffer of maximum size of `buffer_size`. \"\"\" buffer = bytearray ( buffer_size ) while True : read = stream . readinto ( buffer ) if read : yield buffer [: read ] else : break","title":"read_stream_to_generator()"},{"location":"api/#bandsaw.modules","text":"Utility functions for handling python modules.","title":"modules"},{"location":"api/#bandsaw.modules.get_loaded_module_name_by_path","text":"Determine the name of an already loaded module by its file path. Parameters: Name Type Description Default file_path str File path of the python file containing the module. required Returns: Type Description str The name of the module, or None if the file isn't loaded as a module. Source code in bandsaw/modules.py def get_loaded_module_name_by_path ( file_path ): \"\"\" Determine the name of an already loaded module by its file path. Args: file_path (str): File path of the python file containing the module. Returns: str: The name of the module, or `None` if the file isn't loaded as a module. \"\"\" real_path = os . path . realpath ( file_path ) for name , module in sys . modules . items (): if hasattr ( module , '__file__' ): module_path = os . path . realpath ( module . __file__ ) if module_path == real_path : return name return None","title":"get_loaded_module_name_by_path()"},{"location":"api/#bandsaw.modules.import_object","text":"Import a python object from a module. Parameters: Name Type Description Default object_name str The name under which the object is defined in the module. required module_name str The name of the module from which the object should be imported. required Returns: Type Description object The python object defined under the name. Exceptions: Type Description AttributeError If nothing is defined with name object_name in the referenced module. ModuleNotFoundError If no module exists with the name module_name . Source code in bandsaw/modules.py def import_object ( object_name , module_name ): \"\"\" Import a python object from a module. Args: object_name (str): The name under which the object is defined in the module. module_name (str): The name of the module from which the object should be imported. Returns: object: The python object defined under the name. Raises: AttributeError: If nothing is defined with name `object_name` in the referenced module. ModuleNotFoundError: If no module exists with the name `module_name`. \"\"\" module = importlib . import_module ( module_name ) return getattr ( module , object_name )","title":"import_object()"},{"location":"api/#bandsaw.modules.object_as_import","text":"Returns the name and module of an object, which can be used for importing it. Parameters: Name Type Description Default obj object An arbitrary Python object. required Returns: Type Description Tuple(str, str) Returns a tuple of the object name and the module name in which the object is defined. Exceptions: Type Description ValueError If obj doesn't have a name that can be directly imported, e.g. because it is defined within a local class. !!! note If obj is defined within the __main__ script, the function tries to determine a name for the __main__ module, under which it could be imported from other scripts. Source code in bandsaw/modules.py def object_as_import ( obj ): \"\"\" Returns the name and module of an object, which can be used for importing it. Args: obj (object): An arbitrary Python object. Returns: Tuple(str, str): Returns a tuple of the object name and the module name in which the object is defined. Raises: ValueError: If `obj` doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note: If `obj` is defined within the `__main__` script, the function tries to determine a name for the `__main__` module, under which it could be imported from other scripts. \"\"\" object_name = obj . __name__ module_name = obj . __module__ if module_name == '__main__' : module_file_path = sys . modules [ '__main__' ] . __file__ module_name = _guess_module_name_by_path ( module_file_path , sys . path ) if '<locals>' in obj . __qualname__ : raise ValueError ( \"Can't import local functions.\" ) return object_name , module_name","title":"object_as_import()"},{"location":"api/#bandsaw.result","text":"Contains code for representing the result of tasks.","title":"result"},{"location":"api/#bandsaw.result.Result","text":"Class to encapsulate the result of a task execution. Attributes: Name Type Description value Any The value that is returned by the task. None is the task raised an exception during execution. exception Exception The exception that was raised during execution, None if no exception was raised.","title":"Result"},{"location":"api/#bandsaw.result.Result.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/result.py @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception )","title":"deserialize()"},{"location":"api/#bandsaw.result.Result.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/result.py def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values","title":"serialized()"},{"location":"api/#bandsaw.run","text":"Contains classes and functions around a run of tasks","title":"run"},{"location":"api/#bandsaw.run.Run","text":"Class that defines a run of a Task . Attributes: Name Type Description run_id str A string identifying this run. args tuple[Any] The positional arguments for the task to use in this execution. kwargs Dict[Any,Any] The keyword arguments for the task to use in this execution.","title":"Run"},{"location":"api/#bandsaw.run.Run.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/run.py @classmethod def deserialize ( cls , values ): return Run ( values [ 'run_id' ], values [ 'args' ], values [ 'kwargs' ], )","title":"deserialize()"},{"location":"api/#bandsaw.run.Run.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/run.py def serialized ( self ): return { 'run_id' : self . run_id , 'args' : self . args , 'kwargs' : self . kwargs , }","title":"serialized()"},{"location":"api/#bandsaw.serialization","text":"Module for the package bandsaw.serialization. Contains all public types.","title":"serialization"},{"location":"api/#bandsaw.serialization.json","text":"Contains a Serializer that allows to serialize objects to JSON.","title":"json"},{"location":"api/#bandsaw.serialization.json.JsonSerializer","text":"A Serializer which serializes objects to JSON. Attributes: Name Type Description value_serializers List[ValueSerializer] A list of serializers that are used for serialization of custom types.","title":"JsonSerializer"},{"location":"api/#bandsaw.serialization.json.JsonSerializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/json.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result","title":"deserialize()"},{"location":"api/#bandsaw.serialization.json.JsonSerializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/json.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach ()","title":"serialize()"},{"location":"api/#bandsaw.serialization.pickle","text":"Contains a Serializer which uses pickle for serializing values.","title":"pickle"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer","text":"A Serializer which serializes objects using pickle.","title":"PickleSerializer"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/pickle.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream )","title":"deserialize()"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/pickle.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream )","title":"serialize()"},{"location":"api/#bandsaw.serialization.serializer","text":"Base classes for serializers which allow to serialize python values.","title":"serializer"},{"location":"api/#bandsaw.serialization.serializer.Serializer","text":"Interface for Serializer which serialize objects","title":"Serializer"},{"location":"api/#bandsaw.serialization.serializer.Serializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\"","title":"deserialize()"},{"location":"api/#bandsaw.serialization.serializer.Serializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\"","title":"serialize()"},{"location":"api/#bandsaw.serialization.values","text":"A collection of classes for serializing custom objects.","title":"values"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer","text":"A ValueSerializer for serializing exceptions. The serializer saves only the type and the args attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded.","title":"ExceptionSerializer"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , Exception )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValue","text":"Interface for types that can serialize themselves.","title":"SerializableValue"},{"location":"api/#bandsaw.serialization.values.SerializableValue.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/serialization/values.py @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\"","title":"deserialize()"},{"location":"api/#bandsaw.serialization.values.SerializableValue.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\"","title":"serialized()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer","text":"A ValueSerializer for serializing subclasses of SerializableValue . The serializer uses the methods defined in SerializableValue and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information.","title":"SerializableValueSerializer"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer","text":"A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly.","title":"TupleSerializer"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , tuple )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer","text":"Interface for serializers that can serialize custom values.","title":"ValueSerializer"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\"","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\"","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\"","title":"serialize_value()"},{"location":"api/#bandsaw.session","text":"Contains classes for representing an advising session","title":"session"},{"location":"api/#bandsaw.session.Session","text":"Class that handles the advising of an execution. A Session object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like def proceed(self) to continue or conclude() to end with a result, the advices can influence the final result. Additionally, the session provides access to the context , which allows advices to keep state, the execution that is advised, the configuration that is used for advising and the result of the execution. Attributes: Name Type Description task bandsaw.tasks.Task The task that is executed. run bandsaw.run.Run The run definition for the task. context bandsaw.context.Context The context that can be used for advices to store state. result bandsaw.result.Result Result of the task if already computed. Otherwise None . _configuration bandsaw.config.Configuration The configuration that is being used for advising this task.","title":"Session"},{"location":"api/#bandsaw.session.Session.serializer","text":"The serializer that can be used for serializing values.","title":"serializer"},{"location":"api/#bandsaw.session.Session.__init__","text":"Create a new session. Source code in bandsaw/session.py def __init__ ( self , task = None , run = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . run = run self . context = {} self . result = None self . _configuration = configuration self . _advice_chain = advice_chain self . _moderator = None","title":"__init__()"},{"location":"api/#bandsaw.session.Session.conclude","text":"Conclude the process of advising with a Result . This can be used in two cases: Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given result will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there after(session) method. Concluding AFTER the task was actually executed. This will just change the result of the session and continue will all following advices. Parameters: Name Type Description Default result bandsaw.result.Result The result to conclude with. required Source code in bandsaw/session.py def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self )","title":"conclude()"},{"location":"api/#bandsaw.session.Session.initiate","text":"Start the process of advising an execution. Returns: Type Description bandsaw.result.Result The final result of the execution after all advices. Source code in bandsaw/session.py def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . _configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . _configuration . extensions : extension . on_before_advice ( self . task , self . run , self . context ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . _configuration . extensions : extension . on_after_advice ( self . task , self . run , self . context , self . result ) return self . result","title":"initiate()"},{"location":"api/#bandsaw.session.Session.proceed","text":"Continue the process of advising with the next advice. Source code in bandsaw/session.py def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self )","title":"proceed()"},{"location":"api/#bandsaw.session.Session.restore","text":"Resume a prior suspended session. Source code in bandsaw/session.py def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self","title":"restore()"},{"location":"api/#bandsaw.session.Session.save","text":"Suspend the session to be resumed later or elsewhere. Source code in bandsaw/session.py def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream )","title":"save()"},{"location":"api/#bandsaw.tasks","text":"Contains classes and functions representing different types of tasks","title":"tasks"},{"location":"api/#bandsaw.tasks.Task","text":"Base-class for different types of Tasks that can be executed Attributes: Name Type Description task_id str A unique identifier for the individual tasks. source str The python source code as string which defines the task. bytecode bytes The compiled byte code of the task definition.","title":"Task"},{"location":"api/#bandsaw.tasks.Task.bytecode","text":"The compiled byte code of the task definition as bytes .","title":"bytecode"},{"location":"api/#bandsaw.tasks.Task.source","text":"The python source code as str which defines the task.","title":"source"},{"location":"api/#bandsaw.tasks.Task.create_task","text":"Factory for creating a task for different Python objects. Parameters: Name Type Description Default obj Any Python object that should be run as a task. required Returns: Type Description bandsaw.tasks.Task Instance of Task class that allows to execute the task. Exceptions: Type Description TypeError If there is no support for this type of python object. Source code in bandsaw/tasks.py @classmethod def create_task ( cls , obj ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" )","title":"create_task()"},{"location":"api/#bandsaw.tasks.Task.execute_run","text":"Execute the task with the arguments specified by the run. Parameters: Name Type Description Default run bandsaw.run.Run The run definition which contains how the task should be run. required Returns: Type Description bandsaw.result.Result A Result object with either the returned value from the task or an exception that was raised by the task. Source code in bandsaw/tasks.py def execute_run ( self , run ): \"\"\" Execute the task with the arguments specified by the run. Args: run (bandsaw.run.Run): The run definition which contains how the task should be run. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( run . args , run . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result","title":"execute_run()"},{"location":"changelog/","text":"Changelog \ud83d\udd17 0.1: Initial release of the package. \ud83d\udd17 Support for free functions as tasks Ability to run tasks in subprocesses Ability to execute tasks with different python interpreters Simple file system cache for caching task results","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#01-initial-release-of-the-package","text":"Support for free functions as tasks Ability to run tasks in subprocesses Ability to execute tasks with different python interpreters Simple file system cache for caching task results","title":"0.1: Initial release of the package."},{"location":"faq/","text":"FAQ \ud83d\udd17 Why do I have to configure bandsaw in a separate module? \ud83d\udd17 Since bandsaw can be integrated in arbitrary python scripts, we need to make sure that as soon as the bandsaw.task decorator is used first time, it is properly configured. By using a separate module, that bandsaw can import as needed, the library doesn't depend on the user setting the configuration upfront.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-do-i-have-to-configure-bandsaw-in-a-separate-module","text":"Since bandsaw can be integrated in arbitrary python scripts, we need to make sure that as soon as the bandsaw.task decorator is used first time, it is properly configured. By using a separate module, that bandsaw can import as needed, the library doesn't depend on the user setting the configuration upfront.","title":"Why do I have to configure bandsaw in a separate module?"},{"location":"getting_started/","text":"Getting started \ud83d\udd17 Install the library \ud83d\udd17 Install the latest version from PyPI using pip: pip install bandsaw Define the individual tasks of your workflow \ud83d\udd17 Import the @task decorator from the bandsaw package and decorate a function with it: import bandsaw ... @bandsaw . task def my_function ( x ): ... return x Configure bandsaw \ud83d\udd17 Create a new python module bandsaw_config and add first advice that just adds some additional logging when a task is executed: import bandsaw configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . logging . LoggingAdvice (), ) Run your workflow \ud83d\udd17 When you now run your workflow, bandsaw intercepts the execution of my_function and its LoggingAdvice prints out additional log messages before() and after() it, e.g.: $ python my_script.py ... 2021 -10-27 13 :13:51,940 2290 bandsaw.advices.logging INFO: BEFORE 0d268ac0..4213:76560cb4..a37d with context {} ... 2021 -10-27 13 :13:52,127 2290 bandsaw.advices.logging INFO: AFTER 0d268ac0..4213:76560cb4..a37d with context {} ... The log messages contain the task_id (0d268ac0..4213), which is derived from the code that is decorated, and the run_id (76560cb4..a37d), derived from the arguments that my_function was called with. Where to go from here? \ud83d\udd17 Read the user guide for some more in-depth explanation about bandsaw and its concepts. Alternatively, bandsaw brings with it a couple of useful advice classes, that can be used just by adding them to its configuration: Running tasks in a subprocess or with a different python interpreter: bandsaw.advices.subprocess.SubprocessAdvice Caching the result of a task: bandsaw.advices.cache.CachingAdvice Running tasks on a different machine using SSH (Coming soon): bandsaw.advices.remote.SshAdvice Capturing the resource usage of a task (Coming soon): bandsaw.advices.profile.ProfilingAdvice Running tasks on asynchronously (Coming soon): bandsaw.advices.async.AsyncAdvice Creating your own advice: How to write your own advice?","title":"Getting started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#install-the-library","text":"Install the latest version from PyPI using pip: pip install bandsaw","title":"Install the library"},{"location":"getting_started/#define-the-individual-tasks-of-your-workflow","text":"Import the @task decorator from the bandsaw package and decorate a function with it: import bandsaw ... @bandsaw . task def my_function ( x ): ... return x","title":"Define the individual tasks of your workflow"},{"location":"getting_started/#configure-bandsaw","text":"Create a new python module bandsaw_config and add first advice that just adds some additional logging when a task is executed: import bandsaw configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . logging . LoggingAdvice (), )","title":"Configure bandsaw"},{"location":"getting_started/#run-your-workflow","text":"When you now run your workflow, bandsaw intercepts the execution of my_function and its LoggingAdvice prints out additional log messages before() and after() it, e.g.: $ python my_script.py ... 2021 -10-27 13 :13:51,940 2290 bandsaw.advices.logging INFO: BEFORE 0d268ac0..4213:76560cb4..a37d with context {} ... 2021 -10-27 13 :13:52,127 2290 bandsaw.advices.logging INFO: AFTER 0d268ac0..4213:76560cb4..a37d with context {} ... The log messages contain the task_id (0d268ac0..4213), which is derived from the code that is decorated, and the run_id (76560cb4..a37d), derived from the arguments that my_function was called with.","title":"Run your workflow"},{"location":"getting_started/#where-to-go-from-here","text":"Read the user guide for some more in-depth explanation about bandsaw and its concepts. Alternatively, bandsaw brings with it a couple of useful advice classes, that can be used just by adding them to its configuration: Running tasks in a subprocess or with a different python interpreter: bandsaw.advices.subprocess.SubprocessAdvice Caching the result of a task: bandsaw.advices.cache.CachingAdvice Running tasks on a different machine using SSH (Coming soon): bandsaw.advices.remote.SshAdvice Capturing the resource usage of a task (Coming soon): bandsaw.advices.profile.ProfilingAdvice Running tasks on asynchronously (Coming soon): bandsaw.advices.async.AsyncAdvice Creating your own advice: How to write your own advice?","title":"Where to go from here?"},{"location":"user_guide/","text":"User guide \ud83d\udd17 This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the bandsaw library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own advices or extensions. Concepts \ud83d\udd17 First we start with some high-level concepts that we use throughout the library. The purpose of this sections is to explain the structure of bandsaw and introduce a common set of terms that helps to talk about the underlying ideas Workflow \ud83d\udd17 The fundamental basis in bandsaw is the idea of a workflow. We think of a workflow as a single python script, that contains code for all individual steps that are performed in a defined sequence. The individual steps can have dependencies on external inputs and on results of other steps, so that they form a directed acyclic graph. Those steps are referred to as Tasks within bandsaw. Tasks \ud83d\udd17 Tasks are pieces of code, that are used to process data. Task instances can be created by calling the create_task(cls, obj) class function in the Task class. At the moment, bandsaw supports only free functions defined on module level as tasks. Usually, tasks are defined by adding the @bandsaw.task decorator to the code that should be executed as a task. @bandsaw . task def my_function ( x ): return x Each task has a unique task_id that is derived from the code that is executed. This can be used to differentiate between different tasks. Runs \ud83d\udd17 Tasks can take arbitrary arguments, which means we can have multiple executions of the same task, that differ in the given arguments. This is captured by a Run object, which encapsulates the arguments for a specific task execution. Similar to the task_id , each run has a separate run_id that differentiates between different runs. Advice \ud83d\udd17 Objects that implement the Advice protocol are the mechanism that allows bandsaw to influence the execution of the task. Each advice class can implement two different methods, before(self, session) and after(self, session) . The before() method is called before the task is actually executed and allows the advice to make changes to the way the task is executed, e.g. running the task on a different system or returning a result early without executing the task at all. The after() method is called after the task was actually executed and returned a result. This allows an advice to make changes to the result or use it in a different way than just returning it. Both methods decide on what happens after by calling the appropriate method on the current session , the sole argument both methods are taking. Session \ud83d\udd17 A Session is the object, that manages the process of executing a task for a specific run. It defines the different actions that advices can take when their before() or after() methods are called. When a task is being called within a workflow, a new Session object is instantiated with the task, a run object containing the tasks arguments and a list of advices, called the \"advice chain\", that should be used for advising the execution. before() executing a task. \ud83d\udd17 The session calls the before() methods of all advices one after another in the order that the advices are defined in the advice chain. Each Advice has to tell the session to either continue with the next advice by calling session.proceed() or return early by skipping the following advices AND the actual task execution by calling session.conclude(result) and providing a Result that should be used instead. After the advice has concluded with a result, the only advices whose after() methods will be called are the advices, that come before in the advice chain. Executing the task \ud83d\udd17 If all advices of the advice chain decided to proceed() , the session will execute that task and keep the value it returns. If an exception or error is raised during the execution it will be stored in the Result instance in the session. after() executing a task \ud83d\udd17 After the task has been executed, the session begins to call the after() methods of the advices in the REVERSED order from the advice chain. This means the advice that was called last for before() is called first for after() . Now each advice can decide how to continue. Similar to before() there are two possibilities: continue with the current result and the next advice by calling session.proceed() or return a different result and continue with that by calling session.conclude(result) with a different Result instance. All following advices will be called using after() with a session containing the new result. Once all advices have finished, the session will unpack the result and either return its value to the workflow or re-raise the error. Serializing the session \ud83d\udd17 In order to move the execution of a task across different python interpreters, an advice can use the capability of a Session to serialize its state to a stream and recreate it at a later point in time or on a different platform. For this the session contains two methods, save(stream) and restore(stream) . Both methods will (de-)serialize the complete session including context, task, run and result. The only thing missing here are the objects from the advice chain, since bandsaw can't enforce them to be serializable. This means, that the same advice chain with the same name must be available from the configuration at the time, the session is restored. For an example, how transfer to a different python interpreter can be implemented, please look at the implementation of the SubprocessAdvice . Configuration \ud83d\udd17 Bandsaw needs configuration to know which advices to apply to the individual tasks. This configuration is given in form of an object of the bandsaw.config.Configuration class. Just creating a new Configuration object will create an empty, but working configuration, that actually does nothing and executes tasks without any changes. import bandsaw configuration = bandsaw . Configuration () The class has all the required methods to configure the different aspects of bandsaw. Advice chains \ud83d\udd17 An advice chain is a sequence of objects implementing the Advice protocol, that should be used for advising task executions. An advice chain is added to the configuration using the add_device_chain(*advices, name='default') method. It takes instances of Advice as positional arguments with an optional name keyword argument. ... configuration . add_device_chain ( bandsaw . advices . logging . LoggingAdvice (), ) Each advice chain has a name, that can be used to choose which chain to use per task. If no name is given, the chain with name 'default' is configured. Already existing chains will be overwritten. So if you configure two different advice chains, with no or the same name, the latter will replace the former. Serializer \ud83d\udd17 In order to transfer tasks between different python interpreters, bandsaw needs the capability to serialize tasks, their arguments and internal classes. For this bandsaw defines a Serializer base class, that can be implemented to support different types of serialization. Which serializer to use, can be configured as part of the configuration: from bandsaw.serialization.json import JsonSerializer ... configuration . set_serializer ( JsonSerializer ()) Bandsaw comes with two different serialization formats: Pickle \ud83d\udd17 The PickleSerializer has the advantage, that it works out of the box with most standard python types. It uses the standard python pickle library to serialize python objects and should work across different python versions. If custom types need to be serialized (e.g. as part of some arguments to a task), that don't work with pickle, support for pickle can easily be added . One disadvantage of pickle is that sometimes the serialized representation of a value is not unique. Since bandsaw uses the serialized form of arguments to derive the run_id of a run, this can lead to inconsistencies, when the same arguments can lead to different run_ids. Json \ud83d\udd17 The JsonSerializer uses JSON as format for the serialized data. The standard json library supports only primitive types like strings, dict, int etc. so for all complex types one need to explicitly add code to serialize them. Bandsaw implements support for serializing exceptions, tuples and all of its internal classes, so that they can be serialized to json. To serialize a custom type to json, bandsaw offers two options: Implement SerializableValue \ud83d\udd17 The easiest way to make your custom type json serializable is to inherit from the SerializableValue base class and implement the abstract methods serialized(self) and deserialize(cls, values) . serialized(self) must return a value that is json serializable (e.g. a dict containing only primitives). The class method deserialize(cls, values) is given this value and returns a new instance of the class. Create a ValueSerializer \ud83d\udd17 If the custom type can't be changed, there is the option to create a new ValueSerializer class that can serialize this type. It consists of 3 different methods: can_serialize_value(self, value) Has to return True if value is of the type that this particular serializer can serialize. serialize_value(self, value) Has to return the serialized representation of the type, consisting only of primitives that are json serializable. deserialize_value(self, representation) Has to return a new instance of custom_type from its serialized representation. Finally, the new ValueSerializer needs to be added to the json serializer as part of the configuration: configuration . serializer . value_serializers . append ( MyValueSerializer ()) How to use bandsaw \ud83d\udd17 Now with some knowledge about the different concepts within bandsaw at our hands, let's dive into the topic of how to put the library to good use. Install the library \ud83d\udd17 Use stable release from PyPI \ud83d\udd17 All stable versions of bandsaw are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install bandsaw Use from source \ud83d\udd17 Bandsaw's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/bandsaw.git $ cd bandsaw If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local bandsaw repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/bandsaw\" Defining the individual tasks of your workflow \ud83d\udd17 In order to use bandsaw in your workflow, you first have to import its package. import bandsaw ... Splitting up your workflow into individual tasks can be done by annotating the individual functions with the bandsaw.task decorator: @bandsaw . task def my_function ( x ): ... return x The decorator can be only applied to free functions in the current implementation, so it isn't possible to decorate methods of classes for now : class MyClass : @bandsaw . task def my_method ( self , x ): return x Configure bandsaw \ud83d\udd17 Bandsaw loads its configuration automatically at the time it is needed. This happens by dynamically importing a python module that contains an instance of the class Configuration assigned to the variable configuration . import bandsaw configuration = bandsaw . Configuration () Bandsaw expects the configuration to be found in the python module bandsaw_config . The name of the module can be changed in two ways: Set the BANDSAW_CONFIG environment variable to a different module name. Bandsaw reads the name of the module containing the configuration from this variable if it is set. So by setting it to e.g. my_config it will import my_config and take the configuration from it instead. Add an additional keyword argument to the @task decorator that contains the name of the configuration to use for this task: @bandsaw . task ( config = 'my_config_module' ) def my_function ( x ): ... return x By adding the config keyword argument we can choose the configuration we want to use per task. The existence of the configuration is checked as soon as the decorator is being applied. If no configuration could be loaded, an error is raised , usually at module import time. Choose the advice chain \ud83d\udd17 Each task can define, which advice chain should be used. This can be done, by adding a keyword argument chain to the task decorator: @bandsaw . task ( chain = 'my_chain' ) def my_function ( x ): ... return x If no chain exists with the specified name, a KeyError is raised . Extending bandsaw \ud83d\udd17 Bandsaw is extensible and allows developers to add new functionality in various ways: Implementing custom advices \ud83d\udd17 Advices are the main building blocks for adding new functionality. Implementing an advice is easy, the only necessary work is to adhere to a protocol and follow some simple rules. The protocol is defined in Advice and consists of two methods, before(self, session) and after(self, session) . Advices have to call the session. When called via before() and after() , the advice is responsible for telling the session how to continue. They must call once either session.proceed() or session.conclude() . Failure to do so, will lead to a RuntimeError raised by the session. Advices shouldn't keep state themselves. Advice instances are used for multiple tasks. Therefore, their implementation shouldn't store any task specific state themselves. If task specific state is necessary, it can be easily added to the context of the session. Advices may be instantiated multiple times and on different machines. Everytime a task is transferred to a different python interpreter, its configuration and with it the configured advices are instantiated again, even if they aren't actually called. Therefore, advices shouldn't do much work or interact with their environment at instantiation time, but only when they are actually called via after() or before() . Usually they can assume that both methods are called in the same environment for the same task.","title":"User guide"},{"location":"user_guide/#user-guide","text":"This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the bandsaw library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own advices or extensions.","title":"User guide"},{"location":"user_guide/#concepts","text":"First we start with some high-level concepts that we use throughout the library. The purpose of this sections is to explain the structure of bandsaw and introduce a common set of terms that helps to talk about the underlying ideas","title":"Concepts"},{"location":"user_guide/#workflow","text":"The fundamental basis in bandsaw is the idea of a workflow. We think of a workflow as a single python script, that contains code for all individual steps that are performed in a defined sequence. The individual steps can have dependencies on external inputs and on results of other steps, so that they form a directed acyclic graph. Those steps are referred to as Tasks within bandsaw.","title":"Workflow"},{"location":"user_guide/#tasks","text":"Tasks are pieces of code, that are used to process data. Task instances can be created by calling the create_task(cls, obj) class function in the Task class. At the moment, bandsaw supports only free functions defined on module level as tasks. Usually, tasks are defined by adding the @bandsaw.task decorator to the code that should be executed as a task. @bandsaw . task def my_function ( x ): return x Each task has a unique task_id that is derived from the code that is executed. This can be used to differentiate between different tasks.","title":"Tasks"},{"location":"user_guide/#runs","text":"Tasks can take arbitrary arguments, which means we can have multiple executions of the same task, that differ in the given arguments. This is captured by a Run object, which encapsulates the arguments for a specific task execution. Similar to the task_id , each run has a separate run_id that differentiates between different runs.","title":"Runs"},{"location":"user_guide/#advice","text":"Objects that implement the Advice protocol are the mechanism that allows bandsaw to influence the execution of the task. Each advice class can implement two different methods, before(self, session) and after(self, session) . The before() method is called before the task is actually executed and allows the advice to make changes to the way the task is executed, e.g. running the task on a different system or returning a result early without executing the task at all. The after() method is called after the task was actually executed and returned a result. This allows an advice to make changes to the result or use it in a different way than just returning it. Both methods decide on what happens after by calling the appropriate method on the current session , the sole argument both methods are taking.","title":"Advice"},{"location":"user_guide/#session","text":"A Session is the object, that manages the process of executing a task for a specific run. It defines the different actions that advices can take when their before() or after() methods are called. When a task is being called within a workflow, a new Session object is instantiated with the task, a run object containing the tasks arguments and a list of advices, called the \"advice chain\", that should be used for advising the execution.","title":"Session"},{"location":"user_guide/#before-executing-a-task","text":"The session calls the before() methods of all advices one after another in the order that the advices are defined in the advice chain. Each Advice has to tell the session to either continue with the next advice by calling session.proceed() or return early by skipping the following advices AND the actual task execution by calling session.conclude(result) and providing a Result that should be used instead. After the advice has concluded with a result, the only advices whose after() methods will be called are the advices, that come before in the advice chain.","title":"before() executing a task."},{"location":"user_guide/#executing-the-task","text":"If all advices of the advice chain decided to proceed() , the session will execute that task and keep the value it returns. If an exception or error is raised during the execution it will be stored in the Result instance in the session.","title":"Executing the task"},{"location":"user_guide/#after-executing-a-task","text":"After the task has been executed, the session begins to call the after() methods of the advices in the REVERSED order from the advice chain. This means the advice that was called last for before() is called first for after() . Now each advice can decide how to continue. Similar to before() there are two possibilities: continue with the current result and the next advice by calling session.proceed() or return a different result and continue with that by calling session.conclude(result) with a different Result instance. All following advices will be called using after() with a session containing the new result. Once all advices have finished, the session will unpack the result and either return its value to the workflow or re-raise the error.","title":"after() executing a task"},{"location":"user_guide/#serializing-the-session","text":"In order to move the execution of a task across different python interpreters, an advice can use the capability of a Session to serialize its state to a stream and recreate it at a later point in time or on a different platform. For this the session contains two methods, save(stream) and restore(stream) . Both methods will (de-)serialize the complete session including context, task, run and result. The only thing missing here are the objects from the advice chain, since bandsaw can't enforce them to be serializable. This means, that the same advice chain with the same name must be available from the configuration at the time, the session is restored. For an example, how transfer to a different python interpreter can be implemented, please look at the implementation of the SubprocessAdvice .","title":"Serializing the session"},{"location":"user_guide/#configuration","text":"Bandsaw needs configuration to know which advices to apply to the individual tasks. This configuration is given in form of an object of the bandsaw.config.Configuration class. Just creating a new Configuration object will create an empty, but working configuration, that actually does nothing and executes tasks without any changes. import bandsaw configuration = bandsaw . Configuration () The class has all the required methods to configure the different aspects of bandsaw.","title":"Configuration"},{"location":"user_guide/#advice-chains","text":"An advice chain is a sequence of objects implementing the Advice protocol, that should be used for advising task executions. An advice chain is added to the configuration using the add_device_chain(*advices, name='default') method. It takes instances of Advice as positional arguments with an optional name keyword argument. ... configuration . add_device_chain ( bandsaw . advices . logging . LoggingAdvice (), ) Each advice chain has a name, that can be used to choose which chain to use per task. If no name is given, the chain with name 'default' is configured. Already existing chains will be overwritten. So if you configure two different advice chains, with no or the same name, the latter will replace the former.","title":"Advice chains"},{"location":"user_guide/#serializer","text":"In order to transfer tasks between different python interpreters, bandsaw needs the capability to serialize tasks, their arguments and internal classes. For this bandsaw defines a Serializer base class, that can be implemented to support different types of serialization. Which serializer to use, can be configured as part of the configuration: from bandsaw.serialization.json import JsonSerializer ... configuration . set_serializer ( JsonSerializer ()) Bandsaw comes with two different serialization formats:","title":"Serializer"},{"location":"user_guide/#pickle","text":"The PickleSerializer has the advantage, that it works out of the box with most standard python types. It uses the standard python pickle library to serialize python objects and should work across different python versions. If custom types need to be serialized (e.g. as part of some arguments to a task), that don't work with pickle, support for pickle can easily be added . One disadvantage of pickle is that sometimes the serialized representation of a value is not unique. Since bandsaw uses the serialized form of arguments to derive the run_id of a run, this can lead to inconsistencies, when the same arguments can lead to different run_ids.","title":"Pickle"},{"location":"user_guide/#json","text":"The JsonSerializer uses JSON as format for the serialized data. The standard json library supports only primitive types like strings, dict, int etc. so for all complex types one need to explicitly add code to serialize them. Bandsaw implements support for serializing exceptions, tuples and all of its internal classes, so that they can be serialized to json. To serialize a custom type to json, bandsaw offers two options:","title":"Json"},{"location":"user_guide/#implement-serializablevalue","text":"The easiest way to make your custom type json serializable is to inherit from the SerializableValue base class and implement the abstract methods serialized(self) and deserialize(cls, values) . serialized(self) must return a value that is json serializable (e.g. a dict containing only primitives). The class method deserialize(cls, values) is given this value and returns a new instance of the class.","title":"Implement SerializableValue"},{"location":"user_guide/#create-a-valueserializer","text":"If the custom type can't be changed, there is the option to create a new ValueSerializer class that can serialize this type. It consists of 3 different methods: can_serialize_value(self, value) Has to return True if value is of the type that this particular serializer can serialize. serialize_value(self, value) Has to return the serialized representation of the type, consisting only of primitives that are json serializable. deserialize_value(self, representation) Has to return a new instance of custom_type from its serialized representation. Finally, the new ValueSerializer needs to be added to the json serializer as part of the configuration: configuration . serializer . value_serializers . append ( MyValueSerializer ())","title":"Create a ValueSerializer"},{"location":"user_guide/#how-to-use-bandsaw","text":"Now with some knowledge about the different concepts within bandsaw at our hands, let's dive into the topic of how to put the library to good use.","title":"How to use bandsaw"},{"location":"user_guide/#install-the-library","text":"","title":"Install the library"},{"location":"user_guide/#use-stable-release-from-pypi","text":"All stable versions of bandsaw are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install bandsaw","title":"Use stable release from PyPI"},{"location":"user_guide/#use-from-source","text":"Bandsaw's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/bandsaw.git $ cd bandsaw If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local bandsaw repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/bandsaw\"","title":"Use from source"},{"location":"user_guide/#defining-the-individual-tasks-of-your-workflow","text":"In order to use bandsaw in your workflow, you first have to import its package. import bandsaw ... Splitting up your workflow into individual tasks can be done by annotating the individual functions with the bandsaw.task decorator: @bandsaw . task def my_function ( x ): ... return x The decorator can be only applied to free functions in the current implementation, so it isn't possible to decorate methods of classes for now : class MyClass : @bandsaw . task def my_method ( self , x ): return x","title":"Defining the individual tasks of your workflow"},{"location":"user_guide/#configure-bandsaw","text":"Bandsaw loads its configuration automatically at the time it is needed. This happens by dynamically importing a python module that contains an instance of the class Configuration assigned to the variable configuration . import bandsaw configuration = bandsaw . Configuration () Bandsaw expects the configuration to be found in the python module bandsaw_config . The name of the module can be changed in two ways: Set the BANDSAW_CONFIG environment variable to a different module name. Bandsaw reads the name of the module containing the configuration from this variable if it is set. So by setting it to e.g. my_config it will import my_config and take the configuration from it instead. Add an additional keyword argument to the @task decorator that contains the name of the configuration to use for this task: @bandsaw . task ( config = 'my_config_module' ) def my_function ( x ): ... return x By adding the config keyword argument we can choose the configuration we want to use per task. The existence of the configuration is checked as soon as the decorator is being applied. If no configuration could be loaded, an error is raised , usually at module import time.","title":"Configure bandsaw"},{"location":"user_guide/#choose-the-advice-chain","text":"Each task can define, which advice chain should be used. This can be done, by adding a keyword argument chain to the task decorator: @bandsaw . task ( chain = 'my_chain' ) def my_function ( x ): ... return x If no chain exists with the specified name, a KeyError is raised .","title":"Choose the advice chain"},{"location":"user_guide/#extending-bandsaw","text":"Bandsaw is extensible and allows developers to add new functionality in various ways:","title":"Extending bandsaw"},{"location":"user_guide/#implementing-custom-advices","text":"Advices are the main building blocks for adding new functionality. Implementing an advice is easy, the only necessary work is to adhere to a protocol and follow some simple rules. The protocol is defined in Advice and consists of two methods, before(self, session) and after(self, session) . Advices have to call the session. When called via before() and after() , the advice is responsible for telling the session how to continue. They must call once either session.proceed() or session.conclude() . Failure to do so, will lead to a RuntimeError raised by the session. Advices shouldn't keep state themselves. Advice instances are used for multiple tasks. Therefore, their implementation shouldn't store any task specific state themselves. If task specific state is necessary, it can be easily added to the context of the session. Advices may be instantiated multiple times and on different machines. Everytime a task is transferred to a different python interpreter, its configuration and with it the configured advices are instantiated again, even if they aren't actually called. Therefore, advices shouldn't do much work or interact with their environment at instantiation time, but only when they are actually called via after() or before() . Usually they can assume that both methods are called in the same environment for the same task.","title":"Implementing custom advices"},{"location":"advices/async/","text":"Running tasks asynchronously (Planned) \ud83d\udd17 This feature is currently not available but planned for the next future. The main use-case for this are processes that take a long time to compute. In this case, driving the process from the local machine and running the individual tasks synchronously would require the developer machine to stay online the whole time to communicate the results between the individual tasks and start the individual tasks as needed. In the asynchronous case, all tasks are scheduled before and an executor on the individual computation platforms takes care of running them as appropriate. The drawback of this is, that we don't have access to the actual results within the workflow that defines the process, but we only have futures that are passed between the individual tasks. This feature is planned to be available in Q1 of the year 2022.","title":"Async"},{"location":"advices/async/#running-tasks-asynchronously-planned","text":"This feature is currently not available but planned for the next future. The main use-case for this are processes that take a long time to compute. In this case, driving the process from the local machine and running the individual tasks synchronously would require the developer machine to stay online the whole time to communicate the results between the individual tasks and start the individual tasks as needed. In the asynchronous case, all tasks are scheduled before and an executor on the individual computation platforms takes care of running them as appropriate. The drawback of this is, that we don't have access to the actual results within the workflow that defines the process, but we only have futures that are passed between the individual tasks. This feature is planned to be available in Q1 of the year 2022.","title":"Running tasks asynchronously (Planned)"},{"location":"advices/caching/","text":"Caching task results in the file system \ud83d\udd17 The python module bandsaw.advices.cache contains the CachingAdvice class, which allows to store results of already calculated tasks in the file system so that they can be reused in later executions. Configuration \ud83d\udd17 directory (str) \ud83d\udd17 The directory, where the results will be stored. If the directory doesn't exist, it will be created the first time, a result is being stored. Example configuration \ud83d\udd17 import bandsaw.advices.cache configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . cache . CachingAdvice ( directory = '/my/cache/directory' , ) )","title":"Caching"},{"location":"advices/caching/#caching-task-results-in-the-file-system","text":"The python module bandsaw.advices.cache contains the CachingAdvice class, which allows to store results of already calculated tasks in the file system so that they can be reused in later executions.","title":"Caching task results in the file system"},{"location":"advices/caching/#configuration","text":"","title":"Configuration"},{"location":"advices/caching/#directory-str","text":"The directory, where the results will be stored. If the directory doesn't exist, it will be created the first time, a result is being stored.","title":"directory (str)"},{"location":"advices/caching/#example-configuration","text":"import bandsaw.advices.cache configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . cache . CachingAdvice ( directory = '/my/cache/directory' , ) )","title":"Example configuration"},{"location":"advices/profiling/","text":"Profiling of task executions (In development) \ud83d\udd17 In order to get better insight into bottlenecks and consumptions of computing resources we are currently working on an advice, which will automatically gather metrics about things like cpu utilisation, memory consumption and runtime statistics for each task. This should allow identifying optimization potential in workflows and help to reduce the cost and energy consumption of large workflows. This feature is currently in development and will be released in December 2021.","title":"Profiling"},{"location":"advices/profiling/#profiling-of-task-executions-in-development","text":"In order to get better insight into bottlenecks and consumptions of computing resources we are currently working on an advice, which will automatically gather metrics about things like cpu utilisation, memory consumption and runtime statistics for each task. This should allow identifying optimization potential in workflows and help to reduce the cost and energy consumption of large workflows. This feature is currently in development and will be released in December 2021.","title":"Profiling of task executions (In development)"},{"location":"advices/remote/","text":"Running tasks on remote machines using SSH (In development) \ud83d\udd17 The bandsaw.advices.remote.SshAdvice allows to run tasks on a different machine than where the workflow defining the whole process is being run. Internally it uses paramiko to transfer the task over to another machine, spawns a new python interpreter, runs the task and returns the result back to the calling machine. This feature is currently in development and will be released in November 2021.","title":"Remote"},{"location":"advices/remote/#running-tasks-on-remote-machines-using-ssh-in-development","text":"The bandsaw.advices.remote.SshAdvice allows to run tasks on a different machine than where the workflow defining the whole process is being run. Internally it uses paramiko to transfer the task over to another machine, spawns a new python interpreter, runs the task and returns the result back to the calling machine. This feature is currently in development and will be released in November 2021.","title":"Running tasks on remote machines using SSH (In development)"},{"location":"advices/subprocess/","text":"Running tasks in subprocesses \ud83d\udd17 The python module bandsaw.advices.subprocess contains the SubprocessAdvice class, which allows running task computations in a subprocess. Additionally, the subprocess can use a different python interpreter than the one, that is used for running the rest of the recipe. This can be used for bringing together tasks with conflicting dependencies or different python versions. Configuration \ud83d\udd17 directory (str) \ud83d\udd17 The directory, where the intermediate results and temporary data to communicate with the subprocess will be written to. Can be None , in which case a temporary directory will be used. interpreter (bandsaw.interpreter.Interpreter) \ud83d\udd17 The python interpreter to use for executing the task. If None , the same interpreter will be used, that is executing the workflow. Example configuration \ud83d\udd17 import bandsaw.advices.subprocess import bandsaw.interpreter configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . subprocess . SubprocessAdvice ( directory = '/my/subprocess/directory' , interpreter = bandsaw . interpreter . Interpreter ( path = [ '/my/other/interpreter' , '/python/path' ], executable = '/path/to/the/other/python' , ) ) )","title":"Subprocess"},{"location":"advices/subprocess/#running-tasks-in-subprocesses","text":"The python module bandsaw.advices.subprocess contains the SubprocessAdvice class, which allows running task computations in a subprocess. Additionally, the subprocess can use a different python interpreter than the one, that is used for running the rest of the recipe. This can be used for bringing together tasks with conflicting dependencies or different python versions.","title":"Running tasks in subprocesses"},{"location":"advices/subprocess/#configuration","text":"","title":"Configuration"},{"location":"advices/subprocess/#directory-str","text":"The directory, where the intermediate results and temporary data to communicate with the subprocess will be written to. Can be None , in which case a temporary directory will be used.","title":"directory (str)"},{"location":"advices/subprocess/#interpreter-bandsawinterpreterinterpreter","text":"The python interpreter to use for executing the task. If None , the same interpreter will be used, that is executing the workflow.","title":"interpreter (bandsaw.interpreter.Interpreter)"},{"location":"advices/subprocess/#example-configuration","text":"import bandsaw.advices.subprocess import bandsaw.interpreter configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . subprocess . SubprocessAdvice ( directory = '/my/subprocess/directory' , interpreter = bandsaw . interpreter . Interpreter ( path = [ '/my/other/interpreter' , '/python/path' ], executable = '/path/to/the/other/python' , ) ) )","title":"Example configuration"}]}