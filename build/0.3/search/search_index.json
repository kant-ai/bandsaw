{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bandsaw \ud83d\udd17 Bandsaw is a library for defining and structuring Python workflows, that can span across multiple python interpreters and machines. It is currently under development by Kantai GmbH and licensed under MIT License . Interested in first steps using bandsaw? \ud83d\udd17 Take a look at our Getting started documentation . Want to learn more about the details? \ud83d\udd17 Read through our User guide to understand how it works. You have questions? \ud83d\udd17 Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"Home"},{"location":"#bandsaw","text":"Bandsaw is a library for defining and structuring Python workflows, that can span across multiple python interpreters and machines. It is currently under development by Kantai GmbH and licensed under MIT License .","title":"Bandsaw"},{"location":"#interested-in-first-steps-using-bandsaw","text":"Take a look at our Getting started documentation .","title":"Interested in first steps using bandsaw?"},{"location":"#want-to-learn-more-about-the-details","text":"Read through our User guide to understand how it works.","title":"Want to learn more about the details?"},{"location":"#you-have-questions","text":"Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"You have questions?"},{"location":"api/","text":"A library for splitting python workflows into separate tasks advice \ud83d\udd17 Contains classes and functions for advising tasks. Advice \ud83d\udd17 Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, before(session) and after(session) , that are called during the process of advising a task execution. Both take a single argument session which contains an instance of the class Session . This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result. Source code in bandsaw/advice.py class Advice : \"\"\" Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, `before(session)` and `after(session)`, that are called during the process of advising a task execution. Both take a single argument `session` which contains an instance of the class `Session`. This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result. \"\"\" def before ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () def after ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def after ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def before ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () advise_task_with_chain ( task , execution , configuration , advice_chain = 'default' ) \ud83d\udd17 Executes an Task with additional advices. Parameters: Name Type Description Default task bandsaw.tasks.Task The task to be executed. required execution bandsaw.execution.Execution The execution definition for the task. required configuration bandsaw.config.Configuration The configuration which should be used during advising. required advice_chain str The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. 'default' Returns: Type Description bandsaw.result.Result The result of the task execution. Source code in bandsaw/advice.py def advise_task_with_chain ( task , execution , configuration , advice_chain = 'default' ): \"\"\" Executes an `Task` with additional advices. Args: task (bandsaw.tasks.Task): The task to be executed. execution (bandsaw.execution.Execution): The execution definition for the task. configuration (bandsaw.config.Configuration): The configuration which should be used during advising. advice_chain (str): The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. Returns: bandsaw.result.Result: The result of the task execution. \"\"\" session = Session ( task , execution , configuration , advice_chain ) return session . initiate () advices special \ud83d\udd17 Package that contains reusable Advice classes cache \ud83d\udd17 Contains Advice that can cache task results in a local file system. CachingAdvice ( Advice ) \ud83d\udd17 Advice that caches results in a local filesystem. Attributes: Name Type Description directory Path The path to the directory where the results are cached. Source code in bandsaw/advices/cache.py class CachingAdvice ( Advice ): \"\"\" Advice that caches results in a local filesystem. Attributes: directory (Path): The path to the directory where the results are cached. \"\"\" def __init__ ( self , directory ): self . directory = pathlib . Path ( directory ) logger . info ( \"Caching artifacts in storage ' %s '\" , self . directory ) super () . __init__ () def before ( self , session ): artifact_id = session . task . task_id revision_id = session . execution . execution_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed () def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed () after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def before ( self , session ): artifact_id = session . task . task_id revision_id = session . execution . execution_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed () log \ud83d\udd17 Contains an Advice implementation which adds logging JsonFormatter ( Formatter ) \ud83d\udd17 Formatter that formats log records into a JSON string. Source code in bandsaw/advices/log.py class JsonFormatter ( logging . Formatter ): \"\"\" Formatter that formats log records into a JSON string. \"\"\" def format ( self , record ): timestamp = datetime . datetime . fromtimestamp ( record . created , datetime . timezone . utc , ) log_item = { \"timestamp\" : datetime . datetime . isoformat ( timestamp ), \"logger\" : record . name , \"level\" : record . levelname , \"message\" : record . message , \"threadId\" : record . thread , \"threadName\" : record . threadName , \"processId\" : record . process , \"processName\" : record . processName , \"module\" : record . module , \"function\" : record . funcName , \"path\" : record . pathname , \"line_no\" : record . lineno , } if record . exc_info is not None : log_item . update ( { 'traceback' : '' . join ( traceback . format_tb ( record . exc_info [ 2 ]) ) . strip (), 'exception' : traceback . format_exception_only ( * record . exc_info [: 2 ])[ 0 ] . strip (), } ) if hasattr ( record , 'session' ): log_item . update ( { 'sessionId' : record . session . session_id , 'runId' : record . session . run_id , 'taskId' : record . session . task . task_id , 'executionId' : record . session . execution . execution_id , } ) return json . dumps ( log_item ) format ( self , record ) \ud83d\udd17 Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Source code in bandsaw/advices/log.py def format ( self , record ): timestamp = datetime . datetime . fromtimestamp ( record . created , datetime . timezone . utc , ) log_item = { \"timestamp\" : datetime . datetime . isoformat ( timestamp ), \"logger\" : record . name , \"level\" : record . levelname , \"message\" : record . message , \"threadId\" : record . thread , \"threadName\" : record . threadName , \"processId\" : record . process , \"processName\" : record . processName , \"module\" : record . module , \"function\" : record . funcName , \"path\" : record . pathname , \"line_no\" : record . lineno , } if record . exc_info is not None : log_item . update ( { 'traceback' : '' . join ( traceback . format_tb ( record . exc_info [ 2 ]) ) . strip (), 'exception' : traceback . format_exception_only ( * record . exc_info [: 2 ])[ 0 ] . strip (), } ) if hasattr ( record , 'session' ): log_item . update ( { 'sessionId' : record . session . session_id , 'runId' : record . session . run_id , 'taskId' : record . session . task . task_id , 'executionId' : record . session . execution . execution_id , } ) return json . dumps ( log_item ) LoggingAdvice ( Advice ) \ud83d\udd17 An Advice which adds additional logging Source code in bandsaw/advices/log.py class LoggingAdvice ( Advice ): \"\"\"An Advice which adds additional logging\"\"\" def __init__ ( self , level = None , formatter = None ): \"\"\" Create a new instance of the `LoggingAdvice`. Args: level (int): The log level of the messages to keep. If `None` the level is defined by the root logger. Defaults to `None`. formatter (logging.Formatter): Formatter to use for writing out the individual log messages. Defaults to `JsonFormatter`. \"\"\" self . _level = level if formatter is None : formatter = JsonFormatter () self . _formatter = formatter def before ( self , session ): session_log_file_path = session . temp_dir / 'session.log' file_handler = logging . FileHandler ( filename = str ( session_log_file_path . absolute ()), ) file_handler . set_name ( 'Handler-' + session . session_id ) if self . _level is not None : file_handler . setLevel ( self . _level ) file_handler . setFormatter ( self . _formatter ) session_filter = _SessionFilter ( session ) file_handler . addFilter ( session_filter ) logging . root . addHandler ( file_handler ) logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) session . proceed () def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) for handler in logging . root . handlers : if handler . get_name () == 'Handler-' + session . session_id : logging . root . removeHandler ( handler ) handler . flush () session . attachments [ 'session.log' ] = session . temp_dir / 'session.log' session . proceed () __init__ ( self , level = None , formatter = None ) special \ud83d\udd17 Create a new instance of the LoggingAdvice . Parameters: Name Type Description Default level int The log level of the messages to keep. If None the level is defined by the root logger. Defaults to None . None formatter logging.Formatter Formatter to use for writing out the individual log messages. Defaults to JsonFormatter . None Source code in bandsaw/advices/log.py def __init__ ( self , level = None , formatter = None ): \"\"\" Create a new instance of the `LoggingAdvice`. Args: level (int): The log level of the messages to keep. If `None` the level is defined by the root logger. Defaults to `None`. formatter (logging.Formatter): Formatter to use for writing out the individual log messages. Defaults to `JsonFormatter`. \"\"\" self . _level = level if formatter is None : formatter = JsonFormatter () self . _formatter = formatter after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/log.py def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) for handler in logging . root . handlers : if handler . get_name () == 'Handler-' + session . session_id : logging . root . removeHandler ( handler ) handler . flush () session . attachments [ 'session.log' ] = session . temp_dir / 'session.log' session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/log.py def before ( self , session ): session_log_file_path = session . temp_dir / 'session.log' file_handler = logging . FileHandler ( filename = str ( session_log_file_path . absolute ()), ) file_handler . set_name ( 'Handler-' + session . session_id ) if self . _level is not None : file_handler . setLevel ( self . _level ) file_handler . setFormatter ( self . _formatter ) session_filter = _SessionFilter ( session ) file_handler . addFilter ( session_filter ) logging . root . addHandler ( file_handler ) logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) session . proceed () metrics \ud83d\udd17 Contains an Advice implementation which gathers metrics. MetricsAdvice ( Advice ) \ud83d\udd17 An Advice which gathers metrics. Underneath this advice uses the python multimeter library for collecting the metrics. Source code in bandsaw/advices/metrics.py class MetricsAdvice ( Advice ): \"\"\"An Advice which gathers metrics. Underneath this advice uses the python `multimeter` library for collecting the metrics. \"\"\" def __init__ ( self , meter , directory = None , file_format = multimeter . JsonFormat ()): \"\"\" Creates a new MetricsAdvice that gathers metrics. Args: meter (multimeter.Multimeter): The Multimeter instance which is used for gathering the metrics. directory (str): Path to a directory, where the metrics are temporarily stored. If `None` or omitted, the session temporary directory is used. file_format (multimeter.FileFormat): File format that defines the format in which the gathered metrics are stored. Defaults to `multimeter.JsonFormat`. \"\"\" self . _multimeter = meter if directory is not None : self . _directory = pathlib . Path ( directory ) else : self . _directory = None self . _file_format = file_format def before ( self , session ): tags = { 'run_id' : session . run_id , 'task_id' : session . task . task_id , 'execution_id' : session . execution . execution_id , 'session_id' : session . session_id , } advice_parameters = session . task . advice_parameters additional_tags = advice_parameters . get ( 'metrics' , {}) . get ( 'tags' , {}) tags . update ( additional_tags ) logger . info ( \"Measurement id %s with tags %s \" , session . session_id , tags ) measurement = self . _multimeter . measure ( session . session_id , ** tags ) session . context [ 'metrics.measurement' ] = measurement logger . debug ( \"Measurement start\" ) measurement . start () session . proceed () def after ( self , session ): measurement = session . context . pop ( 'metrics.measurement' ) logger . debug ( \"Measurement end\" ) measurement . end () directory = self . _directory or session . temp_dir storage = multimeter . FileStorage ( directory , self . _file_format ) storage . store ( measurement . result ) metrics_file_name = measurement . identifier + self . _file_format . extension metrics_attachment_name = 'metrics' + self . _file_format . extension session . attachments [ metrics_attachment_name ] = directory / metrics_file_name session . proceed () __init__ ( self , meter , directory = None , file_format =< multimeter . storages . file . JsonFormat object at 0x7f8a8f98df10 > ) special \ud83d\udd17 Creates a new MetricsAdvice that gathers metrics. Parameters: Name Type Description Default meter multimeter.Multimeter The Multimeter instance which is used for gathering the metrics. required directory str Path to a directory, where the metrics are temporarily stored. If None or omitted, the session temporary directory is used. None file_format multimeter.FileFormat File format that defines the format in which the gathered metrics are stored. Defaults to multimeter.JsonFormat . <multimeter.storages.file.JsonFormat object at 0x7f8a8f98df10> Source code in bandsaw/advices/metrics.py def __init__ ( self , meter , directory = None , file_format = multimeter . JsonFormat ()): \"\"\" Creates a new MetricsAdvice that gathers metrics. Args: meter (multimeter.Multimeter): The Multimeter instance which is used for gathering the metrics. directory (str): Path to a directory, where the metrics are temporarily stored. If `None` or omitted, the session temporary directory is used. file_format (multimeter.FileFormat): File format that defines the format in which the gathered metrics are stored. Defaults to `multimeter.JsonFormat`. \"\"\" self . _multimeter = meter if directory is not None : self . _directory = pathlib . Path ( directory ) else : self . _directory = None self . _file_format = file_format after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/metrics.py def after ( self , session ): measurement = session . context . pop ( 'metrics.measurement' ) logger . debug ( \"Measurement end\" ) measurement . end () directory = self . _directory or session . temp_dir storage = multimeter . FileStorage ( directory , self . _file_format ) storage . store ( measurement . result ) metrics_file_name = measurement . identifier + self . _file_format . extension metrics_attachment_name = 'metrics' + self . _file_format . extension session . attachments [ metrics_attachment_name ] = directory / metrics_file_name session . proceed () before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/metrics.py def before ( self , session ): tags = { 'run_id' : session . run_id , 'task_id' : session . task . task_id , 'execution_id' : session . execution . execution_id , 'session_id' : session . session_id , } advice_parameters = session . task . advice_parameters additional_tags = advice_parameters . get ( 'metrics' , {}) . get ( 'tags' , {}) tags . update ( additional_tags ) logger . info ( \"Measurement id %s with tags %s \" , session . session_id , tags ) measurement = self . _multimeter . measure ( session . session_id , ** tags ) session . context [ 'metrics.measurement' ] = measurement logger . debug ( \"Measurement start\" ) measurement . start () session . proceed () ssh \ud83d\udd17 Contains code for running tasks remotely via SSH Remote \ud83d\udd17 Definition of a remote machine. Remotes are used for executing sessions on remote machines. Attributes: Name Type Description host str The hostname of the machine, where this interpreter is run. port int The port where ssh is listening for connections. Defaults to 22. user str The name of the user, under which the interpreter will run. Defaults to the name of the local user. key_file str Path to a file containing the key to use for authentication. interpreter bandsaw.interpreter.Interpreter The interpreter which should be used, including its executable and python path. directory str Remote directory where temporary files are stored. If None , defaults to '/tmp'. Source code in bandsaw/advices/ssh.py class Remote : # pylint: disable=too-few-public-methods \"\"\" Definition of a remote machine. Remotes are used for executing sessions on remote machines. Attributes: host (str): The hostname of the machine, where this interpreter is run. port (int): The port where ssh is listening for connections. Defaults to 22. user (str): The name of the user, under which the interpreter will run. Defaults to the name of the local user. key_file (str): Path to a file containing the key to use for authentication. interpreter (bandsaw.interpreter.Interpreter): The interpreter which should be used, including its executable and python path. directory (str): Remote directory where temporary files are stored. If `None`, defaults to '/tmp'. \"\"\" def __init__ ( self , host = None , port = None , user = None , key_file = None , interpreter = None , directory = None , ): # pylint: disable=too-many-arguments if host is None : raise ValueError ( \"Remote needs a host, `None` given.\" ) self . host = host self . port = port or 22 self . user = user or get_current_username () self . key_file = key_file if interpreter is None : raise ValueError ( \"Remote needs an interpreter, `None` given.\" ) self . interpreter = interpreter self . directory = pathlib . Path ( directory or '/tmp' ) SshAdvice ( Advice ) \ud83d\udd17 Advice that moves and proceeds a session on a remote machine via SSH Source code in bandsaw/advices/ssh.py class SshAdvice ( Advice ): \"\"\"Advice that moves and proceeds a session on a remote machine via SSH\"\"\" def __init__ ( self , directory = None , backend = SshCommandLineBackend ()): \"\"\" Create a new instance. Args: directory (str): The local directory where temporary files are stored to exchange data between the local and the remote machine. If `None`, the temporary directory from the session is used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using session temporary directory for exchange data\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s for exchange data\" , self . directory ) self . remotes = {} self . _backend = backend super () . __init__ () def add_remote ( self , remote , name = 'default' ): \"\"\" Add a new definition of a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Definition of the remote machine. name (str): Name of the remote. Defaults to `default`. Returns: bandsaw.advices.ssh.SshAdvice: The advice with the added remote. \"\"\" self . remotes [ name ] = remote return self def before ( self , session ): temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( str ( session_in_path ), mode = 'w' ) as stream : session . save ( stream ) parameters = session . task . advice_parameters remote_name = parameters . get ( 'ssh' , {}) . get ( 'remote' , 'default' ) remote = self . remotes [ remote_name ] remote_run_directory = remote . directory / session . execution . execution_id logger . info ( \"Creating run directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . create_dir ( remote , remote_run_directory , ) logger . info ( \"Copying over distribution archive to host %s \" , remote . host ) distribution_archive_path = session . distribution_archive . path remote_distribution_archive_path = ( remote_run_directory / distribution_archive_path . name ) self . _backend . copy_file_to_remote ( remote , distribution_archive_path , remote_distribution_archive_path , ) logger . info ( \"Copying over session to host %s \" , remote . host ) remote_session_in_path = remote_run_directory / session_in_path . name self . _backend . copy_file_to_remote ( remote , session_in_path , remote_session_in_path , ) remote_session_out_path = remote_run_directory / session_out_path . name logger . info ( \"Running remote process using interpreter %s \" , remote . interpreter . executable ) self . _backend . execute_remote ( remote , remote . interpreter . executable , str ( remote_distribution_archive_path ), '--input' , str ( remote_session_in_path ), '--output' , str ( remote_session_out_path ), '--run-id' , session . run_id , ) # environment = self.interpreter.environment # environment['PYTHONPATH'] = ':'.join(self.interpreter.path) logger . info ( \"Remote process exited\" ) logger . info ( \"Copying over session result from host %s \" , remote . host ) self . _backend . copy_file_from_remote ( remote , remote_session_out_path , session_out_path , ) logger . info ( \"Cleaning up remote directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . delete_dir ( remote , remote_run_directory ) logger . info ( \"Restore local session from %s \" , session_out_path ) stream = io . FileIO ( str ( session_out_path ), mode = 'r' ) session . restore ( stream ) logger . info ( \"Cleaning up local sessions %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"Proceed local session\" ) session . proceed () def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Remote process created result %s \" , session . result ) logger . info ( \"Returning to end remote session and continue in parent\" ) __init__ ( self , directory = None , backend =< bandsaw . advices . ssh . SshCommandLineBackend object at 0x7f8a8f968250 > ) special \ud83d\udd17 Create a new instance. Parameters: Name Type Description Default directory str The local directory where temporary files are stored to exchange data between the local and the remote machine. If None , the temporary directory from the session is used. None Source code in bandsaw/advices/ssh.py def __init__ ( self , directory = None , backend = SshCommandLineBackend ()): \"\"\" Create a new instance. Args: directory (str): The local directory where temporary files are stored to exchange data between the local and the remote machine. If `None`, the temporary directory from the session is used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using session temporary directory for exchange data\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s for exchange data\" , self . directory ) self . remotes = {} self . _backend = backend super () . __init__ () add_remote ( self , remote , name = 'default' ) \ud83d\udd17 Add a new definition of a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Definition of the remote machine. required name str Name of the remote. Defaults to default . 'default' Returns: Type Description bandsaw.advices.ssh.SshAdvice The advice with the added remote. Source code in bandsaw/advices/ssh.py def add_remote ( self , remote , name = 'default' ): \"\"\" Add a new definition of a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Definition of the remote machine. name (str): Name of the remote. Defaults to `default`. Returns: bandsaw.advices.ssh.SshAdvice: The advice with the added remote. \"\"\" self . remotes [ name ] = remote return self after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/ssh.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Remote process created result %s \" , session . result ) logger . info ( \"Returning to end remote session and continue in parent\" ) before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/ssh.py def before ( self , session ): temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( str ( session_in_path ), mode = 'w' ) as stream : session . save ( stream ) parameters = session . task . advice_parameters remote_name = parameters . get ( 'ssh' , {}) . get ( 'remote' , 'default' ) remote = self . remotes [ remote_name ] remote_run_directory = remote . directory / session . execution . execution_id logger . info ( \"Creating run directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . create_dir ( remote , remote_run_directory , ) logger . info ( \"Copying over distribution archive to host %s \" , remote . host ) distribution_archive_path = session . distribution_archive . path remote_distribution_archive_path = ( remote_run_directory / distribution_archive_path . name ) self . _backend . copy_file_to_remote ( remote , distribution_archive_path , remote_distribution_archive_path , ) logger . info ( \"Copying over session to host %s \" , remote . host ) remote_session_in_path = remote_run_directory / session_in_path . name self . _backend . copy_file_to_remote ( remote , session_in_path , remote_session_in_path , ) remote_session_out_path = remote_run_directory / session_out_path . name logger . info ( \"Running remote process using interpreter %s \" , remote . interpreter . executable ) self . _backend . execute_remote ( remote , remote . interpreter . executable , str ( remote_distribution_archive_path ), '--input' , str ( remote_session_in_path ), '--output' , str ( remote_session_out_path ), '--run-id' , session . run_id , ) # environment = self.interpreter.environment # environment['PYTHONPATH'] = ':'.join(self.interpreter.path) logger . info ( \"Remote process exited\" ) logger . info ( \"Copying over session result from host %s \" , remote . host ) self . _backend . copy_file_from_remote ( remote , remote_session_out_path , session_out_path , ) logger . info ( \"Cleaning up remote directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . delete_dir ( remote , remote_run_directory ) logger . info ( \"Restore local session from %s \" , session_out_path ) stream = io . FileIO ( str ( session_out_path ), mode = 'r' ) session . restore ( stream ) logger . info ( \"Cleaning up local sessions %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"Proceed local session\" ) session . proceed () SshBackend ( ABC ) \ud83d\udd17 Interface definition for different SSH backends. Source code in bandsaw/advices/ssh.py class SshBackend ( abc . ABC ): \"\"\" Interface definition for different SSH backends. \"\"\" def create_dir ( self , remote , remote_path ): \"\"\" Create a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be created. remote_path (str): Remote path to the directory that should be created. \"\"\" def copy_file_to_remote ( self , remote , local_path , remote_path ): \"\"\" Copies a local file or directory to a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine to which a file should be copied. local_path (pathlib.Path): Local path to the file which should be copied over. remote_path (pathlib.Path): Remote path of the file where it should be copied to. \"\"\" def copy_file_from_remote ( self , remote , remote_path , local_path ): \"\"\" Copies a remote file or directory to the local file system. Args: remote (bandsaw.advices.ssh.Remote): Remote machine from which a file should be copied. remote_path (pathlib.Path): Remote path of the file which should be copied. local_path (pathlib.Path): Local path to the file where it should be copied to. \"\"\" def execute_remote ( self , remote , executable , * arguments ): \"\"\" Executes an executable on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where `executable` will be executed. executable (str): Remote path of the executable which should be executed. *arguments (str): Positional arguments which are the command line parameter for the `executable`. Raises: subprocess.CalledProcessError: If the remote process ends with an error. Its return code will be available through the exception. \"\"\" def delete_dir ( self , remote , remote_path ): \"\"\" Delete a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be deleted. remote_path (str): Remote path to the directory that should be deleted. \"\"\" copy_file_from_remote ( self , remote , remote_path , local_path ) \ud83d\udd17 Copies a remote file or directory to the local file system. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine from which a file should be copied. required remote_path pathlib.Path Remote path of the file which should be copied. required local_path pathlib.Path Local path to the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_from_remote ( self , remote , remote_path , local_path ): \"\"\" Copies a remote file or directory to the local file system. Args: remote (bandsaw.advices.ssh.Remote): Remote machine from which a file should be copied. remote_path (pathlib.Path): Remote path of the file which should be copied. local_path (pathlib.Path): Local path to the file where it should be copied to. \"\"\" copy_file_to_remote ( self , remote , local_path , remote_path ) \ud83d\udd17 Copies a local file or directory to a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine to which a file should be copied. required local_path pathlib.Path Local path to the file which should be copied over. required remote_path pathlib.Path Remote path of the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_to_remote ( self , remote , local_path , remote_path ): \"\"\" Copies a local file or directory to a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine to which a file should be copied. local_path (pathlib.Path): Local path to the file which should be copied over. remote_path (pathlib.Path): Remote path of the file where it should be copied to. \"\"\" create_dir ( self , remote , remote_path ) \ud83d\udd17 Create a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be created. required remote_path str Remote path to the directory that should be created. required Source code in bandsaw/advices/ssh.py def create_dir ( self , remote , remote_path ): \"\"\" Create a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be created. remote_path (str): Remote path to the directory that should be created. \"\"\" delete_dir ( self , remote , remote_path ) \ud83d\udd17 Delete a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be deleted. required remote_path str Remote path to the directory that should be deleted. required Source code in bandsaw/advices/ssh.py def delete_dir ( self , remote , remote_path ): \"\"\" Delete a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be deleted. remote_path (str): Remote path to the directory that should be deleted. \"\"\" execute_remote ( self , remote , executable , * arguments ) \ud83d\udd17 Executes an executable on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where executable will be executed. required executable str Remote path of the executable which should be executed. required *arguments str Positional arguments which are the command line parameter for the executable . () Exceptions: Type Description subprocess.CalledProcessError If the remote process ends with an error. Its return code will be available through the exception. Source code in bandsaw/advices/ssh.py def execute_remote ( self , remote , executable , * arguments ): \"\"\" Executes an executable on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where `executable` will be executed. executable (str): Remote path of the executable which should be executed. *arguments (str): Positional arguments which are the command line parameter for the `executable`. Raises: subprocess.CalledProcessError: If the remote process ends with an error. Its return code will be available through the exception. \"\"\" SshCommandLineBackend ( SshBackend ) \ud83d\udd17 SSH backend that uses the SSH command line tools. Source code in bandsaw/advices/ssh.py class SshCommandLineBackend ( SshBackend ): \"\"\" SSH backend that uses the SSH command line tools. \"\"\" def create_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'mkdir' , '-p' , str ( remote_path ), ] ) def copy_file_to_remote ( self , remote , local_path , remote_path ): copy_destination = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ str ( local_path ), copy_destination , ], ) def copy_file_from_remote ( self , remote , remote_path , local_path ): copy_source = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ copy_source , str ( local_path ), ], ) def execute_remote ( self , remote , executable , * arguments ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), str ( executable ), ] + list ( arguments ), ) def delete_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'rm' , '-Rf' , str ( remote_path ), ] ) @staticmethod def _run ( command ): logger . debug ( \"running command %s \" , command ) subprocess . check_call ( command ) @staticmethod def login ( remote ): \"\"\"Returns the destination of the remote in form of <user>@<host>\"\"\" return f \" { remote . user } @ { remote . host } \" def get_remote_path ( self , remote , path ): \"\"\"Returns the remote path in form of <user>@<host>:<path>\"\"\" return f \" { self . login ( remote ) } : { path . absolute () } \" @staticmethod def _key_file_option ( remote ): if remote . key_file is not None : return [ '-i' , remote . key_file , ] return [] copy_file_from_remote ( self , remote , remote_path , local_path ) \ud83d\udd17 Copies a remote file or directory to the local file system. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine from which a file should be copied. required remote_path pathlib.Path Remote path of the file which should be copied. required local_path pathlib.Path Local path to the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_from_remote ( self , remote , remote_path , local_path ): copy_source = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ copy_source , str ( local_path ), ], ) copy_file_to_remote ( self , remote , local_path , remote_path ) \ud83d\udd17 Copies a local file or directory to a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine to which a file should be copied. required local_path pathlib.Path Local path to the file which should be copied over. required remote_path pathlib.Path Remote path of the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_to_remote ( self , remote , local_path , remote_path ): copy_destination = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ str ( local_path ), copy_destination , ], ) create_dir ( self , remote , remote_path ) \ud83d\udd17 Create a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be created. required remote_path str Remote path to the directory that should be created. required Source code in bandsaw/advices/ssh.py def create_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'mkdir' , '-p' , str ( remote_path ), ] ) delete_dir ( self , remote , remote_path ) \ud83d\udd17 Delete a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be deleted. required remote_path str Remote path to the directory that should be deleted. required Source code in bandsaw/advices/ssh.py def delete_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'rm' , '-Rf' , str ( remote_path ), ] ) execute_remote ( self , remote , executable , * arguments ) \ud83d\udd17 Executes an executable on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where executable will be executed. required executable str Remote path of the executable which should be executed. required *arguments str Positional arguments which are the command line parameter for the executable . () Exceptions: Type Description subprocess.CalledProcessError If the remote process ends with an error. Its return code will be available through the exception. Source code in bandsaw/advices/ssh.py def execute_remote ( self , remote , executable , * arguments ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), str ( executable ), ] + list ( arguments ), ) get_remote_path ( self , remote , path ) \ud83d\udd17 Returns the remote path in form of @ : Source code in bandsaw/advices/ssh.py def get_remote_path ( self , remote , path ): \"\"\"Returns the remote path in form of <user>@<host>:<path>\"\"\" return f \" { self . login ( remote ) } : { path . absolute () } \" login ( remote ) staticmethod \ud83d\udd17 Returns the destination of the remote in form of @ Source code in bandsaw/advices/ssh.py @staticmethod def login ( remote ): \"\"\"Returns the destination of the remote in form of <user>@<host>\"\"\" return f \" { remote . user } @ { remote . host } \" subprocess \ud83d\udd17 Contains Advice implementation that runs the execution in a subprocess SubprocessAdvice ( Advice ) \ud83d\udd17 Advice that runs in a subprocess Source code in bandsaw/advices/subprocess.py class SubprocessAdvice ( Advice ): \"\"\"Advice that runs in a subprocess\"\"\" def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using temporary session directory\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ () def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' archive_path = session . distribution_archive . path logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_path , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Continue session in subprocess using interpreter %s and \" \"distribution archive %s \" , self . interpreter . executable , archive_path , ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , archive_path , '--input' , session_in_path , '--output' , session_out_path , '--run-id' , session . run_id , ], env = environment , ) logger . info ( \"Sub process exited\" ) logger . info ( \"Reading session from %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Cleaning up session files %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"proceed() session in parent process\" ) session . proceed () def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) logger . info ( \"Returning to end session and continue in parent\" ) __init__ ( self , directory = None , interpreter = None ) special \ud83d\udd17 Create a new instance. Parameters: Name Type Description Default directory str The directory where temporary files are stored to exchange data between both processes. If None a temporary directory is used. None interpreter bandsaw.interpreter.Interpreter The interpreter to use in the subprocess. If None the same interpreter will be used. None Source code in bandsaw/advices/subprocess.py def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using temporary session directory\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ () after ( self , session ) \ud83d\udd17 Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) logger . info ( \"Returning to end session and continue in parent\" ) before ( self , session ) \ud83d\udd17 Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' archive_path = session . distribution_archive . path logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_path , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Continue session in subprocess using interpreter %s and \" \"distribution archive %s \" , self . interpreter . executable , archive_path , ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , archive_path , '--input' , session_in_path , '--output' , session_out_path , '--run-id' , session . run_id , ], env = environment , ) logger . info ( \"Sub process exited\" ) logger . info ( \"Reading session from %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Cleaning up session files %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"proceed() session in parent process\" ) session . proceed () config \ud83d\udd17 Contains the class and functions to configure bandsaw. Configuration \ud83d\udd17 Class that represents a configuration for bandsaw. Attributes: Name Type Description temporary_directory pathlib.Path The path to a directory where temporary files are stored. Source code in bandsaw/config.py class Configuration : \"\"\" Class that represents a configuration for bandsaw. Attributes: temporary_directory (pathlib.Path): The path to a directory where temporary files are stored. \"\"\" def __init__ ( self ): self . _advice_chains = {} self . extensions = [] self . serializer = PickleSerializer () self . add_advice_chain () stack = traceback . extract_stack ( limit = 2 ) config_module_file_path = stack [ 0 ] . filename self . module_name = get_loaded_module_name_by_path ( config_module_file_path ) logger . info ( \"Config created in module: %s \" , self . module_name ) self . distribution_modules = [] self . temporary_directory = None self . set_temp_directory ( tempfile . mkdtemp ( prefix = 'bandsaw' )) def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name ) def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self def add_modules_for_distribution ( self , * modules ): \"\"\" Add modules that should be included in the distribution archive. Args: *modules (List[str]): Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. Returns: bandsaw.config.Configuration: The configuration with the added modules. \"\"\" self . distribution_modules . extend ( modules ) return self def set_temp_directory ( self , directory ): \"\"\" Sets the temporary directory. Args: directory (Union[str, pathlib.Path]): Path to the directory, where temporary files will be stored. \"\"\" self . temporary_directory = pathlib . Path ( directory ) atexit . register ( lambda path : shutil . rmtree ( path , ignore_errors = True ), str ( self . temporary_directory ), ) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . module_name == other . module_name def __hash__ ( self ): return hash ( self . module_name ) add_advice_chain ( self , * advices , * , name = 'default' ) \ud83d\udd17 Add a new advice chain to the configuration. Each advice chain has a unique name . If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Parameters: Name Type Description Default *advices bandsaw.advice.Advice A tuple of advices for this chain. () name str The name of the advice chain, defaults to 'default' if not specified. 'default' Returns: Type Description bandsaw.config.Configuration The configuration to which the chain was added. Source code in bandsaw/config.py def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self add_extension ( self , extension ) \ud83d\udd17 Add an Extension to the configuration. Extensions are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Parameters: Name Type Description Default extension bandsaw.extension.Extension An object implementing the Extension . required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self add_modules_for_distribution ( self , * modules ) \ud83d\udd17 Add modules that should be included in the distribution archive. Parameters: Name Type Description Default *modules List[str] Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. () Returns: Type Description bandsaw.config.Configuration The configuration with the added modules. Source code in bandsaw/config.py def add_modules_for_distribution ( self , * modules ): \"\"\" Add modules that should be included in the distribution archive. Args: *modules (List[str]): Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. Returns: bandsaw.config.Configuration: The configuration with the added modules. \"\"\" self . distribution_modules . extend ( modules ) return self get_advice_chain ( self , name ) \ud83d\udd17 Returns the advice chain with the given name. Parameters: Name Type Description Default name str Name of the wanted advice chain. required Returns: Type Description List[bandsaw.advice.Advice] The advice chain with the given name. Exceptions: Type Description KeyError If no chain with the specified name is configured. Source code in bandsaw/config.py def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name ) set_serializer ( self , serializer ) \ud83d\udd17 Sets the serialize which defines how tasks and results will be serialized. Parameters: Name Type Description Default serializer bandsaw.serialization.Serializer The serializer to use for serializing objects. required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self set_temp_directory ( self , directory ) \ud83d\udd17 Sets the temporary directory. Parameters: Name Type Description Default directory Union[str, pathlib.Path] Path to the directory, where temporary files will be stored. required Source code in bandsaw/config.py def set_temp_directory ( self , directory ): \"\"\" Sets the temporary directory. Args: directory (Union[str, pathlib.Path]): Path to the directory, where temporary files will be stored. \"\"\" self . temporary_directory = pathlib . Path ( directory ) atexit . register ( lambda path : shutil . rmtree ( path , ignore_errors = True ), str ( self . temporary_directory ), ) get_configuration ( configuration_module = None ) \ud83d\udd17 Return a configuration. Parameters: Name Type Description Default configuration_module str The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of Configuration . If no module name is given, a default configuration is returned based on the value of the BANDSAW_CONFIG_MODULE environment variable. If this variable is not set, we default to 'bandsaw_config'. None Returns: Type Description bandsaw.config.Configuration The configuration. Exceptions: Type Description ModuleNotFoundError If no module exists with name configuration_module . LookupError If the module doesn't contain a variable 'configuration`. TypeError If the variable configuration is not of type Configuration . Source code in bandsaw/config.py def get_configuration ( configuration_module = None ): \"\"\" Return a configuration. Args: configuration_module (str): The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of `Configuration`. If no module name is given, a default configuration is returned based on the value of the `BANDSAW_CONFIG_MODULE` environment variable. If this variable is not set, we default to 'bandsaw_config'. Returns: bandsaw.config.Configuration: The configuration. Raises: ModuleNotFoundError: If no module exists with name `configuration_module`. LookupError: If the module doesn't contain a variable 'configuration`. TypeError: If the variable `configuration` is not of type `Configuration`. \"\"\" if configuration_module is None : default_configuration_module_name = os . getenv ( CONFIGURATION_MODULE_ENV_VARIABLE , CONFIGURATION_MODULE_DEFAULT , ) configuration_module = default_configuration_module_name if configuration_module not in _configurations : try : _load_configuration_module ( configuration_module ) except ModuleNotFoundError : logger . warning ( \"No module found for config %s \" , configuration_module , ) raise return _configurations [ configuration_module ] context \ud83d\udd17 Classes that represent the context used in advising tasks. Context ( SerializableValue ) \ud83d\udd17 Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the Advice classes to store state or communicate with other advices. Source code in bandsaw/context.py class Context ( SerializableValue ): \"\"\" Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the `Advice` classes to store state or communicate with other advices. \"\"\" def __init__ ( self , attributes = None ): self . _attributes = attributes or {} def serialized ( self ): data = { 'attributes' : self . _attributes , } return data @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ]) @property def attributes ( self ): \"\"\" A set of arbitrary key-value mappings for the `Advice` classes. `Advice` can add to this mapping and use this as a way of keeping state. \"\"\" return self . _attributes def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . _attributes == other . _attributes attributes property readonly \ud83d\udd17 A set of arbitrary key-value mappings for the Advice classes. Advice can add to this mapping and use this as a way of keeping state. deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/context.py @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ]) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/context.py def serialized ( self ): data = { 'attributes' : self . _attributes , } return data decorator \ud83d\udd17 Contains decorators that allow to define individual tasks task ( * task_args , * , config = None , chain = None , ** task_kwargs ) \ud83d\udd17 Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Examples: >>> @task ... def my_task_function (): ... pass or with additional configuration. Examples: >>> @task ( config = 'my.config' ) ... def my_task_function (): ... pass Parameters: Name Type Description Default config str The name of the configuration module to use for this task. If not given, the default configuration is used. None chain str The name of the advice chain to use for advising this task. If not given, 'default' is used. None *task_args Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, task_args contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, task_args contains the positional arguments of the call of the decorator. () **task_kwargs Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, task_kwargs is an empty dictionary. If there is additional configuration given, task_kwargs contains the keyword arguments of the call of the decorator. {} Returns: Type Description Callable Returns a callable that wraps the decorated function. Exceptions: Type Description ModuleNotFoundError If the configured configuration module does not exist. ValueError If the specified advice chain does not exist. RuntimeError If the task is configured with multiple positional arguments. Source code in bandsaw/decorator.py def task ( * task_args , config = None , chain = None , ** task_kwargs ): \"\"\" Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Example: >>> @task ... def my_task_function(): ... pass or with additional configuration. Example: >>> @task(config='my.config') ... def my_task_function(): ... pass Args: config (str): The name of the configuration module to use for this task. If not given, the default configuration is used. chain (str): The name of the advice chain to use for advising this task. If not given, 'default' is used. *task_args: Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, `task_args` contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, `task_args` contains the positional arguments of the call of the decorator. **task_kwargs: Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, `task_kwargs` is an empty dictionary. If there is additional configuration given, `task_kwargs`contains the keyword arguments of the call of the decorator. Returns: Callable: Returns a callable that wraps the decorated function. Raises: ModuleNotFoundError: If the configured configuration module does not exist. ValueError: If the specified advice chain does not exist. RuntimeError: If the task is configured with multiple positional arguments. \"\"\" config_module = config configuration = get_configuration ( config_module ) chain_name = chain or 'default' advice_chain = configuration . get_advice_chain ( chain_name ) if advice_chain is None : raise ValueError ( f \"Unknown advice chain { chain_name } \" ) def decorate_function ( func ): logger . info ( \"Decorate function ' %s '\" , func ) logger . info ( \"Creating task for function ' %s '\" , func ) the_task = Task . create_task ( func , task_kwargs ) def inner ( * func_args , ** func_kwargs ): execution_id = _calculate_execution_id ( func_args , func_kwargs , configuration . serializer , ) execution = Execution ( execution_id , func_args , func_kwargs ) result = advise_task_with_chain ( the_task , execution , configuration , chain_name , ) if result . exception : raise result . exception return result . value inner . __wrapped__ = func inner . bandsaw_task = the_task inner . bandsaw_configuration = configuration return inner if len ( task_args ) == 1 and len ( task_kwargs ) == 0 : return decorate_function ( task_args [ 0 ]) if len ( task_args ) == 0 and ( len ( task_kwargs ) > 0 or chain is not None or config is not None ): return decorate_function # This shouldn't happen if the decorator is properly used. raise RuntimeError ( \"Invalid 'task' decorator.\" ) distribution \ud83d\udd17 Contains functions for creating distribution archives. Distribution archives are the way how bandsaw transfers code between different machines. They are normal zip files, that contain bandsaw itself, a main module which allows to execute the archive and to continue sessions and possibly some additional dependencies. DistributionArchive \ud83d\udd17 Class that represents a distribution archive. A distribution archive contains all the code necessary for running a task. It can be used for running a task on a different machine by copying over the archive. Attributes: Name Type Description path pathlib.Path The path to the file containing the code. modules tuple[str] The names of the modules that are included in this archive. Source code in bandsaw/distribution.py class DistributionArchive : \"\"\" Class that represents a distribution archive. A distribution archive contains all the code necessary for running a task. It can be used for running a task on a different machine by copying over the archive. Attributes: path (pathlib.Path): The path to the file containing the code. modules (tuple[str]): The names of the modules that are included in this archive. \"\"\" def __init__ ( self , path , * modules ): self . _path = path self . modules = modules @property def path ( self ): \"\"\" Returns: pathlib.Path: The path to the archive file. The file itself is created lazily, when the path is accessed the first time. This makes sure, we only create the archive if necessary. \"\"\" if not self . _path . exists (): _create_distribution_archive ( self . _path , self . modules ) return self . _path def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . modules == other . modules def __hash__ ( self ): return hash ( self . modules ) path property readonly \ud83d\udd17 Returns: Type Description pathlib.Path The path to the archive file. The file itself is created lazily, when the path is accessed the first time. This makes sure, we only create the archive if necessary. get_distribution_archive ( configuration ) \ud83d\udd17 Returns a distribution archive for a given configuration. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration for which the distribution package should be returned. required Returns: Type Description bandsaw.distribution.DistributionArchive The archive for the configuration. Source code in bandsaw/distribution.py def get_distribution_archive ( configuration ): \"\"\" Returns a distribution archive for a given configuration. Args: configuration (bandsaw.config.Configuration): The configuration for which the distribution package should be returned. Returns: bandsaw.distribution.DistributionArchive: The archive for the configuration. \"\"\" archive = _CACHE . get_archive ( configuration ) if archive is None : archive_path = pathlib . Path ( tempfile . mktemp ( suffix = '.pyz' , prefix = 'distribution-' ) ) modules = [ '__main__' , 'bandsaw' , configuration . module_name , * configuration . distribution_modules , ] archive = DistributionArchive ( archive_path , * modules ) _CACHE . put_archive ( configuration , archive ) return archive execution \ud83d\udd17 Contains classes and functions around an execution of a task Execution ( SerializableValue ) \ud83d\udd17 Class that defines an execution of a Task . It contains the arguments that should be used for the task and an unique identifier derived from those arguments. Attributes: Name Type Description execution_id str A string identifying this execution. args tuple[Any] The positional arguments for the task to use in this execution. kwargs Dict[Any,Any] The keyword arguments for the task to use in this execution. Source code in bandsaw/execution.py class Execution ( SerializableValue ): \"\"\" Class that defines an execution of a `Task`. It contains the arguments that should be used for the task and an unique identifier derived from those arguments. Attributes: execution_id (str): A string identifying this execution. args (tuple[Any]): The positional arguments for the task to use in this execution. kwargs (Dict[Any,Any]): The keyword arguments for the task to use in this execution. \"\"\" def __init__ ( self , execution_id , args = None , kwargs = None ): self . execution_id = execution_id self . args = args or () self . kwargs = kwargs or {} def serialized ( self ): return { 'execution_id' : self . execution_id , 'args' : self . args , 'kwargs' : self . kwargs , } @classmethod def deserialize ( cls , values ): return Execution ( values [ 'execution_id' ], values [ 'args' ], values [ 'kwargs' ], ) deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/execution.py @classmethod def deserialize ( cls , values ): return Execution ( values [ 'execution_id' ], values [ 'args' ], values [ 'kwargs' ], ) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/execution.py def serialized ( self ): return { 'execution_id' : self . execution_id , 'args' : self . args , 'kwargs' : self . kwargs , } extensions \ud83d\udd17 Contains an API for extensions that can be used in bandsaw Extension \ud83d\udd17 Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than Advice , an Extension is globally defined in a config and therefore applies to all tasks. Source code in bandsaw/extensions.py class Extension : \"\"\" Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than `Advice`, an `Extension` is globally defined in a config and therefore applies to all tasks. \"\"\" def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\" def on_session_created ( self , session ): \"\"\" Called before bandsaw advises a task. This is called before any advice is applied. Args: session (bandsaw.session.Session): The new session. \"\"\" def on_session_finished ( self , session ): \"\"\" Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Args: session (bandsaw.session.Session): The session. \"\"\" on_init ( self , configuration ) \ud83d\udd17 Called when a bandsaw configuration has been initialized. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration object which contains the config that has been loaded. required Source code in bandsaw/extensions.py def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\" on_session_created ( self , session ) \ud83d\udd17 Called before bandsaw advises a task. This is called before any advice is applied. Parameters: Name Type Description Default session bandsaw.session.Session The new session. required Source code in bandsaw/extensions.py def on_session_created ( self , session ): \"\"\" Called before bandsaw advises a task. This is called before any advice is applied. Args: session (bandsaw.session.Session): The new session. \"\"\" on_session_finished ( self , session ) \ud83d\udd17 Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Parameters: Name Type Description Default session bandsaw.session.Session The session. required Source code in bandsaw/extensions.py def on_session_finished ( self , session ): \"\"\" Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Args: session (bandsaw.session.Session): The session. \"\"\" identifier \ud83d\udd17 Functions for generating identifier for arbitrary python objects. identifier_from_bytes ( buffer ) \ud83d\udd17 Derive an identifier from a bytebuffer. Parameters: Name Type Description Default buffer Union[bytes,bytearray] The binary data from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_bytes ( buffer ): \"\"\" Derive an identifier from a bytebuffer. Args: buffer (Union[bytes,bytearray]): The binary data from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = hashlib . sha256 ( buffer ) . hexdigest ()[: _ID_LENGTH ] return identifier identifier_from_string ( string ) \ud83d\udd17 Derive an identifier from a string. Parameters: Name Type Description Default string str The string from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_string ( string ): \"\"\" Derive an identifier from a string. Args: string (str): The string from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = identifier_from_bytes ( string . encode ( 'utf-8' )) return identifier infos \ud83d\udd17 Infos about values, arguments and tasks value_info ( value ) \ud83d\udd17 Information about a value. The information contains a string representation and a type name, but additional infos can be included as well. Parameters: Name Type Description Default value Any The value for which the infos should be returned. required Returns: Type Description Dict[str,str] A dictionary containing the infos about the value. Source code in bandsaw/infos.py def value_info ( value ): \"\"\" Information about a value. The information contains a string representation and a type name, but additional infos can be included as well. Args: value (Any): The value for which the infos should be returned. Returns: Dict[str,str]: A dictionary containing the infos about the value. \"\"\" value_type = type ( value ) if isinstance ( value , set ): value = sorted ( value ) string_value = str ( value ) if len ( string_value ) > 100 : string_value = string_value [: 85 ] + '...' + string_value [ - 12 :] info = { 'type' : value_type . __qualname__ , 'value' : string_value , } if hasattr ( value , '__len__' ): info [ 'size' ] = str ( len ( value )) if hasattr ( value , 'info' ): info . update ( value . info ()) return info interpreter \ud83d\udd17 Contains classes regarding python interpreters Interpreter ( SerializableValue ) \ud83d\udd17 Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined. Source code in bandsaw/interpreter.py class Interpreter ( SerializableValue ): \"\"\" Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined. \"\"\" def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" if path is None : self . _path = tuple ( sys . path ) else : self . _path = tuple ( path ) self . executable = executable or sys . executable self . _environment = {} def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self @property def environment ( self ): \"\"\"The environment variables to be set for the interpreter.\"\"\" return dict ( self . _environment ) @property def path ( self ): \"\"\"The python path items that will be used.\"\"\" return tuple ( self . _path ) def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , } @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ]) environment property readonly \ud83d\udd17 The environment variables to be set for the interpreter. path property readonly \ud83d\udd17 The python path items that will be used. __init__ ( self , path = None , executable = None ) special \ud83d\udd17 Create a new interpreter instance. Parameters: Name Type Description Default path List[str] A list of directory paths, to be used as $PYTHONPATH. If None the current sys.path is used. None executable str The path to the python executable for this interpreter. If None the current sys.executable is used. None Source code in bandsaw/interpreter.py def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" if path is None : self . _path = tuple ( sys . path ) else : self . _path = tuple ( path ) self . executable = executable or sys . executable self . _environment = {} deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/interpreter.py @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ]) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/interpreter.py def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , } set_environment ( self , ** environment ) \ud83d\udd17 Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Parameters: Name Type Description Default **environment Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. {} Source code in bandsaw/interpreter.py def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self io \ud83d\udd17 Contains classes related to input/output of data. BytearrayGeneratorToStream ( RawIOBase ) \ud83d\udd17 Stream that reads from a generator that yields bytes/bytearrays. Source code in bandsaw/io.py class BytearrayGeneratorToStream ( io . RawIOBase ): \"\"\" Stream that reads from a generator that yields bytes/bytearrays. \"\"\" def __init__ ( self , generator ): self . _generator = generator self . _source = None self . _source_position = 0 super () . __init__ () def readinto ( self , buffer ): buffer_size = len ( buffer ) position = 0 generator_empty = False while True : if self . _source is None : self . _source = next ( self . _generator , None ) self . _source_position = 0 if self . _source is None : logger . debug ( \"no new bytearray from generator, ending stream\" ) generator_empty = True else : logger . debug ( \"got new bytearray from generator of size %d \" , len ( self . _source ), ) if self . _source is not None : source_bytes_left = len ( self . _source ) - self . _source_position buffer_free = buffer_size - position bytes_to_copy = min ( buffer_free , source_bytes_left ) logger . debug ( \"copy %d bytes from current value to stream via buffer of size %d \" , bytes_to_copy , buffer_size , ) buffer_end = position + bytes_to_copy source_end = self . _source_position + bytes_to_copy buffer [ position : buffer_end ] = self . _source [ self . _source_position : source_end ] position += bytes_to_copy if bytes_to_copy < source_bytes_left : self . _source_position += bytes_to_copy else : self . _source = None buffer_full = position == buffer_size if buffer_full or generator_empty : break return position read_stream_to_generator ( stream , buffer_size = 8192 ) \ud83d\udd17 Read from a stream into a generator yielding bytes . Parameters: Name Type Description Default stream io.Stream The stream to read bytes from. required buffer_size int The buffer size to read. Each individual bytes buffer returned by the generator has a maximum size of buffer_size . Defaults to 8192 if not set. 8192 Yields: Type Description bytes A byte buffer of maximum size of buffer_size . Source code in bandsaw/io.py def read_stream_to_generator ( stream , buffer_size = 8192 ): \"\"\" Read from a stream into a generator yielding `bytes`. Args: stream (io.Stream): The stream to read bytes from. buffer_size (int): The buffer size to read. Each individual `bytes` buffer returned by the generator has a maximum size of `buffer_size`. Defaults to `8192` if not set. Yields: bytes: A byte buffer of maximum size of `buffer_size`. \"\"\" buffer = bytearray ( buffer_size ) while True : read = stream . readinto ( buffer ) if read : yield buffer [: read ] else : break modules \ud83d\udd17 Utility functions for handling python modules. get_loaded_module_name_by_path ( file_path ) \ud83d\udd17 Determine the name of an already loaded module by its file path. Parameters: Name Type Description Default file_path str File path of the python file containing the module. required Returns: Type Description str The name of the module, or None if the file isn't loaded as a module. Source code in bandsaw/modules.py def get_loaded_module_name_by_path ( file_path ): \"\"\" Determine the name of an already loaded module by its file path. Args: file_path (str): File path of the python file containing the module. Returns: str: The name of the module, or `None` if the file isn't loaded as a module. \"\"\" real_path = os . path . realpath ( file_path ) for name , module in sys . modules . items (): if hasattr ( module , '__file__' ): module_path = os . path . realpath ( module . __file__ ) if module_path == real_path : return name return None import_object ( object_name , module_name ) \ud83d\udd17 Import a python object from a module. Parameters: Name Type Description Default object_name str The name under which the object is defined in the module. required module_name str The name of the module from which the object should be imported. required Returns: Type Description object The python object defined under the name. Exceptions: Type Description AttributeError If nothing is defined with name object_name in the referenced module. ModuleNotFoundError If no module exists with the name module_name . Source code in bandsaw/modules.py def import_object ( object_name , module_name ): \"\"\" Import a python object from a module. Args: object_name (str): The name under which the object is defined in the module. module_name (str): The name of the module from which the object should be imported. Returns: object: The python object defined under the name. Raises: AttributeError: If nothing is defined with name `object_name` in the referenced module. ModuleNotFoundError: If no module exists with the name `module_name`. \"\"\" module = importlib . import_module ( module_name ) return getattr ( module , object_name ) object_as_import ( obj ) \ud83d\udd17 Returns the name and module of an object, which can be used for importing it. Parameters: Name Type Description Default obj object An arbitrary Python object. required Returns: Type Description Tuple(str, str) Returns a tuple of the object name and the module name in which the object is defined. Exceptions: Type Description ValueError If obj doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note If obj is defined within the __main__ script, the function tries to determine a name for the __main__ module, under which it could be imported from other scripts. Source code in bandsaw/modules.py def object_as_import ( obj ): \"\"\" Returns the name and module of an object, which can be used for importing it. Args: obj (object): An arbitrary Python object. Returns: Tuple(str, str): Returns a tuple of the object name and the module name in which the object is defined. Raises: ValueError: If `obj` doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note: If `obj` is defined within the `__main__` script, the function tries to determine a name for the `__main__` module, under which it could be imported from other scripts. \"\"\" object_name = obj . __name__ module_name = obj . __module__ if module_name == '__main__' : module_file_path = sys . modules [ '__main__' ] . __file__ module_name = _guess_module_name_by_path ( module_file_path , sys . path ) if '<locals>' in obj . __qualname__ : raise ValueError ( \"Can't import local functions.\" ) return object_name , module_name result \ud83d\udd17 Contains code for representing the result of tasks. Result ( SerializableValue ) \ud83d\udd17 Class to encapsulate the result of a task execution. Attributes: Name Type Description value Any The value that is returned by the task. None is the task raised an exception during execution. exception Exception The exception that was raised during execution, None if no exception was raised. Source code in bandsaw/result.py class Result ( SerializableValue ): \"\"\" Class to encapsulate the result of a task execution. Attributes: value (Any): The value that is returned by the task. `None` is the task raised an exception during execution. exception (Exception): The exception that was raised during execution, `None` if no exception was raised. \"\"\" def __init__ ( self , value = None , exception = None ): self . value = value self . exception = exception def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception ) def __eq__ ( self , other ): value_equals = self . value == other . value exception_type_equals = isinstance ( other . exception , type ( self . exception )) exception_args_equals = getattr ( self . exception , \"args\" , None ) == getattr ( other . exception , \"args\" , None ) return value_equals and exception_type_equals and exception_args_equals def __hash__ ( self ): return hash (( self . value , repr ( self . exception ))) deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/result.py @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception ) serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/result.py def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values run \ud83d\udd17 Functions for managing the run id. get_run_id () \ud83d\udd17 Returns the run id. The run id is a unique identifier that is specific to an individual run of a workflow. It stays the same across all task executions and can be used for tracking metrics and differentiating between different runs of the same workflow where task_id and run_id stay the same. Returns: Type Description str The unique run id. Source code in bandsaw/run.py def get_run_id (): \"\"\" Returns the run id. The run id is a unique identifier that is specific to an individual run of a workflow. It stays the same across all task executions and can be used for tracking metrics and differentiating between different runs of the same workflow where task_id and run_id stay the same. Returns: str: The unique run id. \"\"\" if _RUN_ID is None : set_run_id ( str ( uuid . uuid1 ())) return _RUN_ID set_run_id ( run_id ) \ud83d\udd17 Sets the run id. Setting the run id explicitly is usually not necessary. The function is mainly used when task executions are run in a different process to make sure the run id is consistent with the spawning process, but it can be used e.g. if an external system provides a unique identifier for a specific workflow run. When set_run_id(run_id) is being used, it must be run before the first tasks are actually defined. Exceptions: Type Description RuntimeError If the run id was already set before. Source code in bandsaw/run.py def set_run_id ( run_id ): \"\"\" Sets the run id. Setting the run id explicitly is usually not necessary. The function is mainly used when task executions are run in a different process to make sure the run id is consistent with the spawning process, but it can be used e.g. if an external system provides a unique identifier for a specific workflow run. When `set_run_id(run_id)` is being used, it must be run before the first tasks are actually defined. Raises: RuntimeError: If the run id was already set before. \"\"\" global _RUN_ID # pylint: disable=global-statement if _RUN_ID is not None : logger . error ( \"run_id already set to %s when trying to set again\" , _RUN_ID ) raise RuntimeError ( \"Run ID was already set\" ) logger . info ( \"Set run_id to %s \" , run_id ) _RUN_ID = run_id runner \ud83d\udd17 Contains main() function to continue sessions from files main ( args ) \ud83d\udd17 Main function that can be used for proceeding a session. This function allows to read a session from a file, proceed it until it returns and then save the state of the session to a new file. It is used for running tasks in a separate process or on different machines. Parameters: Name Type Description Default args tuple[str] The arguments taken from the command line. required Source code in bandsaw/runner.py def main ( args ): \"\"\" Main function that can be used for proceeding a session. This function allows to read a session from a file, proceed it until it returns and then save the state of the session to a new file. It is used for running tasks in a separate process or on different machines. Args: args (tuple[str]): The arguments taken from the command line. \"\"\" hostname = os . uname ()[ 1 ] log_format = ( f \" {{ asctime }} { hostname } {{ process: >5d }} {{ thread: >5d }} \" f \" {{ name }} {{ levelname }} : {{ message }} \" ) logging . basicConfig ( level = logging . INFO , format = log_format , style = '{' ) parser = argparse . ArgumentParser () parser . add_argument ( '--input' , dest = 'input_session' , help = \"The session which should be continued\" , required = True , ) parser . add_argument ( '--output' , dest = 'output_session' , help = \"The session after continuation ended\" , required = True , ) parser . add_argument ( '--run-id' , dest = 'run_id' , help = \"The run id of the workflow\" , required = True , ) args = parser . parse_args ( args = args ) set_run_id ( args . run_id ) logger . info ( \"Creating new session\" ) session = Session () logger . info ( \"Reading session from %s \" , args . output_session ) with io . FileIO ( args . input_session , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Proceeding session\" ) session . proceed () logger . info ( \"Writing session with result to %s \" , args . output_session ) with io . FileIO ( args . output_session , mode = 'w' ) as stream : session . save ( stream ) serialization special \ud83d\udd17 Module for the package bandsaw.serialization. Contains all public types. json \ud83d\udd17 Contains a Serializer that allows to serialize objects to JSON. JsonSerializer ( Serializer ) \ud83d\udd17 A Serializer which serializes objects to JSON. Attributes: Name Type Description value_serializers List[ValueSerializer] A list of serializers that are used for serialization of custom types. Source code in bandsaw/serialization/json.py class JsonSerializer ( Serializer ): \"\"\" A `Serializer` which serializes objects to JSON. Attributes: value_serializers (List[ValueSerializer]): A list of serializers that are used for serialization of custom types. \"\"\" def __init__ ( self ): super () . __init__ () self . value_serializers = [] self . value_serializers . append ( ExceptionSerializer ()) self . value_serializers . append ( SerializableValueSerializer ()) self . value_serializers . append ( TupleSerializer ()) def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach () def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/json.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/json.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach () pickle \ud83d\udd17 Contains a Serializer which uses pickle for serializing values. PickleSerializer ( Serializer ) \ud83d\udd17 A Serializer which serializes objects using pickle. Source code in bandsaw/serialization/pickle.py class PickleSerializer ( Serializer ): \"\"\"A `Serializer` which serializes objects using pickle.\"\"\" def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream ) def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream ) deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/pickle.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream ) serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/pickle.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream ) serializer \ud83d\udd17 Base classes for serializers which allow to serialize python values. Serializer ( ABC ) \ud83d\udd17 Interface for Serializer which serialize objects Source code in bandsaw/serialization/serializer.py class Serializer ( abc . ABC ): \"\"\"Interface for `Serializer` which serialize objects\"\"\" @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" deserialize ( self , stream ) \ud83d\udd17 Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" serialize ( self , value , stream ) \ud83d\udd17 Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" values \ud83d\udd17 A collection of classes for serializing custom objects. ExceptionSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing exceptions. The serializer saves only the type and the args attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded. Source code in bandsaw/serialization/values.py class ExceptionSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing exceptions. The serializer saves only the type and the `args` attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , Exception ) def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ]) can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , Exception ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state SerializableValue ( ABC ) \ud83d\udd17 Interface for types that can serialize themselves. Source code in bandsaw/serialization/values.py class SerializableValue ( abc . ABC ): \"\"\"Interface for types that can serialize themselves.\"\"\" @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\" @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\" deserialize ( values ) classmethod \ud83d\udd17 Returns a new instance of a value from its serialized representation. Source code in bandsaw/serialization/values.py @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\" serialized ( self ) \ud83d\udd17 Returns a serializable representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\" SerializableValueSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing subclasses of SerializableValue . The serializer uses the methods defined in SerializableValue and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information. Source code in bandsaw/serialization/values.py class SerializableValueSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing subclasses of `SerializableValue`. The serializer uses the methods defined in `SerializableValue` and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue ) def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ]) can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state TupleSerializer ( ValueSerializer ) \ud83d\udd17 A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly. Source code in bandsaw/serialization/values.py class TupleSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , tuple ) def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ]) can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , tuple ) deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ]) serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state ValueSerializer ( ABC ) \ud83d\udd17 Interface for serializers that can serialize custom values. Source code in bandsaw/serialization/values.py class ValueSerializer ( abc . ABC ): \"\"\" Interface for serializers that can serialize custom values. \"\"\" @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\" @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\" @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\" can_serialize_value ( self , value ) \ud83d\udd17 Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\" deserialize_value ( self , representation ) \ud83d\udd17 Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\" serialize_value ( self , value ) \ud83d\udd17 Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\" session \ud83d\udd17 Contains classes for representing an advising session Attachment ( ABC ) \ud83d\udd17 Class that represents a single file that as been attached to a session. Source code in bandsaw/session.py class Attachment ( abc . ABC ): \"\"\" Class that represents a single file that as been attached to a session. \"\"\" @abc . abstractmethod def open ( self ): \"\"\" Opens the attachment for reading. Returns: io.RawIOBase: binary stream for reading. \"\"\" @property @abc . abstractmethod def size ( self ): \"\"\"Return the size of the attachment in bytes\"\"\" size property readonly \ud83d\udd17 Return the size of the attachment in bytes open ( self ) \ud83d\udd17 Opens the attachment for reading. Returns: Type Description io.RawIOBase binary stream for reading. Source code in bandsaw/session.py @abc . abstractmethod def open ( self ): \"\"\" Opens the attachment for reading. Returns: io.RawIOBase: binary stream for reading. \"\"\" Attachments ( Mapping ) \ud83d\udd17 A mapping that contains attachments. Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Attachments itself is a mapping class and can be used similar to a dictionary. When a new attachments is added, it must be path to an existing file, either as str or pathlib.Path . When an attachment is accessed, an object of type Attachment is returned, that gives access to the size of the attachment and allows to read its content. Examples: >>> attachments = Attachments () >>> attachments [ 'my.attachment' ] = '/path/to/file' >>> attachment = attachments [ 'my.attachment' ] >>> attachment . size 1234 >>> attachment . open () . readall () b 'My binary file content.' Source code in bandsaw/session.py class Attachments ( collections . abc . Mapping ): \"\"\" A mapping that contains attachments. Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Attachments itself is a mapping class and can be used similar to a dictionary. When a new attachments is added, it must be path to an existing file, either as `str` or `pathlib.Path`. When an attachment is accessed, an object of type `Attachment` is returned, that gives access to the size of the attachment and allows to read its content. Examples: >>> attachments = Attachments() >>> attachments['my.attachment'] = '/path/to/file' >>> attachment = attachments['my.attachment'] >>> attachment.size 1234 >>> attachment.open().readall() b'My binary file content.' \"\"\" def __init__ ( self , zip_file = None ): \"\"\" Creates a new container for attachments. Args: zip_file (zipfile.ZipFile): An already existing zip file, which can be used for initializing with pre-existing attachments. \"\"\" self . _items = {} if zip_file is not None : self . _add_attachments_from_zip ( zip_file ) def _add_attachments_from_zip ( self , zip_file ): for file_path in zip_file . namelist (): if file_path [: 12 ] == 'attachments/' : attachment_name = file_path . split ( '/' , 1 )[ 1 ] self . _items [ attachment_name ] = _ZipAttachment ( zip_file , file_path ) def store ( self , zip_file ): \"\"\" Stores all attachments in a zip file. Args: zip_file (zipfile.ZipFile): The zip file where the attachments should be stored in. \"\"\" for name , attachment in self . _items . items (): with attachment . open () as stream : zip_file . writestr ( 'attachments/' + name , stream . read ()) def __setitem__ ( self , key , path ): if key in self . _items : raise KeyError ( f \"Attachment ' { key } ' does already exist\" ) if isinstance ( path , str ): path = pathlib . Path ( path ) if not isinstance ( path , pathlib . Path ): raise TypeError ( \"Invalid type for value, must be str or Path\" ) if not path . exists (): raise ValueError ( \"File does not exist\" ) if not path . is_file (): raise ValueError ( \"Path is not a file\" ) self . _items [ key ] = _FileAttachment ( path ) def __getitem__ ( self , key ): return self . _items [ key ] def __iter__ ( self ): return iter ( self . _items ) def __len__ ( self ): return len ( self . _items ) __init__ ( self , zip_file = None ) special \ud83d\udd17 Creates a new container for attachments. Parameters: Name Type Description Default zip_file zipfile.ZipFile An already existing zip file, which can be used for initializing with pre-existing attachments. None Source code in bandsaw/session.py def __init__ ( self , zip_file = None ): \"\"\" Creates a new container for attachments. Args: zip_file (zipfile.ZipFile): An already existing zip file, which can be used for initializing with pre-existing attachments. \"\"\" self . _items = {} if zip_file is not None : self . _add_attachments_from_zip ( zip_file ) store ( self , zip_file ) \ud83d\udd17 Stores all attachments in a zip file. Parameters: Name Type Description Default zip_file zipfile.ZipFile The zip file where the attachments should be stored in. required Source code in bandsaw/session.py def store ( self , zip_file ): \"\"\" Stores all attachments in a zip file. Args: zip_file (zipfile.ZipFile): The zip file where the attachments should be stored in. \"\"\" for name , attachment in self . _items . items (): with attachment . open () as stream : zip_file . writestr ( 'attachments/' + name , stream . read ()) Ids \ud83d\udd17 Class that encapsulates the ids of a session. Attributes: Name Type Description task_id str The id of the task in this session. execution_id str The id of the execution of the task in this session. run_id str The id of the current run. session_id str The id of the session. The id is a combination of the three other ids. Source code in bandsaw/session.py class Ids : \"\"\" Class that encapsulates the ids of a session. Attributes: task_id (str): The id of the task in this session. execution_id (str): The id of the execution of the task in this session. run_id (str): The id of the current run. session_id (str): The id of the session. The id is a combination of the three other ids. \"\"\" slots = ( 'task_id' , 'execution_id' , 'run_id' , '_session_id' ) def __init__ ( self , task_id , execution_id , run_id ): self . task_id = task_id self . execution_id = execution_id self . run_id = run_id self . session_id = \"_\" . join ( [ self . task_id , self . execution_id , self . run_id ], ) def __str__ ( self ): return self . session_id def as_path ( self ): \"\"\" Returns a relative path derived from the ids. Returns: pathlib.Path: relative path that uses the individual ids as components. \"\"\" return pathlib . Path ( self . task_id ) / self . execution_id / self . run_id @classmethod def from_string ( cls , id_as_string ): \"\"\"Create new Ids object from its string representation.\"\"\" return Ids ( * ( id_as_string . split ( '_' ))) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . session_id == other . session_id def __hash__ ( self ): return hash ( self . session_id ) as_path ( self ) \ud83d\udd17 Returns a relative path derived from the ids. Returns: Type Description pathlib.Path relative path that uses the individual ids as components. Source code in bandsaw/session.py def as_path ( self ): \"\"\" Returns a relative path derived from the ids. Returns: pathlib.Path: relative path that uses the individual ids as components. \"\"\" return pathlib . Path ( self . task_id ) / self . execution_id / self . run_id from_string ( id_as_string ) classmethod \ud83d\udd17 Create new Ids object from its string representation. Source code in bandsaw/session.py @classmethod def from_string ( cls , id_as_string ): \"\"\"Create new Ids object from its string representation.\"\"\" return Ids ( * ( id_as_string . split ( '_' ))) Session \ud83d\udd17 Class that handles the advising of an execution. A Session object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like def proceed(self) to continue or conclude() to end with a result, the advices can influence the final result. Additionally, the session provides access to the context , which allows advices to keep state, the execution that is advised, the configuration that is used for advising and the result of the execution. Attributes: Name Type Description task bandsaw.tasks.Task The task that is executed. execution bandsaw.execution.Execution The execution arguments for the task. context bandsaw.context.Context The context that can be used for advices to store state. result bandsaw.result.Result Result of the task if already computed. Otherwise, None . attachments bandsaw.session.Attachments A mapping of files that have been attached to the session. configuration bandsaw.config.Configuration The configuration that is being used for advising this task. Source code in bandsaw/session.py class Session : \"\"\" Class that handles the advising of an execution. A `Session` object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like `def proceed(self)` to continue or `conclude()` to end with a result, the advices can influence the final result. Additionally, the session provides access to the `context`, which allows advices to keep state, the `execution` that is advised, the `configuration` that is used for advising and the `result` of the execution. Attributes: task (bandsaw.tasks.Task): The task that is executed. execution (bandsaw.execution.Execution): The execution arguments for the task. context (bandsaw.context.Context): The context that can be used for advices to store state. result (bandsaw.result.Result): Result of the task if already computed. Otherwise, `None`. attachments (bandsaw.session.Attachments): A mapping of files that have been attached to the session. configuration (bandsaw.config.Configuration): The configuration that is being used for advising this task. \"\"\" # pylint: disable=too-many-instance-attributes # is reasonable in this case. def __init__ ( self , task = None , execution = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . execution = execution self . context = {} self . result = None self . attachments = Attachments () self . configuration = configuration self . _advice_chain = advice_chain self . _moderator = None self . _ids = None self . _temp_dir = None def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . configuration . extensions : extension . on_session_created ( self ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . configuration . extensions : extension . on_session_finished ( self ) return self . result @property def ids ( self ): \"\"\"The ids of this session.\"\"\" if self . _ids is None : if self . task is None or self . execution is None : raise ValueError ( \"Incomplete session, missing task or execution.\" ) self . _ids = Ids ( self . task . task_id , self . execution . execution_id , self . run_id , ) return self . _ids @property def session_id ( self ): \"\"\"The id of this session as string.\"\"\" return str ( self . ids ) @property def serializer ( self ): \"\"\"The serializer that can be used for serializing values.\"\"\" return self . configuration . serializer @property def distribution_archive ( self ): \"\"\"The DistributionArchive which can be used when transferring the session.\"\"\" return get_distribution_archive ( self . configuration ) @property def run_id ( self ): \"\"\"The run id of the workflow.\"\"\" return get_run_id () @property def temp_dir ( self ): \"\"\" Temporary directory where session specific files can be written to. This directory is meant for storing temporary files, that are used by the individual `Advice` instances. The directory is already created and will be automatically deleted with the end of the python interpreter, nonetheless, the advices writing files to the directory should if possible take care of removing them if no longer needed. Returns: pathlib.Path: Path to the temporary directory. \"\"\" if self . _temp_dir is None : self . _temp_dir = self . configuration . temporary_directory / self . ids . as_path () self . _temp_dir . mkdir ( parents = True , exist_ok = True ) return self . _temp_dir def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self ) def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self ) def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream ) def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self def _load_from_zip ( self , stream ): # We don't use with here, because we don't want to close the zip file # This allows the attachment's container, to access the attachments from the # archive archive = zipfile . ZipFile ( stream , 'r' ) # pylint: disable=consider-using-with session_json = json . loads ( archive . read ( 'session.json' )) self . configuration = get_configuration ( session_json [ 'configuration' ]) self . _advice_chain = session_json [ 'advice_chain' ] self . _ids = Ids . from_string ( session_json [ 'ids' ]) serializer = self . configuration . serializer stream = io . BytesIO ( archive . read ( 'task.dat' )) self . task = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'execution.dat' )) self . execution = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'context.dat' )) self . context = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'result.dat' )) self . result = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'moderator.dat' )) self . _moderator = serializer . deserialize ( stream ) if self . _moderator is not None : self . _moderator . advice_chain = self . configuration . get_advice_chain ( self . _advice_chain ) self . attachments = Attachments ( archive ) def _store_as_zip ( self , stream ): serializer = self . configuration . serializer with zipfile . ZipFile ( stream , 'w' ) as archive : session_json = json . dumps ( { 'configuration' : self . configuration . module_name , 'advice_chain' : self . _advice_chain , 'ids' : str ( self . ids ), } ) archive . writestr ( 'session.json' , session_json ) stream = io . BytesIO () serializer . serialize ( self . task , stream ) archive . writestr ( 'task.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . execution , stream ) archive . writestr ( 'execution.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . context , stream ) archive . writestr ( 'context.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . result , stream ) archive . writestr ( 'result.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . _moderator , stream ) archive . writestr ( 'moderator.dat' , stream . getvalue ()) self . attachments . store ( archive ) distribution_archive property readonly \ud83d\udd17 The DistributionArchive which can be used when transferring the session. ids property readonly \ud83d\udd17 The ids of this session. run_id property readonly \ud83d\udd17 The run id of the workflow. serializer property readonly \ud83d\udd17 The serializer that can be used for serializing values. session_id property readonly \ud83d\udd17 The id of this session as string. temp_dir property readonly \ud83d\udd17 Temporary directory where session specific files can be written to. This directory is meant for storing temporary files, that are used by the individual Advice instances. The directory is already created and will be automatically deleted with the end of the python interpreter, nonetheless, the advices writing files to the directory should if possible take care of removing them if no longer needed. Returns: Type Description pathlib.Path Path to the temporary directory. __init__ ( self , task = None , execution = None , configuration = None , advice_chain = 'default' ) special \ud83d\udd17 Create a new session. Source code in bandsaw/session.py def __init__ ( self , task = None , execution = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . execution = execution self . context = {} self . result = None self . attachments = Attachments () self . configuration = configuration self . _advice_chain = advice_chain self . _moderator = None self . _ids = None self . _temp_dir = None conclude ( self , result ) \ud83d\udd17 Conclude the process of advising with a Result . This can be used in two cases: Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given result will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there after(session) method. Concluding AFTER the task was actually executed. This will just change the result of the session and continue will all following advices. Parameters: Name Type Description Default result bandsaw.result.Result The result to conclude with. required Source code in bandsaw/session.py def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self ) initiate ( self ) \ud83d\udd17 Start the process of advising an execution. Returns: Type Description bandsaw.result.Result The final result of the execution after all advices. Source code in bandsaw/session.py def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . configuration . extensions : extension . on_session_created ( self ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . configuration . extensions : extension . on_session_finished ( self ) return self . result proceed ( self ) \ud83d\udd17 Continue the process of advising with the next advice. Source code in bandsaw/session.py def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self ) restore ( self , stream ) \ud83d\udd17 Resume a prior suspended session. Source code in bandsaw/session.py def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self save ( self , stream ) \ud83d\udd17 Suspend the session to be resumed later or elsewhere. Source code in bandsaw/session.py def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream ) tasks \ud83d\udd17 Contains classes and functions representing different types of tasks Task ( SerializableValue , ABC ) \ud83d\udd17 Base-class for different types of Tasks that can be executed Attributes: Name Type Description task_id str A unique identifier for the individual tasks. advice_parameters dict A dictionary with additional arguments provided at task definition. source str The python source code as string which defines the task. bytecode bytes The compiled byte code of the task definition. Source code in bandsaw/tasks.py class Task ( SerializableValue , abc . ABC ): \"\"\"Base-class for different types of `Tasks` that can be executed Attributes: task_id (str): A unique identifier for the individual tasks. advice_parameters (dict): A dictionary with additional arguments provided at task definition. source (str): The python source code as string which defines the task. bytecode (bytes): The compiled byte code of the task definition. \"\"\" # For different types of callable # https://stackoverflow.com/questions/19314405/how-to-detect-is-decorator-has-been-applied-to-method-or-function def __init__ ( self , task_id , advice_parameters ): self . task_id = task_id self . _advice_parameters = advice_parameters @property def advice_parameters ( self ): \"\"\"Additional parameters for advices defined at task definition.\"\"\" return dict ( self . _advice_parameters ) @property @abc . abstractmethod def source ( self ): \"\"\"The python source code as `str` which defines the task.\"\"\" @property @abc . abstractmethod def bytecode ( self ): \"\"\"The compiled byte code of the task definition as `bytes`.\"\"\" @property @abc . abstractmethod def signature ( self ): \"\"\"The signature() of the callable representing this task.\"\"\" @abc . abstractmethod def _execute ( self , args , kwargs ): \"\"\" Execute the task with the given arguments. Args: args: The positional arguments to use during execution. kwargs: The keyword arguments to use during execution. Returns: Any: The returned value from the task. Raises: Any: During the execution the task can raise arbitrary exceptions. \"\"\" def execute ( self , execution ): \"\"\" Execute the task with the arguments specified by the execution. Args: execution (bandsaw.execution.Execution): The definition which contains how the task should be executed. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( execution . args , execution . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result @classmethod def create_task ( cls , obj , advice_parameters = None ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. advice_parameters (dict): A dictionary containing additional arguments to be used by the advices. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if advice_parameters is None : advice_parameters = {} if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj , advice_parameters ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name , advice_parameters ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" ) advice_parameters property readonly \ud83d\udd17 Additional parameters for advices defined at task definition. bytecode property readonly \ud83d\udd17 The compiled byte code of the task definition as bytes . signature property readonly \ud83d\udd17 The signature() of the callable representing this task. source property readonly \ud83d\udd17 The python source code as str which defines the task. create_task ( obj , advice_parameters = None ) classmethod \ud83d\udd17 Factory for creating a task for different Python objects. Parameters: Name Type Description Default obj Any Python object that should be run as a task. required advice_parameters dict A dictionary containing additional arguments to be used by the advices. None Returns: Type Description bandsaw.tasks.Task Instance of Task class that allows to execute the task. Exceptions: Type Description TypeError If there is no support for this type of python object. Source code in bandsaw/tasks.py @classmethod def create_task ( cls , obj , advice_parameters = None ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. advice_parameters (dict): A dictionary containing additional arguments to be used by the advices. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if advice_parameters is None : advice_parameters = {} if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj , advice_parameters ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name , advice_parameters ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" ) execute ( self , execution ) \ud83d\udd17 Execute the task with the arguments specified by the execution. Parameters: Name Type Description Default execution bandsaw.execution.Execution The definition which contains how the task should be executed. required Returns: Type Description bandsaw.result.Result A Result object with either the returned value from the task or an exception that was raised by the task. Source code in bandsaw/tasks.py def execute ( self , execution ): \"\"\" Execute the task with the arguments specified by the execution. Args: execution (bandsaw.execution.Execution): The definition which contains how the task should be executed. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( execution . args , execution . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result tracking special \ud83d\udd17 backend \ud83d\udd17 Interface for tracking backends Backend \ud83d\udd17 Base class for backend implementations Source code in bandsaw/tracking/backend.py class Backend : \"\"\"Base class for backend implementations\"\"\" def track_run ( self , ids , run_info ): \"\"\" Track a run Args: ids (bandsaw.session.Ids): Ids where the run was first used. run_info (Dict[str,Any]): A dictionary containing tracking information for this run. \"\"\" def track_distribution_archive ( self , distribution_archive ): \"\"\" Track a distribution archive. Args: distribution_archive (bandsaw.distribution.DistributionArchive): The archive which should be tracked. \"\"\" def track_task ( self , ids , task_info ): \"\"\" Track a task. Args: ids (bandsaw.session.Ids): Ids where task was first used. task_info (Dict[str,Any]): A dictionary containing tracking information for a task. \"\"\" def track_execution ( self , ids , execution_info ): \"\"\" Track an execution. Args: ids (bandsaw.session.Ids): Ids where task was first used. execution_info (Dict[str,Any]): A dictionary containing tracking information for the execution. \"\"\" def track_session ( self , ids , session_info ): \"\"\" Track a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. session_info (Dict[str,Any]): A dictionary containing tracking information for this session. \"\"\" def track_result ( self , ids , result_info ): \"\"\" Track the result of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. result_info (Dict[str,Any]): A dictionary containing tracking information for this result. \"\"\" def track_attachments ( self , ids , attachments ): \"\"\" Track the attachments of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. attachments (bandsaw.session.Attachments): An instance of `Attachments` which gives access to the files that were attached to a session. \"\"\" track_attachments ( self , ids , attachments ) \ud83d\udd17 Track the attachments of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required attachments bandsaw.session.Attachments An instance of Attachments which gives access to the files that were attached to a session. required Source code in bandsaw/tracking/backend.py def track_attachments ( self , ids , attachments ): \"\"\" Track the attachments of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. attachments (bandsaw.session.Attachments): An instance of `Attachments` which gives access to the files that were attached to a session. \"\"\" track_distribution_archive ( self , distribution_archive ) \ud83d\udd17 Track a distribution archive. Parameters: Name Type Description Default distribution_archive bandsaw.distribution.DistributionArchive The archive which should be tracked. required Source code in bandsaw/tracking/backend.py def track_distribution_archive ( self , distribution_archive ): \"\"\" Track a distribution archive. Args: distribution_archive (bandsaw.distribution.DistributionArchive): The archive which should be tracked. \"\"\" track_execution ( self , ids , execution_info ) \ud83d\udd17 Track an execution. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required execution_info Dict[str,Any] A dictionary containing tracking information for the execution. required Source code in bandsaw/tracking/backend.py def track_execution ( self , ids , execution_info ): \"\"\" Track an execution. Args: ids (bandsaw.session.Ids): Ids where task was first used. execution_info (Dict[str,Any]): A dictionary containing tracking information for the execution. \"\"\" track_result ( self , ids , result_info ) \ud83d\udd17 Track the result of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required result_info Dict[str,Any] A dictionary containing tracking information for this result. required Source code in bandsaw/tracking/backend.py def track_result ( self , ids , result_info ): \"\"\" Track the result of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. result_info (Dict[str,Any]): A dictionary containing tracking information for this result. \"\"\" track_run ( self , ids , run_info ) \ud83d\udd17 Track a run Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where the run was first used. required run_info Dict[str,Any] A dictionary containing tracking information for this run. required Source code in bandsaw/tracking/backend.py def track_run ( self , ids , run_info ): \"\"\" Track a run Args: ids (bandsaw.session.Ids): Ids where the run was first used. run_info (Dict[str,Any]): A dictionary containing tracking information for this run. \"\"\" track_session ( self , ids , session_info ) \ud83d\udd17 Track a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required session_info Dict[str,Any] A dictionary containing tracking information for this session. required Source code in bandsaw/tracking/backend.py def track_session ( self , ids , session_info ): \"\"\" Track a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. session_info (Dict[str,Any]): A dictionary containing tracking information for this session. \"\"\" track_task ( self , ids , task_info ) \ud83d\udd17 Track a task. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required task_info Dict[str,Any] A dictionary containing tracking information for a task. required Source code in bandsaw/tracking/backend.py def track_task ( self , ids , task_info ): \"\"\" Track a task. Args: ids (bandsaw.session.Ids): Ids where task was first used. task_info (Dict[str,Any]): A dictionary containing tracking information for a task. \"\"\" filesystem \ud83d\udd17 Tracking backend using filesystem FileSystemBackend ( Backend ) \ud83d\udd17 Tracking backend that stores data in the local file system. Source code in bandsaw/tracking/filesystem.py class FileSystemBackend ( Backend ): \"\"\"Tracking backend that stores data in the local file system.\"\"\" def __init__ ( self , directory ): \"\"\" Create a new backend. Args: directory (str): Directory where the tracking data will be stored. \"\"\" self . directory = pathlib . Path ( directory ) logger . info ( \"Tracking sessions in directory ' %s '\" , self . directory ) super () . __init__ () def track_run ( self , ids , run_info ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True ) run_info_path = run_dir / 'run-info.json' with run_info_path . open ( 'w' ) as stream : json . dump ( run_info , stream ) def track_task ( self , ids , task_info ): task_dir = self . directory / 'tasks' / ids . task_id task_dir . mkdir ( parents = True , exist_ok = True ) task_info_path = task_dir / 'task-info.json' with task_info_path . open ( 'w' ) as stream : json . dump ( task_info , stream ) def track_execution ( self , ids , execution_info ): execution_dir = self . directory / 'tasks' / ids . task_id / ids . execution_id execution_dir . mkdir ( parents = True , exist_ok = True ) execution_info_path = execution_dir / 'execution-info.json' with execution_info_path . open ( 'w' ) as stream : json . dump ( execution_info , stream ) def track_session ( self , ids , session_info ): self . _store_session_info ( ids , session_info ) self . _store_session_for_run ( ids ) def track_result ( self , ids , result_info ): self . _store_session_result ( ids , result_info ) def track_attachments ( self , ids , attachments ): self . _store_session_attachments ( ids , attachments ) def _store_session_for_run ( self , ids ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True , exist_ok = True ) run_session_file = run_dir / str ( ids ) run_session_file . touch () def _store_session_info ( self , ids , session_info ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) session_dir . mkdir ( parents = True , exist_ok = True ) session_info_file = session_dir / 'session-info.json' with session_info_file . open ( 'w' ) as stream : json . dump ( session_info , stream ) def _store_session_result ( self , ids , result_info ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) session_dir . mkdir ( parents = True , exist_ok = True ) session_info_file = session_dir / 'result-info.json' with session_info_file . open ( 'w' ) as stream : json . dump ( result_info , stream ) def _store_session_attachments ( self , ids , attachments ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) attachments_dir = session_dir / 'attachments' attachments_dir . mkdir ( parents = True ) for name , attachment in attachments . items (): attachment_path = attachments_dir / name with attachment . open () as input_stream : with attachment_path . open ( 'wb' ) as output_stream : shutil . copyfileobj ( input_stream , output_stream ) __init__ ( self , directory ) special \ud83d\udd17 Create a new backend. Parameters: Name Type Description Default directory str Directory where the tracking data will be stored. required Source code in bandsaw/tracking/filesystem.py def __init__ ( self , directory ): \"\"\" Create a new backend. Args: directory (str): Directory where the tracking data will be stored. \"\"\" self . directory = pathlib . Path ( directory ) logger . info ( \"Tracking sessions in directory ' %s '\" , self . directory ) super () . __init__ () track_attachments ( self , ids , attachments ) \ud83d\udd17 Track the attachments of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required attachments bandsaw.session.Attachments An instance of Attachments which gives access to the files that were attached to a session. required Source code in bandsaw/tracking/filesystem.py def track_attachments ( self , ids , attachments ): self . _store_session_attachments ( ids , attachments ) track_execution ( self , ids , execution_info ) \ud83d\udd17 Track an execution. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required execution_info Dict[str,Any] A dictionary containing tracking information for the execution. required Source code in bandsaw/tracking/filesystem.py def track_execution ( self , ids , execution_info ): execution_dir = self . directory / 'tasks' / ids . task_id / ids . execution_id execution_dir . mkdir ( parents = True , exist_ok = True ) execution_info_path = execution_dir / 'execution-info.json' with execution_info_path . open ( 'w' ) as stream : json . dump ( execution_info , stream ) track_result ( self , ids , result_info ) \ud83d\udd17 Track the result of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required result_info Dict[str,Any] A dictionary containing tracking information for this result. required Source code in bandsaw/tracking/filesystem.py def track_result ( self , ids , result_info ): self . _store_session_result ( ids , result_info ) track_run ( self , ids , run_info ) \ud83d\udd17 Track a run Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where the run was first used. required run_info Dict[str,Any] A dictionary containing tracking information for this run. required Source code in bandsaw/tracking/filesystem.py def track_run ( self , ids , run_info ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True ) run_info_path = run_dir / 'run-info.json' with run_info_path . open ( 'w' ) as stream : json . dump ( run_info , stream ) track_session ( self , ids , session_info ) \ud83d\udd17 Track a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required session_info Dict[str,Any] A dictionary containing tracking information for this session. required Source code in bandsaw/tracking/filesystem.py def track_session ( self , ids , session_info ): self . _store_session_info ( ids , session_info ) self . _store_session_for_run ( ids ) track_task ( self , ids , task_info ) \ud83d\udd17 Track a task. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required task_info Dict[str,Any] A dictionary containing tracking information for a task. required Source code in bandsaw/tracking/filesystem.py def track_task ( self , ids , task_info ): task_dir = self . directory / 'tasks' / ids . task_id task_dir . mkdir ( parents = True , exist_ok = True ) task_info_path = task_dir / 'task-info.json' with task_info_path . open ( 'w' ) as stream : json . dump ( task_info , stream ) tracker \ud83d\udd17 Contains Advice that tracks task executions in a local file system. TrackerExtension ( Extension ) \ud83d\udd17 Advice that tracks task executions and their data in the file system. Attributes: Name Type Description _backend bandsaw.tracking.backend.Backend The backend implementation to use. Source code in bandsaw/tracking/tracker.py class TrackerExtension ( Extension ): \"\"\" Advice that tracks task executions and their data in the file system. Attributes: _backend (bandsaw.tracking.backend.Backend): The backend implementation to use. \"\"\" def __init__ ( self , backend ): \"\"\" Advice that tracks task executions and their data in the file system. Args: backend (bandsaw.tracking.backend.Backend): The backend implementation to use. Raises: TypeError: If `backend` does not inherit from `Backend` base class. ValueError: If no backend is given. \"\"\" if backend is None : raise ValueError ( \"Backend must be set.\" ) if not isinstance ( backend , Backend ): raise TypeError ( \"`backend` is not of type `Backend`.\" ) self . _backend = backend logger . info ( \"Tracking sessions using backend ' %s '\" , self . _backend ) self . _tracked_runs = set () self . _tracked_tasks = set () self . _tracked_executions = set () self . _tracked_sessions = set () self . _tracked_results = set () self . _tracked_attachments = set () super () . __init__ () def on_session_created ( self , session ): self . _track_run ( session ) self . _track_task ( session ) self . _track_execution ( session ) self . _track_session ( session ) def on_session_finished ( self , session ): self . _track_result ( session ) self . _track_attachments ( session ) def _track_run ( self , session ): if session . run_id not in self . _tracked_runs : self . _backend . track_run ( session . ids , { 'id' : session . run_id }) self . _tracked_runs . add ( session . run_id ) def _track_task ( self , session ): if session . task . task_id not in self . _tracked_tasks : self . _backend . track_task ( session . ids , self . _create_task_info ( session )) self . _tracked_tasks . add ( session . task . task_id ) def _track_execution ( self , session ): combined_id = session . task . task_id + '_' + session . execution . execution_id if combined_id not in self . _tracked_executions : self . _backend . track_execution ( session . ids , self . _create_execution_info ( session ) ) self . _tracked_executions . add ( combined_id ) def _track_session ( self , session ): if session . session_id not in self . _tracked_sessions : self . _backend . track_session ( session . ids , self . _create_session_info ( session )) self . _tracked_sessions . add ( session . session_id ) def _track_result ( self , session ): if session . session_id not in self . _tracked_results : self . _backend . track_result ( session . ids , self . _create_result_info ( session )) self . _tracked_results . add ( session . session_id ) def _track_attachments ( self , session ): if session . session_id not in self . _tracked_attachments : self . _backend . track_attachments ( session . ids , session . attachments ) self . _tracked_attachments . add ( session . session_id ) @staticmethod def _create_run_info ( session ): run_info = { 'run' : { 'id' : session . run_id , }, 'configuration' : session . configuration . module_name , 'distribution_archive' : { 'modules' : session . distribution_archive . modules , 'id' : None , # session.distribution_archive.archive_id, }, } return run_info @staticmethod def _create_task_info ( session ): task_info = { 'task' : { 'id' : session . task . task_id , 'definition' : str ( session . task ), 'advice_parameters' : session . task . advice_parameters , }, } return task_info def _create_execution_info ( self , session ): def _argument_infos ( task , execution ): \"\"\" The names of the positional and keyword arguments for this task. Returns: tuple[List[str],Set[str]]: Tuple containing a list with the names of the positional arguments and a set with the names of the keyword arguments. \"\"\" signature = task . signature bound_args = signature . bind ( * execution . args , ** execution . kwargs ) bound_args . apply_defaults () all_infos = [] for name , value in bound_args . arguments . items (): info = value_info ( value ) info [ 'name' ] = name all_infos . append ( info ) return all_infos execution_info = self . _create_task_info ( session ) execution_info [ 'execution' ] = { 'id' : session . execution . execution_id , 'arguments' : _argument_infos ( session . task , session . execution ), } return execution_info def _create_session_info ( self , session ): tracking_info = self . _create_execution_info ( session ) tracking_info . update ( self . _create_run_info ( session )) tracking_info . update ( { 'session' : { 'id' : str ( session . session_id ), }, 'task' : { 'id' : session . task . task_id , 'definition' : str ( session . task ), 'advice_parameters' : session . task . advice_parameters , }, } ) return tracking_info def _create_result_info ( self , session ): def _result_value_infos ( result_value ): \"\"\" The names of the positional and keyword arguments for this task. Returns: tuple[List[str],Set[str]]: Tuple containing a list with the names of the positional arguments and a set with the names of the keyword arguments. \"\"\" result_value_infos = [] if isinstance ( result_value , dict ): for name , value in result_value . items (): info = value_info ( value ) info [ 'key' ] = name result_value_infos . append ( info ) elif isinstance ( result_value , list ): for index , value in enumerate ( result_value ): info = value_info ( value ) info [ 'index' ] = index result_value_infos . append ( info ) else : info = value_info ( result_value ) result_value_infos = info return result_value_infos result = session . result result_info = self . _create_session_info ( session ) result_info [ 'result' ] = {} if result . exception : result_info [ 'result' ][ 'exception' ] = type ( result . exception ) . __name__ result_info [ 'result' ][ 'message' ] = str ( result . exception ) else : result_info [ 'result' ][ 'value' ] = _result_value_infos ( result . value ) return result_info __init__ ( self , backend ) special \ud83d\udd17 Advice that tracks task executions and their data in the file system. Parameters: Name Type Description Default backend bandsaw.tracking.backend.Backend The backend implementation to use. required Exceptions: Type Description TypeError If backend does not inherit from Backend base class. ValueError If no backend is given. Source code in bandsaw/tracking/tracker.py def __init__ ( self , backend ): \"\"\" Advice that tracks task executions and their data in the file system. Args: backend (bandsaw.tracking.backend.Backend): The backend implementation to use. Raises: TypeError: If `backend` does not inherit from `Backend` base class. ValueError: If no backend is given. \"\"\" if backend is None : raise ValueError ( \"Backend must be set.\" ) if not isinstance ( backend , Backend ): raise TypeError ( \"`backend` is not of type `Backend`.\" ) self . _backend = backend logger . info ( \"Tracking sessions using backend ' %s '\" , self . _backend ) self . _tracked_runs = set () self . _tracked_tasks = set () self . _tracked_executions = set () self . _tracked_sessions = set () self . _tracked_results = set () self . _tracked_attachments = set () super () . __init__ () on_session_created ( self , session ) \ud83d\udd17 Called before bandsaw advises a task. This is called before any advice is applied. Parameters: Name Type Description Default session bandsaw.session.Session The new session. required Source code in bandsaw/tracking/tracker.py def on_session_created ( self , session ): self . _track_run ( session ) self . _track_task ( session ) self . _track_execution ( session ) self . _track_session ( session ) on_session_finished ( self , session ) \ud83d\udd17 Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Parameters: Name Type Description Default session bandsaw.session.Session The session. required Source code in bandsaw/tracking/tracker.py def on_session_finished ( self , session ): self . _track_result ( session ) self . _track_attachments ( session ) user \ud83d\udd17 Contains functions related to users get_current_username () \ud83d\udd17 Returns the name of the user which is currently running the python process. Returns: Type Description str The name of the user on the local system. Source code in bandsaw/user.py def get_current_username (): \"\"\" Returns the name of the user which is currently running the python process. Returns: str: The name of the user on the local system. \"\"\" return pwd . getpwuid ( os . getuid ())[ 0 ]","title":"API"},{"location":"api/#bandsaw.advice","text":"Contains classes and functions for advising tasks.","title":"advice"},{"location":"api/#bandsaw.advice.Advice","text":"Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, before(session) and after(session) , that are called during the process of advising a task execution. Both take a single argument session which contains an instance of the class Session . This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result. Source code in bandsaw/advice.py class Advice : \"\"\" Interface that needs to be implemented by an advice. The interface is quite simple. One has to implement two different methods, `before(session)` and `after(session)`, that are called during the process of advising a task execution. Both take a single argument `session` which contains an instance of the class `Session`. This object allows the individual advices to influence the task execution by changing the way the task is being called or making changes to the result. \"\"\" def before ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed () def after ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed ()","title":"Advice"},{"location":"api/#bandsaw.advice.Advice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def after ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the `session`. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with current `result` and the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will set a different result and continue with it. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advice.Advice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advice.py def before ( self , session ): # pylint: disable=R0201 # no-self-use \"\"\" Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call `session.proceed()`, which will continue the process with the next advice in the advice chain, or call `session.conclude(result)` with a `Result` instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call `session.proceed()`. Args: session (bandsaw.session.Session): The session of the execution. \"\"\" session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advice.advise_task_with_chain","text":"Executes an Task with additional advices. Parameters: Name Type Description Default task bandsaw.tasks.Task The task to be executed. required execution bandsaw.execution.Execution The execution definition for the task. required configuration bandsaw.config.Configuration The configuration which should be used during advising. required advice_chain str The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. 'default' Returns: Type Description bandsaw.result.Result The result of the task execution. Source code in bandsaw/advice.py def advise_task_with_chain ( task , execution , configuration , advice_chain = 'default' ): \"\"\" Executes an `Task` with additional advices. Args: task (bandsaw.tasks.Task): The task to be executed. execution (bandsaw.execution.Execution): The execution definition for the task. configuration (bandsaw.config.Configuration): The configuration which should be used during advising. advice_chain (str): The name of the advice chain which contains the additional advices to be applied to the task. Defaults to 'default'. Returns: bandsaw.result.Result: The result of the task execution. \"\"\" session = Session ( task , execution , configuration , advice_chain ) return session . initiate ()","title":"advise_task_with_chain()"},{"location":"api/#bandsaw.advices","text":"Package that contains reusable Advice classes","title":"advices"},{"location":"api/#bandsaw.advices.cache","text":"Contains Advice that can cache task results in a local file system.","title":"cache"},{"location":"api/#bandsaw.advices.cache.CachingAdvice","text":"Advice that caches results in a local filesystem. Attributes: Name Type Description directory Path The path to the directory where the results are cached. Source code in bandsaw/advices/cache.py class CachingAdvice ( Advice ): \"\"\" Advice that caches results in a local filesystem. Attributes: directory (Path): The path to the directory where the results are cached. \"\"\" def __init__ ( self , directory ): self . directory = pathlib . Path ( directory ) logger . info ( \"Caching artifacts in storage ' %s '\" , self . directory ) super () . __init__ () def before ( self , session ): artifact_id = session . task . task_id revision_id = session . execution . execution_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed () def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed ()","title":"CachingAdvice"},{"location":"api/#bandsaw.advices.cache.CachingAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def after ( self , session ): cache_item_path = pathlib . Path ( session . context [ 'cache-item-path' ]) if not cache_item_path . exists (): cache_item_directory = cache_item_path . parent if not cache_item_directory . exists (): cache_item_directory . mkdir ( parents = True ) logger . info ( \"Storing result in cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'wb' ) as stream : session . serializer . serialize ( session . result , stream ) session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advices.cache.CachingAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/cache.py def before ( self , session ): artifact_id = session . task . task_id revision_id = session . execution . execution_id cache_item_path = self . directory / artifact_id / revision_id session . context [ 'cache-item-path' ] = str ( cache_item_path ) if cache_item_path . exists (): logger . info ( \"Using result from cache ' %s '\" , cache_item_path ) with open ( cache_item_path , 'rb' ) as stream : result = session . serializer . deserialize ( stream ) session . conclude ( result ) return session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.log","text":"Contains an Advice implementation which adds logging","title":"log"},{"location":"api/#bandsaw.advices.log.JsonFormatter","text":"Formatter that formats log records into a JSON string. Source code in bandsaw/advices/log.py class JsonFormatter ( logging . Formatter ): \"\"\" Formatter that formats log records into a JSON string. \"\"\" def format ( self , record ): timestamp = datetime . datetime . fromtimestamp ( record . created , datetime . timezone . utc , ) log_item = { \"timestamp\" : datetime . datetime . isoformat ( timestamp ), \"logger\" : record . name , \"level\" : record . levelname , \"message\" : record . message , \"threadId\" : record . thread , \"threadName\" : record . threadName , \"processId\" : record . process , \"processName\" : record . processName , \"module\" : record . module , \"function\" : record . funcName , \"path\" : record . pathname , \"line_no\" : record . lineno , } if record . exc_info is not None : log_item . update ( { 'traceback' : '' . join ( traceback . format_tb ( record . exc_info [ 2 ]) ) . strip (), 'exception' : traceback . format_exception_only ( * record . exc_info [: 2 ])[ 0 ] . strip (), } ) if hasattr ( record , 'session' ): log_item . update ( { 'sessionId' : record . session . session_id , 'runId' : record . session . run_id , 'taskId' : record . session . task . task_id , 'executionId' : record . session . execution . execution_id , } ) return json . dumps ( log_item )","title":"JsonFormatter"},{"location":"api/#bandsaw.advices.log.JsonFormatter.format","text":"Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Source code in bandsaw/advices/log.py def format ( self , record ): timestamp = datetime . datetime . fromtimestamp ( record . created , datetime . timezone . utc , ) log_item = { \"timestamp\" : datetime . datetime . isoformat ( timestamp ), \"logger\" : record . name , \"level\" : record . levelname , \"message\" : record . message , \"threadId\" : record . thread , \"threadName\" : record . threadName , \"processId\" : record . process , \"processName\" : record . processName , \"module\" : record . module , \"function\" : record . funcName , \"path\" : record . pathname , \"line_no\" : record . lineno , } if record . exc_info is not None : log_item . update ( { 'traceback' : '' . join ( traceback . format_tb ( record . exc_info [ 2 ]) ) . strip (), 'exception' : traceback . format_exception_only ( * record . exc_info [: 2 ])[ 0 ] . strip (), } ) if hasattr ( record , 'session' ): log_item . update ( { 'sessionId' : record . session . session_id , 'runId' : record . session . run_id , 'taskId' : record . session . task . task_id , 'executionId' : record . session . execution . execution_id , } ) return json . dumps ( log_item )","title":"format()"},{"location":"api/#bandsaw.advices.log.LoggingAdvice","text":"An Advice which adds additional logging Source code in bandsaw/advices/log.py class LoggingAdvice ( Advice ): \"\"\"An Advice which adds additional logging\"\"\" def __init__ ( self , level = None , formatter = None ): \"\"\" Create a new instance of the `LoggingAdvice`. Args: level (int): The log level of the messages to keep. If `None` the level is defined by the root logger. Defaults to `None`. formatter (logging.Formatter): Formatter to use for writing out the individual log messages. Defaults to `JsonFormatter`. \"\"\" self . _level = level if formatter is None : formatter = JsonFormatter () self . _formatter = formatter def before ( self , session ): session_log_file_path = session . temp_dir / 'session.log' file_handler = logging . FileHandler ( filename = str ( session_log_file_path . absolute ()), ) file_handler . set_name ( 'Handler-' + session . session_id ) if self . _level is not None : file_handler . setLevel ( self . _level ) file_handler . setFormatter ( self . _formatter ) session_filter = _SessionFilter ( session ) file_handler . addFilter ( session_filter ) logging . root . addHandler ( file_handler ) logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) session . proceed () def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) for handler in logging . root . handlers : if handler . get_name () == 'Handler-' + session . session_id : logging . root . removeHandler ( handler ) handler . flush () session . attachments [ 'session.log' ] = session . temp_dir / 'session.log' session . proceed ()","title":"LoggingAdvice"},{"location":"api/#bandsaw.advices.log.LoggingAdvice.__init__","text":"Create a new instance of the LoggingAdvice . Parameters: Name Type Description Default level int The log level of the messages to keep. If None the level is defined by the root logger. Defaults to None . None formatter logging.Formatter Formatter to use for writing out the individual log messages. Defaults to JsonFormatter . None Source code in bandsaw/advices/log.py def __init__ ( self , level = None , formatter = None ): \"\"\" Create a new instance of the `LoggingAdvice`. Args: level (int): The log level of the messages to keep. If `None` the level is defined by the root logger. Defaults to `None`. formatter (logging.Formatter): Formatter to use for writing out the individual log messages. Defaults to `JsonFormatter`. \"\"\" self . _level = level if formatter is None : formatter = JsonFormatter () self . _formatter = formatter","title":"__init__()"},{"location":"api/#bandsaw.advices.log.LoggingAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/log.py def after ( self , session ): logger . info ( \"AFTER %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) for handler in logging . root . handlers : if handler . get_name () == 'Handler-' + session . session_id : logging . root . removeHandler ( handler ) handler . flush () session . attachments [ 'session.log' ] = session . temp_dir / 'session.log' session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advices.log.LoggingAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/log.py def before ( self , session ): session_log_file_path = session . temp_dir / 'session.log' file_handler = logging . FileHandler ( filename = str ( session_log_file_path . absolute ()), ) file_handler . set_name ( 'Handler-' + session . session_id ) if self . _level is not None : file_handler . setLevel ( self . _level ) file_handler . setFormatter ( self . _formatter ) session_filter = _SessionFilter ( session ) file_handler . addFilter ( session_filter ) logging . root . addHandler ( file_handler ) logger . info ( \"BEFORE %s : %s with context %s \" , session . task . task_id , session . execution . execution_id , session . context , ) session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.metrics","text":"Contains an Advice implementation which gathers metrics.","title":"metrics"},{"location":"api/#bandsaw.advices.metrics.MetricsAdvice","text":"An Advice which gathers metrics. Underneath this advice uses the python multimeter library for collecting the metrics. Source code in bandsaw/advices/metrics.py class MetricsAdvice ( Advice ): \"\"\"An Advice which gathers metrics. Underneath this advice uses the python `multimeter` library for collecting the metrics. \"\"\" def __init__ ( self , meter , directory = None , file_format = multimeter . JsonFormat ()): \"\"\" Creates a new MetricsAdvice that gathers metrics. Args: meter (multimeter.Multimeter): The Multimeter instance which is used for gathering the metrics. directory (str): Path to a directory, where the metrics are temporarily stored. If `None` or omitted, the session temporary directory is used. file_format (multimeter.FileFormat): File format that defines the format in which the gathered metrics are stored. Defaults to `multimeter.JsonFormat`. \"\"\" self . _multimeter = meter if directory is not None : self . _directory = pathlib . Path ( directory ) else : self . _directory = None self . _file_format = file_format def before ( self , session ): tags = { 'run_id' : session . run_id , 'task_id' : session . task . task_id , 'execution_id' : session . execution . execution_id , 'session_id' : session . session_id , } advice_parameters = session . task . advice_parameters additional_tags = advice_parameters . get ( 'metrics' , {}) . get ( 'tags' , {}) tags . update ( additional_tags ) logger . info ( \"Measurement id %s with tags %s \" , session . session_id , tags ) measurement = self . _multimeter . measure ( session . session_id , ** tags ) session . context [ 'metrics.measurement' ] = measurement logger . debug ( \"Measurement start\" ) measurement . start () session . proceed () def after ( self , session ): measurement = session . context . pop ( 'metrics.measurement' ) logger . debug ( \"Measurement end\" ) measurement . end () directory = self . _directory or session . temp_dir storage = multimeter . FileStorage ( directory , self . _file_format ) storage . store ( measurement . result ) metrics_file_name = measurement . identifier + self . _file_format . extension metrics_attachment_name = 'metrics' + self . _file_format . extension session . attachments [ metrics_attachment_name ] = directory / metrics_file_name session . proceed ()","title":"MetricsAdvice"},{"location":"api/#bandsaw.advices.metrics.MetricsAdvice.__init__","text":"Creates a new MetricsAdvice that gathers metrics. Parameters: Name Type Description Default meter multimeter.Multimeter The Multimeter instance which is used for gathering the metrics. required directory str Path to a directory, where the metrics are temporarily stored. If None or omitted, the session temporary directory is used. None file_format multimeter.FileFormat File format that defines the format in which the gathered metrics are stored. Defaults to multimeter.JsonFormat . <multimeter.storages.file.JsonFormat object at 0x7f8a8f98df10> Source code in bandsaw/advices/metrics.py def __init__ ( self , meter , directory = None , file_format = multimeter . JsonFormat ()): \"\"\" Creates a new MetricsAdvice that gathers metrics. Args: meter (multimeter.Multimeter): The Multimeter instance which is used for gathering the metrics. directory (str): Path to a directory, where the metrics are temporarily stored. If `None` or omitted, the session temporary directory is used. file_format (multimeter.FileFormat): File format that defines the format in which the gathered metrics are stored. Defaults to `multimeter.JsonFormat`. \"\"\" self . _multimeter = meter if directory is not None : self . _directory = pathlib . Path ( directory ) else : self . _directory = None self . _file_format = file_format","title":"__init__()"},{"location":"api/#bandsaw.advices.metrics.MetricsAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/metrics.py def after ( self , session ): measurement = session . context . pop ( 'metrics.measurement' ) logger . debug ( \"Measurement end\" ) measurement . end () directory = self . _directory or session . temp_dir storage = multimeter . FileStorage ( directory , self . _file_format ) storage . store ( measurement . result ) metrics_file_name = measurement . identifier + self . _file_format . extension metrics_attachment_name = 'metrics' + self . _file_format . extension session . attachments [ metrics_attachment_name ] = directory / metrics_file_name session . proceed ()","title":"after()"},{"location":"api/#bandsaw.advices.metrics.MetricsAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/metrics.py def before ( self , session ): tags = { 'run_id' : session . run_id , 'task_id' : session . task . task_id , 'execution_id' : session . execution . execution_id , 'session_id' : session . session_id , } advice_parameters = session . task . advice_parameters additional_tags = advice_parameters . get ( 'metrics' , {}) . get ( 'tags' , {}) tags . update ( additional_tags ) logger . info ( \"Measurement id %s with tags %s \" , session . session_id , tags ) measurement = self . _multimeter . measure ( session . session_id , ** tags ) session . context [ 'metrics.measurement' ] = measurement logger . debug ( \"Measurement start\" ) measurement . start () session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.ssh","text":"Contains code for running tasks remotely via SSH","title":"ssh"},{"location":"api/#bandsaw.advices.ssh.Remote","text":"Definition of a remote machine. Remotes are used for executing sessions on remote machines. Attributes: Name Type Description host str The hostname of the machine, where this interpreter is run. port int The port where ssh is listening for connections. Defaults to 22. user str The name of the user, under which the interpreter will run. Defaults to the name of the local user. key_file str Path to a file containing the key to use for authentication. interpreter bandsaw.interpreter.Interpreter The interpreter which should be used, including its executable and python path. directory str Remote directory where temporary files are stored. If None , defaults to '/tmp'. Source code in bandsaw/advices/ssh.py class Remote : # pylint: disable=too-few-public-methods \"\"\" Definition of a remote machine. Remotes are used for executing sessions on remote machines. Attributes: host (str): The hostname of the machine, where this interpreter is run. port (int): The port where ssh is listening for connections. Defaults to 22. user (str): The name of the user, under which the interpreter will run. Defaults to the name of the local user. key_file (str): Path to a file containing the key to use for authentication. interpreter (bandsaw.interpreter.Interpreter): The interpreter which should be used, including its executable and python path. directory (str): Remote directory where temporary files are stored. If `None`, defaults to '/tmp'. \"\"\" def __init__ ( self , host = None , port = None , user = None , key_file = None , interpreter = None , directory = None , ): # pylint: disable=too-many-arguments if host is None : raise ValueError ( \"Remote needs a host, `None` given.\" ) self . host = host self . port = port or 22 self . user = user or get_current_username () self . key_file = key_file if interpreter is None : raise ValueError ( \"Remote needs an interpreter, `None` given.\" ) self . interpreter = interpreter self . directory = pathlib . Path ( directory or '/tmp' )","title":"Remote"},{"location":"api/#bandsaw.advices.ssh.SshAdvice","text":"Advice that moves and proceeds a session on a remote machine via SSH Source code in bandsaw/advices/ssh.py class SshAdvice ( Advice ): \"\"\"Advice that moves and proceeds a session on a remote machine via SSH\"\"\" def __init__ ( self , directory = None , backend = SshCommandLineBackend ()): \"\"\" Create a new instance. Args: directory (str): The local directory where temporary files are stored to exchange data between the local and the remote machine. If `None`, the temporary directory from the session is used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using session temporary directory for exchange data\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s for exchange data\" , self . directory ) self . remotes = {} self . _backend = backend super () . __init__ () def add_remote ( self , remote , name = 'default' ): \"\"\" Add a new definition of a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Definition of the remote machine. name (str): Name of the remote. Defaults to `default`. Returns: bandsaw.advices.ssh.SshAdvice: The advice with the added remote. \"\"\" self . remotes [ name ] = remote return self def before ( self , session ): temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( str ( session_in_path ), mode = 'w' ) as stream : session . save ( stream ) parameters = session . task . advice_parameters remote_name = parameters . get ( 'ssh' , {}) . get ( 'remote' , 'default' ) remote = self . remotes [ remote_name ] remote_run_directory = remote . directory / session . execution . execution_id logger . info ( \"Creating run directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . create_dir ( remote , remote_run_directory , ) logger . info ( \"Copying over distribution archive to host %s \" , remote . host ) distribution_archive_path = session . distribution_archive . path remote_distribution_archive_path = ( remote_run_directory / distribution_archive_path . name ) self . _backend . copy_file_to_remote ( remote , distribution_archive_path , remote_distribution_archive_path , ) logger . info ( \"Copying over session to host %s \" , remote . host ) remote_session_in_path = remote_run_directory / session_in_path . name self . _backend . copy_file_to_remote ( remote , session_in_path , remote_session_in_path , ) remote_session_out_path = remote_run_directory / session_out_path . name logger . info ( \"Running remote process using interpreter %s \" , remote . interpreter . executable ) self . _backend . execute_remote ( remote , remote . interpreter . executable , str ( remote_distribution_archive_path ), '--input' , str ( remote_session_in_path ), '--output' , str ( remote_session_out_path ), '--run-id' , session . run_id , ) # environment = self.interpreter.environment # environment['PYTHONPATH'] = ':'.join(self.interpreter.path) logger . info ( \"Remote process exited\" ) logger . info ( \"Copying over session result from host %s \" , remote . host ) self . _backend . copy_file_from_remote ( remote , remote_session_out_path , session_out_path , ) logger . info ( \"Cleaning up remote directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . delete_dir ( remote , remote_run_directory ) logger . info ( \"Restore local session from %s \" , session_out_path ) stream = io . FileIO ( str ( session_out_path ), mode = 'r' ) session . restore ( stream ) logger . info ( \"Cleaning up local sessions %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"Proceed local session\" ) session . proceed () def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Remote process created result %s \" , session . result ) logger . info ( \"Returning to end remote session and continue in parent\" )","title":"SshAdvice"},{"location":"api/#bandsaw.advices.ssh.SshAdvice.__init__","text":"Create a new instance. Parameters: Name Type Description Default directory str The local directory where temporary files are stored to exchange data between the local and the remote machine. If None , the temporary directory from the session is used. None Source code in bandsaw/advices/ssh.py def __init__ ( self , directory = None , backend = SshCommandLineBackend ()): \"\"\" Create a new instance. Args: directory (str): The local directory where temporary files are stored to exchange data between the local and the remote machine. If `None`, the temporary directory from the session is used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using session temporary directory for exchange data\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s for exchange data\" , self . directory ) self . remotes = {} self . _backend = backend super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.advices.ssh.SshAdvice.add_remote","text":"Add a new definition of a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Definition of the remote machine. required name str Name of the remote. Defaults to default . 'default' Returns: Type Description bandsaw.advices.ssh.SshAdvice The advice with the added remote. Source code in bandsaw/advices/ssh.py def add_remote ( self , remote , name = 'default' ): \"\"\" Add a new definition of a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Definition of the remote machine. name (str): Name of the remote. Defaults to `default`. Returns: bandsaw.advices.ssh.SshAdvice: The advice with the added remote. \"\"\" self . remotes [ name ] = remote return self","title":"add_remote()"},{"location":"api/#bandsaw.advices.ssh.SshAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/ssh.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Remote process created result %s \" , session . result ) logger . info ( \"Returning to end remote session and continue in parent\" )","title":"after()"},{"location":"api/#bandsaw.advices.ssh.SshAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/ssh.py def before ( self , session ): temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( str ( session_in_path ), mode = 'w' ) as stream : session . save ( stream ) parameters = session . task . advice_parameters remote_name = parameters . get ( 'ssh' , {}) . get ( 'remote' , 'default' ) remote = self . remotes [ remote_name ] remote_run_directory = remote . directory / session . execution . execution_id logger . info ( \"Creating run directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . create_dir ( remote , remote_run_directory , ) logger . info ( \"Copying over distribution archive to host %s \" , remote . host ) distribution_archive_path = session . distribution_archive . path remote_distribution_archive_path = ( remote_run_directory / distribution_archive_path . name ) self . _backend . copy_file_to_remote ( remote , distribution_archive_path , remote_distribution_archive_path , ) logger . info ( \"Copying over session to host %s \" , remote . host ) remote_session_in_path = remote_run_directory / session_in_path . name self . _backend . copy_file_to_remote ( remote , session_in_path , remote_session_in_path , ) remote_session_out_path = remote_run_directory / session_out_path . name logger . info ( \"Running remote process using interpreter %s \" , remote . interpreter . executable ) self . _backend . execute_remote ( remote , remote . interpreter . executable , str ( remote_distribution_archive_path ), '--input' , str ( remote_session_in_path ), '--output' , str ( remote_session_out_path ), '--run-id' , session . run_id , ) # environment = self.interpreter.environment # environment['PYTHONPATH'] = ':'.join(self.interpreter.path) logger . info ( \"Remote process exited\" ) logger . info ( \"Copying over session result from host %s \" , remote . host ) self . _backend . copy_file_from_remote ( remote , remote_session_out_path , session_out_path , ) logger . info ( \"Cleaning up remote directory %s on host %s \" , remote_run_directory , remote . host , ) self . _backend . delete_dir ( remote , remote_run_directory ) logger . info ( \"Restore local session from %s \" , session_out_path ) stream = io . FileIO ( str ( session_out_path ), mode = 'r' ) session . restore ( stream ) logger . info ( \"Cleaning up local sessions %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"Proceed local session\" ) session . proceed ()","title":"before()"},{"location":"api/#bandsaw.advices.ssh.SshBackend","text":"Interface definition for different SSH backends. Source code in bandsaw/advices/ssh.py class SshBackend ( abc . ABC ): \"\"\" Interface definition for different SSH backends. \"\"\" def create_dir ( self , remote , remote_path ): \"\"\" Create a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be created. remote_path (str): Remote path to the directory that should be created. \"\"\" def copy_file_to_remote ( self , remote , local_path , remote_path ): \"\"\" Copies a local file or directory to a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine to which a file should be copied. local_path (pathlib.Path): Local path to the file which should be copied over. remote_path (pathlib.Path): Remote path of the file where it should be copied to. \"\"\" def copy_file_from_remote ( self , remote , remote_path , local_path ): \"\"\" Copies a remote file or directory to the local file system. Args: remote (bandsaw.advices.ssh.Remote): Remote machine from which a file should be copied. remote_path (pathlib.Path): Remote path of the file which should be copied. local_path (pathlib.Path): Local path to the file where it should be copied to. \"\"\" def execute_remote ( self , remote , executable , * arguments ): \"\"\" Executes an executable on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where `executable` will be executed. executable (str): Remote path of the executable which should be executed. *arguments (str): Positional arguments which are the command line parameter for the `executable`. Raises: subprocess.CalledProcessError: If the remote process ends with an error. Its return code will be available through the exception. \"\"\" def delete_dir ( self , remote , remote_path ): \"\"\" Delete a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be deleted. remote_path (str): Remote path to the directory that should be deleted. \"\"\"","title":"SshBackend"},{"location":"api/#bandsaw.advices.ssh.SshBackend.copy_file_from_remote","text":"Copies a remote file or directory to the local file system. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine from which a file should be copied. required remote_path pathlib.Path Remote path of the file which should be copied. required local_path pathlib.Path Local path to the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_from_remote ( self , remote , remote_path , local_path ): \"\"\" Copies a remote file or directory to the local file system. Args: remote (bandsaw.advices.ssh.Remote): Remote machine from which a file should be copied. remote_path (pathlib.Path): Remote path of the file which should be copied. local_path (pathlib.Path): Local path to the file where it should be copied to. \"\"\"","title":"copy_file_from_remote()"},{"location":"api/#bandsaw.advices.ssh.SshBackend.copy_file_to_remote","text":"Copies a local file or directory to a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine to which a file should be copied. required local_path pathlib.Path Local path to the file which should be copied over. required remote_path pathlib.Path Remote path of the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_to_remote ( self , remote , local_path , remote_path ): \"\"\" Copies a local file or directory to a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine to which a file should be copied. local_path (pathlib.Path): Local path to the file which should be copied over. remote_path (pathlib.Path): Remote path of the file where it should be copied to. \"\"\"","title":"copy_file_to_remote()"},{"location":"api/#bandsaw.advices.ssh.SshBackend.create_dir","text":"Create a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be created. required remote_path str Remote path to the directory that should be created. required Source code in bandsaw/advices/ssh.py def create_dir ( self , remote , remote_path ): \"\"\" Create a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be created. remote_path (str): Remote path to the directory that should be created. \"\"\"","title":"create_dir()"},{"location":"api/#bandsaw.advices.ssh.SshBackend.delete_dir","text":"Delete a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be deleted. required remote_path str Remote path to the directory that should be deleted. required Source code in bandsaw/advices/ssh.py def delete_dir ( self , remote , remote_path ): \"\"\" Delete a directory on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where a directory will be deleted. remote_path (str): Remote path to the directory that should be deleted. \"\"\"","title":"delete_dir()"},{"location":"api/#bandsaw.advices.ssh.SshBackend.execute_remote","text":"Executes an executable on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where executable will be executed. required executable str Remote path of the executable which should be executed. required *arguments str Positional arguments which are the command line parameter for the executable . () Exceptions: Type Description subprocess.CalledProcessError If the remote process ends with an error. Its return code will be available through the exception. Source code in bandsaw/advices/ssh.py def execute_remote ( self , remote , executable , * arguments ): \"\"\" Executes an executable on a remote machine. Args: remote (bandsaw.advices.ssh.Remote): Remote machine where `executable` will be executed. executable (str): Remote path of the executable which should be executed. *arguments (str): Positional arguments which are the command line parameter for the `executable`. Raises: subprocess.CalledProcessError: If the remote process ends with an error. Its return code will be available through the exception. \"\"\"","title":"execute_remote()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend","text":"SSH backend that uses the SSH command line tools. Source code in bandsaw/advices/ssh.py class SshCommandLineBackend ( SshBackend ): \"\"\" SSH backend that uses the SSH command line tools. \"\"\" def create_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'mkdir' , '-p' , str ( remote_path ), ] ) def copy_file_to_remote ( self , remote , local_path , remote_path ): copy_destination = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ str ( local_path ), copy_destination , ], ) def copy_file_from_remote ( self , remote , remote_path , local_path ): copy_source = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ copy_source , str ( local_path ), ], ) def execute_remote ( self , remote , executable , * arguments ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), str ( executable ), ] + list ( arguments ), ) def delete_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'rm' , '-Rf' , str ( remote_path ), ] ) @staticmethod def _run ( command ): logger . debug ( \"running command %s \" , command ) subprocess . check_call ( command ) @staticmethod def login ( remote ): \"\"\"Returns the destination of the remote in form of <user>@<host>\"\"\" return f \" { remote . user } @ { remote . host } \" def get_remote_path ( self , remote , path ): \"\"\"Returns the remote path in form of <user>@<host>:<path>\"\"\" return f \" { self . login ( remote ) } : { path . absolute () } \" @staticmethod def _key_file_option ( remote ): if remote . key_file is not None : return [ '-i' , remote . key_file , ] return []","title":"SshCommandLineBackend"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.copy_file_from_remote","text":"Copies a remote file or directory to the local file system. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine from which a file should be copied. required remote_path pathlib.Path Remote path of the file which should be copied. required local_path pathlib.Path Local path to the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_from_remote ( self , remote , remote_path , local_path ): copy_source = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ copy_source , str ( local_path ), ], )","title":"copy_file_from_remote()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.copy_file_to_remote","text":"Copies a local file or directory to a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine to which a file should be copied. required local_path pathlib.Path Local path to the file which should be copied over. required remote_path pathlib.Path Remote path of the file where it should be copied to. required Source code in bandsaw/advices/ssh.py def copy_file_to_remote ( self , remote , local_path , remote_path ): copy_destination = self . get_remote_path ( remote , remote_path ) self . _run ( [ 'scp' , '-P' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ str ( local_path ), copy_destination , ], )","title":"copy_file_to_remote()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.create_dir","text":"Create a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be created. required remote_path str Remote path to the directory that should be created. required Source code in bandsaw/advices/ssh.py def create_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'mkdir' , '-p' , str ( remote_path ), ] )","title":"create_dir()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.delete_dir","text":"Delete a directory on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where a directory will be deleted. required remote_path str Remote path to the directory that should be deleted. required Source code in bandsaw/advices/ssh.py def delete_dir ( self , remote , remote_path ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), 'rm' , '-Rf' , str ( remote_path ), ] )","title":"delete_dir()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.execute_remote","text":"Executes an executable on a remote machine. Parameters: Name Type Description Default remote bandsaw.advices.ssh.Remote Remote machine where executable will be executed. required executable str Remote path of the executable which should be executed. required *arguments str Positional arguments which are the command line parameter for the executable . () Exceptions: Type Description subprocess.CalledProcessError If the remote process ends with an error. Its return code will be available through the exception. Source code in bandsaw/advices/ssh.py def execute_remote ( self , remote , executable , * arguments ): return self . _run ( [ 'ssh' , '-p' , str ( remote . port ), ] + self . _key_file_option ( remote ) + [ self . login ( remote ), str ( executable ), ] + list ( arguments ), )","title":"execute_remote()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.get_remote_path","text":"Returns the remote path in form of @ : Source code in bandsaw/advices/ssh.py def get_remote_path ( self , remote , path ): \"\"\"Returns the remote path in form of <user>@<host>:<path>\"\"\" return f \" { self . login ( remote ) } : { path . absolute () } \"","title":"get_remote_path()"},{"location":"api/#bandsaw.advices.ssh.SshCommandLineBackend.login","text":"Returns the destination of the remote in form of @ Source code in bandsaw/advices/ssh.py @staticmethod def login ( remote ): \"\"\"Returns the destination of the remote in form of <user>@<host>\"\"\" return f \" { remote . user } @ { remote . host } \"","title":"login()"},{"location":"api/#bandsaw.advices.subprocess","text":"Contains Advice implementation that runs the execution in a subprocess","title":"subprocess"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice","text":"Advice that runs in a subprocess Source code in bandsaw/advices/subprocess.py class SubprocessAdvice ( Advice ): \"\"\"Advice that runs in a subprocess\"\"\" def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using temporary session directory\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ () def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' archive_path = session . distribution_archive . path logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_path , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Continue session in subprocess using interpreter %s and \" \"distribution archive %s \" , self . interpreter . executable , archive_path , ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , archive_path , '--input' , session_in_path , '--output' , session_out_path , '--run-id' , session . run_id , ], env = environment , ) logger . info ( \"Sub process exited\" ) logger . info ( \"Reading session from %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Cleaning up session files %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"proceed() session in parent process\" ) session . proceed () def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) logger . info ( \"Returning to end session and continue in parent\" )","title":"SubprocessAdvice"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.__init__","text":"Create a new instance. Parameters: Name Type Description Default directory str The directory where temporary files are stored to exchange data between both processes. If None a temporary directory is used. None interpreter bandsaw.interpreter.Interpreter The interpreter to use in the subprocess. If None the same interpreter will be used. None Source code in bandsaw/advices/subprocess.py def __init__ ( self , directory = None , interpreter = None ): \"\"\" Create a new instance. Args: directory (str): The directory where temporary files are stored to exchange data between both processes. If `None` a temporary directory is used. interpreter (bandsaw.interpreter.Interpreter): The interpreter to use in the subprocess. If `None` the same interpreter will be used. \"\"\" if directory is None : self . directory = None logger . info ( \"Using temporary session directory\" ) else : self . directory = pathlib . Path ( directory ) logger . info ( \"Using directory %s \" , self . directory ) self . interpreter = interpreter or Interpreter () super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.after","text":"Called after the task is actually executed. This methods allows the individual advice, to make changes to the result of the task execution. The result can be retrieved from the session . In order to continue, the advice MUST either call session.proceed() , which will continue the process with current result and the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will set a different result and continue with it. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def after ( self , session ): logger . info ( \"after called in process %d \" , os . getpid ()) logger . info ( \"Sub process created result %s \" , session . result ) logger . info ( \"Returning to end session and continue in parent\" )","title":"after()"},{"location":"api/#bandsaw.advices.subprocess.SubprocessAdvice.before","text":"Called before the task is actually executed. This methods allows the individual advice, to make changes to the way the task execution is later executed. In order to continue, the advice MUST either call session.proceed() , which will continue the process with the next advice in the advice chain, or call session.conclude(result) with a Result instance, which will skip the following advices and return without executing the task execution at all. The default implementation will just call session.proceed() . Parameters: Name Type Description Default session bandsaw.session.Session The session of the execution. required Source code in bandsaw/advices/subprocess.py def before ( self , session ): logger . info ( \"before called in process %d \" , os . getpid ()) temp_dir = self . directory or session . temp_dir session_in_path = temp_dir / f 'session- { session . session_id } -in.zip' session_out_path = temp_dir / f 'session- { session . session_id } -out.zip' archive_path = session . distribution_archive . path logger . info ( \"Writing session to %s \" , session_in_path ) with io . FileIO ( session_in_path , mode = 'w' ) as stream : session . save ( stream ) logger . info ( \"Continue session in subprocess using interpreter %s and \" \"distribution archive %s \" , self . interpreter . executable , archive_path , ) environment = self . interpreter . environment environment [ 'PYTHONPATH' ] = ':' . join ( self . interpreter . path ) subprocess . check_call ( [ self . interpreter . executable , archive_path , '--input' , session_in_path , '--output' , session_out_path , '--run-id' , session . run_id , ], env = environment , ) logger . info ( \"Sub process exited\" ) logger . info ( \"Reading session from %s \" , session_out_path ) with io . FileIO ( session_out_path , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Cleaning up session files %s , %s \" , session_in_path , session_out_path , ) session_in_path . unlink () session_out_path . unlink () logger . info ( \"proceed() session in parent process\" ) session . proceed ()","title":"before()"},{"location":"api/#bandsaw.config","text":"Contains the class and functions to configure bandsaw.","title":"config"},{"location":"api/#bandsaw.config.Configuration","text":"Class that represents a configuration for bandsaw. Attributes: Name Type Description temporary_directory pathlib.Path The path to a directory where temporary files are stored. Source code in bandsaw/config.py class Configuration : \"\"\" Class that represents a configuration for bandsaw. Attributes: temporary_directory (pathlib.Path): The path to a directory where temporary files are stored. \"\"\" def __init__ ( self ): self . _advice_chains = {} self . extensions = [] self . serializer = PickleSerializer () self . add_advice_chain () stack = traceback . extract_stack ( limit = 2 ) config_module_file_path = stack [ 0 ] . filename self . module_name = get_loaded_module_name_by_path ( config_module_file_path ) logger . info ( \"Config created in module: %s \" , self . module_name ) self . distribution_modules = [] self . temporary_directory = None self . set_temp_directory ( tempfile . mkdtemp ( prefix = 'bandsaw' )) def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name ) def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self def add_modules_for_distribution ( self , * modules ): \"\"\" Add modules that should be included in the distribution archive. Args: *modules (List[str]): Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. Returns: bandsaw.config.Configuration: The configuration with the added modules. \"\"\" self . distribution_modules . extend ( modules ) return self def set_temp_directory ( self , directory ): \"\"\" Sets the temporary directory. Args: directory (Union[str, pathlib.Path]): Path to the directory, where temporary files will be stored. \"\"\" self . temporary_directory = pathlib . Path ( directory ) atexit . register ( lambda path : shutil . rmtree ( path , ignore_errors = True ), str ( self . temporary_directory ), ) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . module_name == other . module_name def __hash__ ( self ): return hash ( self . module_name )","title":"Configuration"},{"location":"api/#bandsaw.config.Configuration.add_advice_chain","text":"Add a new advice chain to the configuration. Each advice chain has a unique name . If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Parameters: Name Type Description Default *advices bandsaw.advice.Advice A tuple of advices for this chain. () name str The name of the advice chain, defaults to 'default' if not specified. 'default' Returns: Type Description bandsaw.config.Configuration The configuration to which the chain was added. Source code in bandsaw/config.py def add_advice_chain ( self , * advices , name = 'default' ): \"\"\" Add a new advice chain to the configuration. Each advice chain has a unique `name`. If multiple chains with the same name are added to the configuration, the last chain overwrites all previous chains. Args: *advices (bandsaw.advice.Advice): A tuple of advices for this chain. name (str): The name of the advice chain, defaults to 'default' if not specified. Returns: bandsaw.config.Configuration: The configuration to which the chain was added. \"\"\" self . _advice_chains [ name ] = advices return self","title":"add_advice_chain()"},{"location":"api/#bandsaw.config.Configuration.add_extension","text":"Add an Extension to the configuration. Extensions are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Parameters: Name Type Description Default extension bandsaw.extension.Extension An object implementing the Extension . required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def add_extension ( self , extension ): \"\"\" Add an `Extension` to the configuration. `Extensions` are objects that can implement callbacks to be informed by bandsaw about certain conditions, e.g. the creation of new tasks or the final result of an execution. Args: extension (bandsaw.extension.Extension): An object implementing the `Extension`. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . extensions . append ( extension ) return self","title":"add_extension()"},{"location":"api/#bandsaw.config.Configuration.add_modules_for_distribution","text":"Add modules that should be included in the distribution archive. Parameters: Name Type Description Default *modules List[str] Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. () Returns: Type Description bandsaw.config.Configuration The configuration with the added modules. Source code in bandsaw/config.py def add_modules_for_distribution ( self , * modules ): \"\"\" Add modules that should be included in the distribution archive. Args: *modules (List[str]): Positional arguments with strings, that contain the names of modules, which should be included in the distribution archive. Returns: bandsaw.config.Configuration: The configuration with the added modules. \"\"\" self . distribution_modules . extend ( modules ) return self","title":"add_modules_for_distribution()"},{"location":"api/#bandsaw.config.Configuration.get_advice_chain","text":"Returns the advice chain with the given name. Parameters: Name Type Description Default name str Name of the wanted advice chain. required Returns: Type Description List[bandsaw.advice.Advice] The advice chain with the given name. Exceptions: Type Description KeyError If no chain with the specified name is configured. Source code in bandsaw/config.py def get_advice_chain ( self , name ): \"\"\" Returns the advice chain with the given name. Args: name (str): Name of the wanted advice chain. Returns: List[bandsaw.advice.Advice]: The advice chain with the given name. Raises: KeyError: If no chain with the specified name is configured. \"\"\" return self . _advice_chains . get ( name )","title":"get_advice_chain()"},{"location":"api/#bandsaw.config.Configuration.set_serializer","text":"Sets the serialize which defines how tasks and results will be serialized. Parameters: Name Type Description Default serializer bandsaw.serialization.Serializer The serializer to use for serializing objects. required Returns: Type Description bandsaw.config.Configuration The configuration to which the extension was added. Source code in bandsaw/config.py def set_serializer ( self , serializer ): \"\"\" Sets the serialize which defines how tasks and results will be serialized. Args: serializer (bandsaw.serialization.Serializer): The serializer to use for serializing objects. Returns: bandsaw.config.Configuration: The configuration to which the extension was added. \"\"\" self . serializer = serializer return self","title":"set_serializer()"},{"location":"api/#bandsaw.config.Configuration.set_temp_directory","text":"Sets the temporary directory. Parameters: Name Type Description Default directory Union[str, pathlib.Path] Path to the directory, where temporary files will be stored. required Source code in bandsaw/config.py def set_temp_directory ( self , directory ): \"\"\" Sets the temporary directory. Args: directory (Union[str, pathlib.Path]): Path to the directory, where temporary files will be stored. \"\"\" self . temporary_directory = pathlib . Path ( directory ) atexit . register ( lambda path : shutil . rmtree ( path , ignore_errors = True ), str ( self . temporary_directory ), )","title":"set_temp_directory()"},{"location":"api/#bandsaw.config.get_configuration","text":"Return a configuration. Parameters: Name Type Description Default configuration_module str The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of Configuration . If no module name is given, a default configuration is returned based on the value of the BANDSAW_CONFIG_MODULE environment variable. If this variable is not set, we default to 'bandsaw_config'. None Returns: Type Description bandsaw.config.Configuration The configuration. Exceptions: Type Description ModuleNotFoundError If no module exists with name configuration_module . LookupError If the module doesn't contain a variable 'configuration`. TypeError If the variable configuration is not of type Configuration . Source code in bandsaw/config.py def get_configuration ( configuration_module = None ): \"\"\" Return a configuration. Args: configuration_module (str): The module name of a module, which contains the configuration. The module needs to define a member 'configuration', which contains an instance of `Configuration`. If no module name is given, a default configuration is returned based on the value of the `BANDSAW_CONFIG_MODULE` environment variable. If this variable is not set, we default to 'bandsaw_config'. Returns: bandsaw.config.Configuration: The configuration. Raises: ModuleNotFoundError: If no module exists with name `configuration_module`. LookupError: If the module doesn't contain a variable 'configuration`. TypeError: If the variable `configuration` is not of type `Configuration`. \"\"\" if configuration_module is None : default_configuration_module_name = os . getenv ( CONFIGURATION_MODULE_ENV_VARIABLE , CONFIGURATION_MODULE_DEFAULT , ) configuration_module = default_configuration_module_name if configuration_module not in _configurations : try : _load_configuration_module ( configuration_module ) except ModuleNotFoundError : logger . warning ( \"No module found for config %s \" , configuration_module , ) raise return _configurations [ configuration_module ]","title":"get_configuration()"},{"location":"api/#bandsaw.context","text":"Classes that represent the context used in advising tasks.","title":"context"},{"location":"api/#bandsaw.context.Context","text":"Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the Advice classes to store state or communicate with other advices. Source code in bandsaw/context.py class Context ( SerializableValue ): \"\"\" Class for representing the context for advising tasks. The context contains of a set of arbitrary key-value mappings that can be used by the `Advice` classes to store state or communicate with other advices. \"\"\" def __init__ ( self , attributes = None ): self . _attributes = attributes or {} def serialized ( self ): data = { 'attributes' : self . _attributes , } return data @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ]) @property def attributes ( self ): \"\"\" A set of arbitrary key-value mappings for the `Advice` classes. `Advice` can add to this mapping and use this as a way of keeping state. \"\"\" return self . _attributes def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . _attributes == other . _attributes","title":"Context"},{"location":"api/#bandsaw.context.Context.attributes","text":"A set of arbitrary key-value mappings for the Advice classes. Advice can add to this mapping and use this as a way of keeping state.","title":"attributes"},{"location":"api/#bandsaw.context.Context.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/context.py @classmethod def deserialize ( cls , values ): return Context ( values [ 'attributes' ])","title":"deserialize()"},{"location":"api/#bandsaw.context.Context.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/context.py def serialized ( self ): data = { 'attributes' : self . _attributes , } return data","title":"serialized()"},{"location":"api/#bandsaw.decorator","text":"Contains decorators that allow to define individual tasks","title":"decorator"},{"location":"api/#bandsaw.decorator.task","text":"Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Examples: >>> @task ... def my_task_function (): ... pass or with additional configuration. Examples: >>> @task ( config = 'my.config' ) ... def my_task_function (): ... pass Parameters: Name Type Description Default config str The name of the configuration module to use for this task. If not given, the default configuration is used. None chain str The name of the advice chain to use for advising this task. If not given, 'default' is used. None *task_args Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, task_args contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, task_args contains the positional arguments of the call of the decorator. () **task_kwargs Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, task_kwargs is an empty dictionary. If there is additional configuration given, task_kwargs contains the keyword arguments of the call of the decorator. {} Returns: Type Description Callable Returns a callable that wraps the decorated function. Exceptions: Type Description ModuleNotFoundError If the configured configuration module does not exist. ValueError If the specified advice chain does not exist. RuntimeError If the task is configured with multiple positional arguments. Source code in bandsaw/decorator.py def task ( * task_args , config = None , chain = None , ** task_kwargs ): \"\"\" Decorator that is used to define a function as as task. The decorator can be used in two different ways, standalone: Example: >>> @task ... def my_task_function(): ... pass or with additional configuration. Example: >>> @task(config='my.config') ... def my_task_function(): ... pass Args: config (str): The name of the configuration module to use for this task. If not given, the default configuration is used. chain (str): The name of the advice chain to use for advising this task. If not given, 'default' is used. *task_args: Positional args given to the decorator OR the decorated function. If the decorator is used WITHOUT providing additional configuration, `task_args` contains a tuple with a single item that is the function to be used as a task. If there is additional configuration given, `task_args` contains the positional arguments of the call of the decorator. **task_kwargs: Keyword args given to the decorator. If the decorator is used WITHOUT providing additional configuration, `task_kwargs` is an empty dictionary. If there is additional configuration given, `task_kwargs`contains the keyword arguments of the call of the decorator. Returns: Callable: Returns a callable that wraps the decorated function. Raises: ModuleNotFoundError: If the configured configuration module does not exist. ValueError: If the specified advice chain does not exist. RuntimeError: If the task is configured with multiple positional arguments. \"\"\" config_module = config configuration = get_configuration ( config_module ) chain_name = chain or 'default' advice_chain = configuration . get_advice_chain ( chain_name ) if advice_chain is None : raise ValueError ( f \"Unknown advice chain { chain_name } \" ) def decorate_function ( func ): logger . info ( \"Decorate function ' %s '\" , func ) logger . info ( \"Creating task for function ' %s '\" , func ) the_task = Task . create_task ( func , task_kwargs ) def inner ( * func_args , ** func_kwargs ): execution_id = _calculate_execution_id ( func_args , func_kwargs , configuration . serializer , ) execution = Execution ( execution_id , func_args , func_kwargs ) result = advise_task_with_chain ( the_task , execution , configuration , chain_name , ) if result . exception : raise result . exception return result . value inner . __wrapped__ = func inner . bandsaw_task = the_task inner . bandsaw_configuration = configuration return inner if len ( task_args ) == 1 and len ( task_kwargs ) == 0 : return decorate_function ( task_args [ 0 ]) if len ( task_args ) == 0 and ( len ( task_kwargs ) > 0 or chain is not None or config is not None ): return decorate_function # This shouldn't happen if the decorator is properly used. raise RuntimeError ( \"Invalid 'task' decorator.\" )","title":"task()"},{"location":"api/#bandsaw.distribution","text":"Contains functions for creating distribution archives. Distribution archives are the way how bandsaw transfers code between different machines. They are normal zip files, that contain bandsaw itself, a main module which allows to execute the archive and to continue sessions and possibly some additional dependencies.","title":"distribution"},{"location":"api/#bandsaw.distribution.DistributionArchive","text":"Class that represents a distribution archive. A distribution archive contains all the code necessary for running a task. It can be used for running a task on a different machine by copying over the archive. Attributes: Name Type Description path pathlib.Path The path to the file containing the code. modules tuple[str] The names of the modules that are included in this archive. Source code in bandsaw/distribution.py class DistributionArchive : \"\"\" Class that represents a distribution archive. A distribution archive contains all the code necessary for running a task. It can be used for running a task on a different machine by copying over the archive. Attributes: path (pathlib.Path): The path to the file containing the code. modules (tuple[str]): The names of the modules that are included in this archive. \"\"\" def __init__ ( self , path , * modules ): self . _path = path self . modules = modules @property def path ( self ): \"\"\" Returns: pathlib.Path: The path to the archive file. The file itself is created lazily, when the path is accessed the first time. This makes sure, we only create the archive if necessary. \"\"\" if not self . _path . exists (): _create_distribution_archive ( self . _path , self . modules ) return self . _path def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . modules == other . modules def __hash__ ( self ): return hash ( self . modules )","title":"DistributionArchive"},{"location":"api/#bandsaw.distribution.DistributionArchive.path","text":"Returns: Type Description pathlib.Path The path to the archive file. The file itself is created lazily, when the path is accessed the first time. This makes sure, we only create the archive if necessary.","title":"path"},{"location":"api/#bandsaw.distribution.get_distribution_archive","text":"Returns a distribution archive for a given configuration. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration for which the distribution package should be returned. required Returns: Type Description bandsaw.distribution.DistributionArchive The archive for the configuration. Source code in bandsaw/distribution.py def get_distribution_archive ( configuration ): \"\"\" Returns a distribution archive for a given configuration. Args: configuration (bandsaw.config.Configuration): The configuration for which the distribution package should be returned. Returns: bandsaw.distribution.DistributionArchive: The archive for the configuration. \"\"\" archive = _CACHE . get_archive ( configuration ) if archive is None : archive_path = pathlib . Path ( tempfile . mktemp ( suffix = '.pyz' , prefix = 'distribution-' ) ) modules = [ '__main__' , 'bandsaw' , configuration . module_name , * configuration . distribution_modules , ] archive = DistributionArchive ( archive_path , * modules ) _CACHE . put_archive ( configuration , archive ) return archive","title":"get_distribution_archive()"},{"location":"api/#bandsaw.execution","text":"Contains classes and functions around an execution of a task","title":"execution"},{"location":"api/#bandsaw.execution.Execution","text":"Class that defines an execution of a Task . It contains the arguments that should be used for the task and an unique identifier derived from those arguments. Attributes: Name Type Description execution_id str A string identifying this execution. args tuple[Any] The positional arguments for the task to use in this execution. kwargs Dict[Any,Any] The keyword arguments for the task to use in this execution. Source code in bandsaw/execution.py class Execution ( SerializableValue ): \"\"\" Class that defines an execution of a `Task`. It contains the arguments that should be used for the task and an unique identifier derived from those arguments. Attributes: execution_id (str): A string identifying this execution. args (tuple[Any]): The positional arguments for the task to use in this execution. kwargs (Dict[Any,Any]): The keyword arguments for the task to use in this execution. \"\"\" def __init__ ( self , execution_id , args = None , kwargs = None ): self . execution_id = execution_id self . args = args or () self . kwargs = kwargs or {} def serialized ( self ): return { 'execution_id' : self . execution_id , 'args' : self . args , 'kwargs' : self . kwargs , } @classmethod def deserialize ( cls , values ): return Execution ( values [ 'execution_id' ], values [ 'args' ], values [ 'kwargs' ], )","title":"Execution"},{"location":"api/#bandsaw.execution.Execution.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/execution.py @classmethod def deserialize ( cls , values ): return Execution ( values [ 'execution_id' ], values [ 'args' ], values [ 'kwargs' ], )","title":"deserialize()"},{"location":"api/#bandsaw.execution.Execution.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/execution.py def serialized ( self ): return { 'execution_id' : self . execution_id , 'args' : self . args , 'kwargs' : self . kwargs , }","title":"serialized()"},{"location":"api/#bandsaw.extensions","text":"Contains an API for extensions that can be used in bandsaw","title":"extensions"},{"location":"api/#bandsaw.extensions.Extension","text":"Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than Advice , an Extension is globally defined in a config and therefore applies to all tasks. Source code in bandsaw/extensions.py class Extension : \"\"\" Class that defines the interface of extensions. An extension can define different callbacks that are called by bandsaw and allows to extend some existing functionality (e.g. by setting additional values in a context before it is handled by all advices) or integrate other systems. Other than `Advice`, an `Extension` is globally defined in a config and therefore applies to all tasks. \"\"\" def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\" def on_session_created ( self , session ): \"\"\" Called before bandsaw advises a task. This is called before any advice is applied. Args: session (bandsaw.session.Session): The new session. \"\"\" def on_session_finished ( self , session ): \"\"\" Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Args: session (bandsaw.session.Session): The session. \"\"\"","title":"Extension"},{"location":"api/#bandsaw.extensions.Extension.on_init","text":"Called when a bandsaw configuration has been initialized. Parameters: Name Type Description Default configuration bandsaw.config.Configuration The configuration object which contains the config that has been loaded. required Source code in bandsaw/extensions.py def on_init ( self , configuration ): \"\"\" Called when a bandsaw configuration has been initialized. Args: configuration (bandsaw.config.Configuration): The configuration object which contains the config that has been loaded. \"\"\"","title":"on_init()"},{"location":"api/#bandsaw.extensions.Extension.on_session_created","text":"Called before bandsaw advises a task. This is called before any advice is applied. Parameters: Name Type Description Default session bandsaw.session.Session The new session. required Source code in bandsaw/extensions.py def on_session_created ( self , session ): \"\"\" Called before bandsaw advises a task. This is called before any advice is applied. Args: session (bandsaw.session.Session): The new session. \"\"\"","title":"on_session_created()"},{"location":"api/#bandsaw.extensions.Extension.on_session_finished","text":"Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Parameters: Name Type Description Default session bandsaw.session.Session The session. required Source code in bandsaw/extensions.py def on_session_finished ( self , session ): \"\"\" Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Args: session (bandsaw.session.Session): The session. \"\"\"","title":"on_session_finished()"},{"location":"api/#bandsaw.identifier","text":"Functions for generating identifier for arbitrary python objects.","title":"identifier"},{"location":"api/#bandsaw.identifier.identifier_from_bytes","text":"Derive an identifier from a bytebuffer. Parameters: Name Type Description Default buffer Union[bytes,bytearray] The binary data from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_bytes ( buffer ): \"\"\" Derive an identifier from a bytebuffer. Args: buffer (Union[bytes,bytearray]): The binary data from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = hashlib . sha256 ( buffer ) . hexdigest ()[: _ID_LENGTH ] return identifier","title":"identifier_from_bytes()"},{"location":"api/#bandsaw.identifier.identifier_from_string","text":"Derive an identifier from a string. Parameters: Name Type Description Default string str The string from which to derive an identifier. required Returns: Type Description str The identifier in form of a string of a hexadecimal number. Source code in bandsaw/identifier.py def identifier_from_string ( string ): \"\"\" Derive an identifier from a string. Args: string (str): The string from which to derive an identifier. Returns: str: The identifier in form of a string of a hexadecimal number. \"\"\" identifier = identifier_from_bytes ( string . encode ( 'utf-8' )) return identifier","title":"identifier_from_string()"},{"location":"api/#bandsaw.infos","text":"Infos about values, arguments and tasks","title":"infos"},{"location":"api/#bandsaw.infos.value_info","text":"Information about a value. The information contains a string representation and a type name, but additional infos can be included as well. Parameters: Name Type Description Default value Any The value for which the infos should be returned. required Returns: Type Description Dict[str,str] A dictionary containing the infos about the value. Source code in bandsaw/infos.py def value_info ( value ): \"\"\" Information about a value. The information contains a string representation and a type name, but additional infos can be included as well. Args: value (Any): The value for which the infos should be returned. Returns: Dict[str,str]: A dictionary containing the infos about the value. \"\"\" value_type = type ( value ) if isinstance ( value , set ): value = sorted ( value ) string_value = str ( value ) if len ( string_value ) > 100 : string_value = string_value [: 85 ] + '...' + string_value [ - 12 :] info = { 'type' : value_type . __qualname__ , 'value' : string_value , } if hasattr ( value , '__len__' ): info [ 'size' ] = str ( len ( value )) if hasattr ( value , 'info' ): info . update ( value . info ()) return info","title":"value_info()"},{"location":"api/#bandsaw.interpreter","text":"Contains classes regarding python interpreters","title":"interpreter"},{"location":"api/#bandsaw.interpreter.Interpreter","text":"Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined. Source code in bandsaw/interpreter.py class Interpreter ( SerializableValue ): \"\"\" Class for representing different python interpreters. This class is used to contain the information about specific python interpreters that are used within the library. In order to support multiple different interpreters there will be the option to define the interpreter as part of config. Currently only a single interpreter is automatically defined. \"\"\" def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" if path is None : self . _path = tuple ( sys . path ) else : self . _path = tuple ( path ) self . executable = executable or sys . executable self . _environment = {} def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self @property def environment ( self ): \"\"\"The environment variables to be set for the interpreter.\"\"\" return dict ( self . _environment ) @property def path ( self ): \"\"\"The python path items that will be used.\"\"\" return tuple ( self . _path ) def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , } @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ])","title":"Interpreter"},{"location":"api/#bandsaw.interpreter.Interpreter.environment","text":"The environment variables to be set for the interpreter.","title":"environment"},{"location":"api/#bandsaw.interpreter.Interpreter.path","text":"The python path items that will be used.","title":"path"},{"location":"api/#bandsaw.interpreter.Interpreter.__init__","text":"Create a new interpreter instance. Parameters: Name Type Description Default path List[str] A list of directory paths, to be used as $PYTHONPATH. If None the current sys.path is used. None executable str The path to the python executable for this interpreter. If None the current sys.executable is used. None Source code in bandsaw/interpreter.py def __init__ ( self , path = None , executable = None , ): \"\"\" Create a new interpreter instance. Args: path (List[str]): A list of directory paths, to be used as $PYTHONPATH. If `None` the current `sys.path` is used. executable (str): The path to the python executable for this interpreter. If `None` the current `sys.executable` is used. \"\"\" if path is None : self . _path = tuple ( sys . path ) else : self . _path = tuple ( path ) self . executable = executable or sys . executable self . _environment = {}","title":"__init__()"},{"location":"api/#bandsaw.interpreter.Interpreter.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/interpreter.py @classmethod def deserialize ( cls , values ): return Interpreter ( path = values [ 'path' ], executable = values [ 'executable' ], ) . set_environment ( ** values [ 'environment' ])","title":"deserialize()"},{"location":"api/#bandsaw.interpreter.Interpreter.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/interpreter.py def serialized ( self ): return { 'path' : self . _path , 'executable' : self . executable , 'environment' : self . _environment , }","title":"serialized()"},{"location":"api/#bandsaw.interpreter.Interpreter.set_environment","text":"Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Parameters: Name Type Description Default **environment Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. {} Source code in bandsaw/interpreter.py def set_environment ( self , ** environment ): \"\"\" Set the environment variables to use for this interpreter. A call to this methods overwrites all variables that have been set previously. Args: **environment: Arbitrary keyword arguments where the name of the keyword corresponds to the name of the environment variable and the values will be the values set in the environment. \"\"\" self . _environment = environment return self","title":"set_environment()"},{"location":"api/#bandsaw.io","text":"Contains classes related to input/output of data.","title":"io"},{"location":"api/#bandsaw.io.BytearrayGeneratorToStream","text":"Stream that reads from a generator that yields bytes/bytearrays. Source code in bandsaw/io.py class BytearrayGeneratorToStream ( io . RawIOBase ): \"\"\" Stream that reads from a generator that yields bytes/bytearrays. \"\"\" def __init__ ( self , generator ): self . _generator = generator self . _source = None self . _source_position = 0 super () . __init__ () def readinto ( self , buffer ): buffer_size = len ( buffer ) position = 0 generator_empty = False while True : if self . _source is None : self . _source = next ( self . _generator , None ) self . _source_position = 0 if self . _source is None : logger . debug ( \"no new bytearray from generator, ending stream\" ) generator_empty = True else : logger . debug ( \"got new bytearray from generator of size %d \" , len ( self . _source ), ) if self . _source is not None : source_bytes_left = len ( self . _source ) - self . _source_position buffer_free = buffer_size - position bytes_to_copy = min ( buffer_free , source_bytes_left ) logger . debug ( \"copy %d bytes from current value to stream via buffer of size %d \" , bytes_to_copy , buffer_size , ) buffer_end = position + bytes_to_copy source_end = self . _source_position + bytes_to_copy buffer [ position : buffer_end ] = self . _source [ self . _source_position : source_end ] position += bytes_to_copy if bytes_to_copy < source_bytes_left : self . _source_position += bytes_to_copy else : self . _source = None buffer_full = position == buffer_size if buffer_full or generator_empty : break return position","title":"BytearrayGeneratorToStream"},{"location":"api/#bandsaw.io.read_stream_to_generator","text":"Read from a stream into a generator yielding bytes . Parameters: Name Type Description Default stream io.Stream The stream to read bytes from. required buffer_size int The buffer size to read. Each individual bytes buffer returned by the generator has a maximum size of buffer_size . Defaults to 8192 if not set. 8192 Yields: Type Description bytes A byte buffer of maximum size of buffer_size . Source code in bandsaw/io.py def read_stream_to_generator ( stream , buffer_size = 8192 ): \"\"\" Read from a stream into a generator yielding `bytes`. Args: stream (io.Stream): The stream to read bytes from. buffer_size (int): The buffer size to read. Each individual `bytes` buffer returned by the generator has a maximum size of `buffer_size`. Defaults to `8192` if not set. Yields: bytes: A byte buffer of maximum size of `buffer_size`. \"\"\" buffer = bytearray ( buffer_size ) while True : read = stream . readinto ( buffer ) if read : yield buffer [: read ] else : break","title":"read_stream_to_generator()"},{"location":"api/#bandsaw.modules","text":"Utility functions for handling python modules.","title":"modules"},{"location":"api/#bandsaw.modules.get_loaded_module_name_by_path","text":"Determine the name of an already loaded module by its file path. Parameters: Name Type Description Default file_path str File path of the python file containing the module. required Returns: Type Description str The name of the module, or None if the file isn't loaded as a module. Source code in bandsaw/modules.py def get_loaded_module_name_by_path ( file_path ): \"\"\" Determine the name of an already loaded module by its file path. Args: file_path (str): File path of the python file containing the module. Returns: str: The name of the module, or `None` if the file isn't loaded as a module. \"\"\" real_path = os . path . realpath ( file_path ) for name , module in sys . modules . items (): if hasattr ( module , '__file__' ): module_path = os . path . realpath ( module . __file__ ) if module_path == real_path : return name return None","title":"get_loaded_module_name_by_path()"},{"location":"api/#bandsaw.modules.import_object","text":"Import a python object from a module. Parameters: Name Type Description Default object_name str The name under which the object is defined in the module. required module_name str The name of the module from which the object should be imported. required Returns: Type Description object The python object defined under the name. Exceptions: Type Description AttributeError If nothing is defined with name object_name in the referenced module. ModuleNotFoundError If no module exists with the name module_name . Source code in bandsaw/modules.py def import_object ( object_name , module_name ): \"\"\" Import a python object from a module. Args: object_name (str): The name under which the object is defined in the module. module_name (str): The name of the module from which the object should be imported. Returns: object: The python object defined under the name. Raises: AttributeError: If nothing is defined with name `object_name` in the referenced module. ModuleNotFoundError: If no module exists with the name `module_name`. \"\"\" module = importlib . import_module ( module_name ) return getattr ( module , object_name )","title":"import_object()"},{"location":"api/#bandsaw.modules.object_as_import","text":"Returns the name and module of an object, which can be used for importing it. Parameters: Name Type Description Default obj object An arbitrary Python object. required Returns: Type Description Tuple(str, str) Returns a tuple of the object name and the module name in which the object is defined. Exceptions: Type Description ValueError If obj doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note If obj is defined within the __main__ script, the function tries to determine a name for the __main__ module, under which it could be imported from other scripts. Source code in bandsaw/modules.py def object_as_import ( obj ): \"\"\" Returns the name and module of an object, which can be used for importing it. Args: obj (object): An arbitrary Python object. Returns: Tuple(str, str): Returns a tuple of the object name and the module name in which the object is defined. Raises: ValueError: If `obj` doesn't have a name that can be directly imported, e.g. because it is defined within a local class. Note: If `obj` is defined within the `__main__` script, the function tries to determine a name for the `__main__` module, under which it could be imported from other scripts. \"\"\" object_name = obj . __name__ module_name = obj . __module__ if module_name == '__main__' : module_file_path = sys . modules [ '__main__' ] . __file__ module_name = _guess_module_name_by_path ( module_file_path , sys . path ) if '<locals>' in obj . __qualname__ : raise ValueError ( \"Can't import local functions.\" ) return object_name , module_name","title":"object_as_import()"},{"location":"api/#bandsaw.result","text":"Contains code for representing the result of tasks.","title":"result"},{"location":"api/#bandsaw.result.Result","text":"Class to encapsulate the result of a task execution. Attributes: Name Type Description value Any The value that is returned by the task. None is the task raised an exception during execution. exception Exception The exception that was raised during execution, None if no exception was raised. Source code in bandsaw/result.py class Result ( SerializableValue ): \"\"\" Class to encapsulate the result of a task execution. Attributes: value (Any): The value that is returned by the task. `None` is the task raised an exception during execution. exception (Exception): The exception that was raised during execution, `None` if no exception was raised. \"\"\" def __init__ ( self , value = None , exception = None ): self . value = value self . exception = exception def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception ) def __eq__ ( self , other ): value_equals = self . value == other . value exception_type_equals = isinstance ( other . exception , type ( self . exception )) exception_args_equals = getattr ( self . exception , \"args\" , None ) == getattr ( other . exception , \"args\" , None ) return value_equals and exception_type_equals and exception_args_equals def __hash__ ( self ): return hash (( self . value , repr ( self . exception )))","title":"Result"},{"location":"api/#bandsaw.result.Result.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/result.py @classmethod def deserialize ( cls , values ): value = values [ \"value\" ] exception = values [ \"exception\" ] return Result ( value = value , exception = exception )","title":"deserialize()"},{"location":"api/#bandsaw.result.Result.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/result.py def serialized ( self ): values = { \"value\" : self . value , \"exception\" : self . exception , } return values","title":"serialized()"},{"location":"api/#bandsaw.run","text":"Functions for managing the run id.","title":"run"},{"location":"api/#bandsaw.run.get_run_id","text":"Returns the run id. The run id is a unique identifier that is specific to an individual run of a workflow. It stays the same across all task executions and can be used for tracking metrics and differentiating between different runs of the same workflow where task_id and run_id stay the same. Returns: Type Description str The unique run id. Source code in bandsaw/run.py def get_run_id (): \"\"\" Returns the run id. The run id is a unique identifier that is specific to an individual run of a workflow. It stays the same across all task executions and can be used for tracking metrics and differentiating between different runs of the same workflow where task_id and run_id stay the same. Returns: str: The unique run id. \"\"\" if _RUN_ID is None : set_run_id ( str ( uuid . uuid1 ())) return _RUN_ID","title":"get_run_id()"},{"location":"api/#bandsaw.run.set_run_id","text":"Sets the run id. Setting the run id explicitly is usually not necessary. The function is mainly used when task executions are run in a different process to make sure the run id is consistent with the spawning process, but it can be used e.g. if an external system provides a unique identifier for a specific workflow run. When set_run_id(run_id) is being used, it must be run before the first tasks are actually defined. Exceptions: Type Description RuntimeError If the run id was already set before. Source code in bandsaw/run.py def set_run_id ( run_id ): \"\"\" Sets the run id. Setting the run id explicitly is usually not necessary. The function is mainly used when task executions are run in a different process to make sure the run id is consistent with the spawning process, but it can be used e.g. if an external system provides a unique identifier for a specific workflow run. When `set_run_id(run_id)` is being used, it must be run before the first tasks are actually defined. Raises: RuntimeError: If the run id was already set before. \"\"\" global _RUN_ID # pylint: disable=global-statement if _RUN_ID is not None : logger . error ( \"run_id already set to %s when trying to set again\" , _RUN_ID ) raise RuntimeError ( \"Run ID was already set\" ) logger . info ( \"Set run_id to %s \" , run_id ) _RUN_ID = run_id","title":"set_run_id()"},{"location":"api/#bandsaw.runner","text":"Contains main() function to continue sessions from files","title":"runner"},{"location":"api/#bandsaw.runner.main","text":"Main function that can be used for proceeding a session. This function allows to read a session from a file, proceed it until it returns and then save the state of the session to a new file. It is used for running tasks in a separate process or on different machines. Parameters: Name Type Description Default args tuple[str] The arguments taken from the command line. required Source code in bandsaw/runner.py def main ( args ): \"\"\" Main function that can be used for proceeding a session. This function allows to read a session from a file, proceed it until it returns and then save the state of the session to a new file. It is used for running tasks in a separate process or on different machines. Args: args (tuple[str]): The arguments taken from the command line. \"\"\" hostname = os . uname ()[ 1 ] log_format = ( f \" {{ asctime }} { hostname } {{ process: >5d }} {{ thread: >5d }} \" f \" {{ name }} {{ levelname }} : {{ message }} \" ) logging . basicConfig ( level = logging . INFO , format = log_format , style = '{' ) parser = argparse . ArgumentParser () parser . add_argument ( '--input' , dest = 'input_session' , help = \"The session which should be continued\" , required = True , ) parser . add_argument ( '--output' , dest = 'output_session' , help = \"The session after continuation ended\" , required = True , ) parser . add_argument ( '--run-id' , dest = 'run_id' , help = \"The run id of the workflow\" , required = True , ) args = parser . parse_args ( args = args ) set_run_id ( args . run_id ) logger . info ( \"Creating new session\" ) session = Session () logger . info ( \"Reading session from %s \" , args . output_session ) with io . FileIO ( args . input_session , mode = 'r' ) as stream : session . restore ( stream ) logger . info ( \"Proceeding session\" ) session . proceed () logger . info ( \"Writing session with result to %s \" , args . output_session ) with io . FileIO ( args . output_session , mode = 'w' ) as stream : session . save ( stream )","title":"main()"},{"location":"api/#bandsaw.serialization","text":"Module for the package bandsaw.serialization. Contains all public types.","title":"serialization"},{"location":"api/#bandsaw.serialization.json","text":"Contains a Serializer that allows to serialize objects to JSON.","title":"json"},{"location":"api/#bandsaw.serialization.json.JsonSerializer","text":"A Serializer which serializes objects to JSON. Attributes: Name Type Description value_serializers List[ValueSerializer] A list of serializers that are used for serialization of custom types. Source code in bandsaw/serialization/json.py class JsonSerializer ( Serializer ): \"\"\" A `Serializer` which serializes objects to JSON. Attributes: value_serializers (List[ValueSerializer]): A list of serializers that are used for serialization of custom types. \"\"\" def __init__ ( self ): super () . __init__ () self . value_serializers = [] self . value_serializers . append ( ExceptionSerializer ()) self . value_serializers . append ( SerializableValueSerializer ()) self . value_serializers . append ( TupleSerializer ()) def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach () def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result","title":"JsonSerializer"},{"location":"api/#bandsaw.serialization.json.JsonSerializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/json.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) result = json . load ( text_stream , cls = _ExtensibleJSONDecoder , value_serializers = self . value_serializers , ) text_stream . detach () return result","title":"deserialize()"},{"location":"api/#bandsaw.serialization.json.JsonSerializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/json.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) json . dump ( value , text_stream , cls = _ExtensibleJSONEncoder , value_serializers = self . value_serializers , allow_nan = False , indent = None , separators = ( ',' , ':' ), sort_keys = True , ) text_stream . detach ()","title":"serialize()"},{"location":"api/#bandsaw.serialization.pickle","text":"Contains a Serializer which uses pickle for serializing values.","title":"pickle"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer","text":"A Serializer which serializes objects using pickle. Source code in bandsaw/serialization/pickle.py class PickleSerializer ( Serializer ): \"\"\"A `Serializer` which serializes objects using pickle.\"\"\" def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream ) def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream )","title":"PickleSerializer"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/pickle.py def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\" return pickle . load ( stream )","title":"deserialize()"},{"location":"api/#bandsaw.serialization.pickle.PickleSerializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/pickle.py def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" pickle . dump ( value , stream )","title":"serialize()"},{"location":"api/#bandsaw.serialization.serializer","text":"Base classes for serializers which allow to serialize python values.","title":"serializer"},{"location":"api/#bandsaw.serialization.serializer.Serializer","text":"Interface for Serializer which serialize objects Source code in bandsaw/serialization/serializer.py class Serializer ( abc . ABC ): \"\"\"Interface for `Serializer` which serialize objects\"\"\" @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\" @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\"","title":"Serializer"},{"location":"api/#bandsaw.serialization.serializer.Serializer.deserialize","text":"Deserialize a value/object from a binary stream. Parameters: Name Type Description Default stream io.Stream The binary stream from where the serialized value is read. required Returns: Type Description Any The object/value which was deserialized. Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def deserialize ( self , stream ): \"\"\" Deserialize a value/object from a binary stream. Args: stream (io.Stream): The binary stream from where the serialized value is read. Returns: Any: The object/value which was deserialized. \"\"\"","title":"deserialize()"},{"location":"api/#bandsaw.serialization.serializer.Serializer.serialize","text":"Serialize a value/object into a binary stream. Parameters: Name Type Description Default value Any The object/value to be serialized. required stream io.Stream The binary stream where the serialized value is written. required Source code in bandsaw/serialization/serializer.py @abc . abstractmethod def serialize ( self , value , stream ): \"\"\" Serialize a value/object into a binary stream. Args: value (Any): The object/value to be serialized. stream (io.Stream): The binary stream where the serialized value is written. \"\"\"","title":"serialize()"},{"location":"api/#bandsaw.serialization.values","text":"A collection of classes for serializing custom objects.","title":"values"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer","text":"A ValueSerializer for serializing exceptions. The serializer saves only the type and the args attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded. Source code in bandsaw/serialization/values.py class ExceptionSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing exceptions. The serializer saves only the type and the `args` attribute of the exception, therefore it won't work for all exception types, but it should cover the most. Other attributes of the exception, e.g. stacktrace etc. are discarded. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , Exception ) def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ])","title":"ExceptionSerializer"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , Exception )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type ( * representation [ 'args' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.ExceptionSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'args' : value . args , } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValue","text":"Interface for types that can serialize themselves. Source code in bandsaw/serialization/values.py class SerializableValue ( abc . ABC ): \"\"\"Interface for types that can serialize themselves.\"\"\" @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\" @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\"","title":"SerializableValue"},{"location":"api/#bandsaw.serialization.values.SerializableValue.deserialize","text":"Returns a new instance of a value from its serialized representation. Source code in bandsaw/serialization/values.py @classmethod @abc . abstractmethod def deserialize ( cls , values ): \"\"\"Returns a new instance of a value from its serialized representation.\"\"\"","title":"deserialize()"},{"location":"api/#bandsaw.serialization.values.SerializableValue.serialized","text":"Returns a serializable representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialized ( self ): \"\"\"Returns a serializable representation of the value.\"\"\"","title":"serialized()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer","text":"A ValueSerializer for serializing subclasses of SerializableValue . The serializer uses the methods defined in SerializableValue and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information. Source code in bandsaw/serialization/values.py class SerializableValueSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing subclasses of `SerializableValue`. The serializer uses the methods defined in `SerializableValue` and implemented by the individual classes to serialize values. It stores the type of the value and its serialized representation and allows to recreate the value from this information. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue ) def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ])","title":"SerializableValueSerializer"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , SerializableValue )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): module_name = representation [ 'module' ] type_name = representation [ 'type' ] module = importlib . import_module ( module_name ) value_type = getattr ( module , type_name ) return value_type . deserialize ( representation [ 'serialized' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.SerializableValueSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): state = { 'type' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'serialized' : value . serialized (), } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer","text":"A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly. Source code in bandsaw/serialization/values.py class TupleSerializer ( ValueSerializer ): \"\"\" A ValueSerializer for serializing tuples. The serializer supports normal tuples as well as named tuples. When namedtuples are deserialized it first tries to reuse an existing namedtople type. If the type can't be imported or reused, a new namedtuple type with the same name and fields is created on the fly. \"\"\" def can_serialize_value ( self , value ): return isinstance ( value , tuple ) def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ])","title":"TupleSerializer"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py def can_serialize_value ( self , value ): return isinstance ( value , tuple )","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py def deserialize_value ( self , representation ): if representation [ 'type' ] == 'namedtuple' : # try to import the namedtuple type module_name = representation [ 'module' ] type_name = representation [ 'name' ] try : module = importlib . import_module ( module_name ) tuple_type = getattr ( module , type_name ) except ( ImportError , AttributeError ) as error : logger . warning ( \"Error importing namedtuple, trying to recreate it: %s \" , error ) # Recreate a new type field_names = ' ' . join ( representation [ 'fields' ]) tuple_type = collections . namedtuple ( type_name , field_names , module = module_name ) return tuple_type ( * representation [ 'items' ]) return tuple ( representation [ 'items' ])","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.TupleSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py def serialize_value ( self , value ): if hasattr ( value , '_fields' ): state = { 'type' : 'namedtuple' , 'fields' : list ( value . _fields ), 'name' : type ( value ) . __name__ , 'module' : type ( value ) . __module__ , 'items' : list ( value ), } else : state = { 'type' : 'tuple' , 'items' : list ( value ), } return state","title":"serialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer","text":"Interface for serializers that can serialize custom values. Source code in bandsaw/serialization/values.py class ValueSerializer ( abc . ABC ): \"\"\" Interface for serializers that can serialize custom values. \"\"\" @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\" @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\" @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\"","title":"ValueSerializer"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.can_serialize_value","text":"Returns if a serializer can serialize a specific value. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description boolean True if this serializer can serialize the given value, otherwise False . Source code in bandsaw/serialization/values.py @abc . abstractmethod def can_serialize_value ( self , value ): \"\"\" Returns if a serializer can serialize a specific value. Args: value (Any): The value that should be serialized. Returns: boolean: `True` if this serializer can serialize the given value, otherwise `False`. \"\"\"","title":"can_serialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.deserialize_value","text":"Returns a deserialized value from its serialized representation. Parameters: Name Type Description Default representation Any The serialized representation of the value. required Returns: Type Description Any The deserialized value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def deserialize_value ( self , representation ): \"\"\" Returns a deserialized value from its serialized representation. Args: representation (Any): The serialized representation of the value. Returns: Any: The deserialized value. \"\"\"","title":"deserialize_value()"},{"location":"api/#bandsaw.serialization.values.ValueSerializer.serialize_value","text":"Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Parameters: Name Type Description Default value Any The value that should be serialized. required Returns: Type Description Any The serialized representation of the value. Source code in bandsaw/serialization/values.py @abc . abstractmethod def serialize_value ( self , value ): \"\"\" Returns a serialized representation of the given value. The returned representation can use standard python types like primitive values, lists or dicts. Args: value (Any): The value that should be serialized. Returns: Any: The serialized representation of the value. \"\"\"","title":"serialize_value()"},{"location":"api/#bandsaw.session","text":"Contains classes for representing an advising session","title":"session"},{"location":"api/#bandsaw.session.Attachment","text":"Class that represents a single file that as been attached to a session. Source code in bandsaw/session.py class Attachment ( abc . ABC ): \"\"\" Class that represents a single file that as been attached to a session. \"\"\" @abc . abstractmethod def open ( self ): \"\"\" Opens the attachment for reading. Returns: io.RawIOBase: binary stream for reading. \"\"\" @property @abc . abstractmethod def size ( self ): \"\"\"Return the size of the attachment in bytes\"\"\"","title":"Attachment"},{"location":"api/#bandsaw.session.Attachment.size","text":"Return the size of the attachment in bytes","title":"size"},{"location":"api/#bandsaw.session.Attachment.open","text":"Opens the attachment for reading. Returns: Type Description io.RawIOBase binary stream for reading. Source code in bandsaw/session.py @abc . abstractmethod def open ( self ): \"\"\" Opens the attachment for reading. Returns: io.RawIOBase: binary stream for reading. \"\"\"","title":"open()"},{"location":"api/#bandsaw.session.Attachments","text":"A mapping that contains attachments. Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Attachments itself is a mapping class and can be used similar to a dictionary. When a new attachments is added, it must be path to an existing file, either as str or pathlib.Path . When an attachment is accessed, an object of type Attachment is returned, that gives access to the size of the attachment and allows to read its content. Examples: >>> attachments = Attachments () >>> attachments [ 'my.attachment' ] = '/path/to/file' >>> attachment = attachments [ 'my.attachment' ] >>> attachment . size 1234 >>> attachment . open () . readall () b 'My binary file content.' Source code in bandsaw/session.py class Attachments ( collections . abc . Mapping ): \"\"\" A mapping that contains attachments. Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Attachments itself is a mapping class and can be used similar to a dictionary. When a new attachments is added, it must be path to an existing file, either as `str` or `pathlib.Path`. When an attachment is accessed, an object of type `Attachment` is returned, that gives access to the size of the attachment and allows to read its content. Examples: >>> attachments = Attachments() >>> attachments['my.attachment'] = '/path/to/file' >>> attachment = attachments['my.attachment'] >>> attachment.size 1234 >>> attachment.open().readall() b'My binary file content.' \"\"\" def __init__ ( self , zip_file = None ): \"\"\" Creates a new container for attachments. Args: zip_file (zipfile.ZipFile): An already existing zip file, which can be used for initializing with pre-existing attachments. \"\"\" self . _items = {} if zip_file is not None : self . _add_attachments_from_zip ( zip_file ) def _add_attachments_from_zip ( self , zip_file ): for file_path in zip_file . namelist (): if file_path [: 12 ] == 'attachments/' : attachment_name = file_path . split ( '/' , 1 )[ 1 ] self . _items [ attachment_name ] = _ZipAttachment ( zip_file , file_path ) def store ( self , zip_file ): \"\"\" Stores all attachments in a zip file. Args: zip_file (zipfile.ZipFile): The zip file where the attachments should be stored in. \"\"\" for name , attachment in self . _items . items (): with attachment . open () as stream : zip_file . writestr ( 'attachments/' + name , stream . read ()) def __setitem__ ( self , key , path ): if key in self . _items : raise KeyError ( f \"Attachment ' { key } ' does already exist\" ) if isinstance ( path , str ): path = pathlib . Path ( path ) if not isinstance ( path , pathlib . Path ): raise TypeError ( \"Invalid type for value, must be str or Path\" ) if not path . exists (): raise ValueError ( \"File does not exist\" ) if not path . is_file (): raise ValueError ( \"Path is not a file\" ) self . _items [ key ] = _FileAttachment ( path ) def __getitem__ ( self , key ): return self . _items [ key ] def __iter__ ( self ): return iter ( self . _items ) def __len__ ( self ): return len ( self . _items )","title":"Attachments"},{"location":"api/#bandsaw.session.Attachments.__init__","text":"Creates a new container for attachments. Parameters: Name Type Description Default zip_file zipfile.ZipFile An already existing zip file, which can be used for initializing with pre-existing attachments. None Source code in bandsaw/session.py def __init__ ( self , zip_file = None ): \"\"\" Creates a new container for attachments. Args: zip_file (zipfile.ZipFile): An already existing zip file, which can be used for initializing with pre-existing attachments. \"\"\" self . _items = {} if zip_file is not None : self . _add_attachments_from_zip ( zip_file )","title":"__init__()"},{"location":"api/#bandsaw.session.Attachments.store","text":"Stores all attachments in a zip file. Parameters: Name Type Description Default zip_file zipfile.ZipFile The zip file where the attachments should be stored in. required Source code in bandsaw/session.py def store ( self , zip_file ): \"\"\" Stores all attachments in a zip file. Args: zip_file (zipfile.ZipFile): The zip file where the attachments should be stored in. \"\"\" for name , attachment in self . _items . items (): with attachment . open () as stream : zip_file . writestr ( 'attachments/' + name , stream . read ())","title":"store()"},{"location":"api/#bandsaw.session.Ids","text":"Class that encapsulates the ids of a session. Attributes: Name Type Description task_id str The id of the task in this session. execution_id str The id of the execution of the task in this session. run_id str The id of the current run. session_id str The id of the session. The id is a combination of the three other ids. Source code in bandsaw/session.py class Ids : \"\"\" Class that encapsulates the ids of a session. Attributes: task_id (str): The id of the task in this session. execution_id (str): The id of the execution of the task in this session. run_id (str): The id of the current run. session_id (str): The id of the session. The id is a combination of the three other ids. \"\"\" slots = ( 'task_id' , 'execution_id' , 'run_id' , '_session_id' ) def __init__ ( self , task_id , execution_id , run_id ): self . task_id = task_id self . execution_id = execution_id self . run_id = run_id self . session_id = \"_\" . join ( [ self . task_id , self . execution_id , self . run_id ], ) def __str__ ( self ): return self . session_id def as_path ( self ): \"\"\" Returns a relative path derived from the ids. Returns: pathlib.Path: relative path that uses the individual ids as components. \"\"\" return pathlib . Path ( self . task_id ) / self . execution_id / self . run_id @classmethod def from_string ( cls , id_as_string ): \"\"\"Create new Ids object from its string representation.\"\"\" return Ids ( * ( id_as_string . split ( '_' ))) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . session_id == other . session_id def __hash__ ( self ): return hash ( self . session_id )","title":"Ids"},{"location":"api/#bandsaw.session.Ids.as_path","text":"Returns a relative path derived from the ids. Returns: Type Description pathlib.Path relative path that uses the individual ids as components. Source code in bandsaw/session.py def as_path ( self ): \"\"\" Returns a relative path derived from the ids. Returns: pathlib.Path: relative path that uses the individual ids as components. \"\"\" return pathlib . Path ( self . task_id ) / self . execution_id / self . run_id","title":"as_path()"},{"location":"api/#bandsaw.session.Ids.from_string","text":"Create new Ids object from its string representation. Source code in bandsaw/session.py @classmethod def from_string ( cls , id_as_string ): \"\"\"Create new Ids object from its string representation.\"\"\" return Ids ( * ( id_as_string . split ( '_' )))","title":"from_string()"},{"location":"api/#bandsaw.session.Session","text":"Class that handles the advising of an execution. A Session object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like def proceed(self) to continue or conclude() to end with a result, the advices can influence the final result. Additionally, the session provides access to the context , which allows advices to keep state, the execution that is advised, the configuration that is used for advising and the result of the execution. Attributes: Name Type Description task bandsaw.tasks.Task The task that is executed. execution bandsaw.execution.Execution The execution arguments for the task. context bandsaw.context.Context The context that can be used for advices to store state. result bandsaw.result.Result Result of the task if already computed. Otherwise, None . attachments bandsaw.session.Attachments A mapping of files that have been attached to the session. configuration bandsaw.config.Configuration The configuration that is being used for advising this task. Source code in bandsaw/session.py class Session : \"\"\" Class that handles the advising of an execution. A `Session` object is given to the individual advices that are called to advise the execution. By calling the appropriate methods like `def proceed(self)` to continue or `conclude()` to end with a result, the advices can influence the final result. Additionally, the session provides access to the `context`, which allows advices to keep state, the `execution` that is advised, the `configuration` that is used for advising and the `result` of the execution. Attributes: task (bandsaw.tasks.Task): The task that is executed. execution (bandsaw.execution.Execution): The execution arguments for the task. context (bandsaw.context.Context): The context that can be used for advices to store state. result (bandsaw.result.Result): Result of the task if already computed. Otherwise, `None`. attachments (bandsaw.session.Attachments): A mapping of files that have been attached to the session. configuration (bandsaw.config.Configuration): The configuration that is being used for advising this task. \"\"\" # pylint: disable=too-many-instance-attributes # is reasonable in this case. def __init__ ( self , task = None , execution = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . execution = execution self . context = {} self . result = None self . attachments = Attachments () self . configuration = configuration self . _advice_chain = advice_chain self . _moderator = None self . _ids = None self . _temp_dir = None def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . configuration . extensions : extension . on_session_created ( self ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . configuration . extensions : extension . on_session_finished ( self ) return self . result @property def ids ( self ): \"\"\"The ids of this session.\"\"\" if self . _ids is None : if self . task is None or self . execution is None : raise ValueError ( \"Incomplete session, missing task or execution.\" ) self . _ids = Ids ( self . task . task_id , self . execution . execution_id , self . run_id , ) return self . _ids @property def session_id ( self ): \"\"\"The id of this session as string.\"\"\" return str ( self . ids ) @property def serializer ( self ): \"\"\"The serializer that can be used for serializing values.\"\"\" return self . configuration . serializer @property def distribution_archive ( self ): \"\"\"The DistributionArchive which can be used when transferring the session.\"\"\" return get_distribution_archive ( self . configuration ) @property def run_id ( self ): \"\"\"The run id of the workflow.\"\"\" return get_run_id () @property def temp_dir ( self ): \"\"\" Temporary directory where session specific files can be written to. This directory is meant for storing temporary files, that are used by the individual `Advice` instances. The directory is already created and will be automatically deleted with the end of the python interpreter, nonetheless, the advices writing files to the directory should if possible take care of removing them if no longer needed. Returns: pathlib.Path: Path to the temporary directory. \"\"\" if self . _temp_dir is None : self . _temp_dir = self . configuration . temporary_directory / self . ids . as_path () self . _temp_dir . mkdir ( parents = True , exist_ok = True ) return self . _temp_dir def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self ) def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self ) def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream ) def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self def _load_from_zip ( self , stream ): # We don't use with here, because we don't want to close the zip file # This allows the attachment's container, to access the attachments from the # archive archive = zipfile . ZipFile ( stream , 'r' ) # pylint: disable=consider-using-with session_json = json . loads ( archive . read ( 'session.json' )) self . configuration = get_configuration ( session_json [ 'configuration' ]) self . _advice_chain = session_json [ 'advice_chain' ] self . _ids = Ids . from_string ( session_json [ 'ids' ]) serializer = self . configuration . serializer stream = io . BytesIO ( archive . read ( 'task.dat' )) self . task = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'execution.dat' )) self . execution = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'context.dat' )) self . context = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'result.dat' )) self . result = serializer . deserialize ( stream ) stream = io . BytesIO ( archive . read ( 'moderator.dat' )) self . _moderator = serializer . deserialize ( stream ) if self . _moderator is not None : self . _moderator . advice_chain = self . configuration . get_advice_chain ( self . _advice_chain ) self . attachments = Attachments ( archive ) def _store_as_zip ( self , stream ): serializer = self . configuration . serializer with zipfile . ZipFile ( stream , 'w' ) as archive : session_json = json . dumps ( { 'configuration' : self . configuration . module_name , 'advice_chain' : self . _advice_chain , 'ids' : str ( self . ids ), } ) archive . writestr ( 'session.json' , session_json ) stream = io . BytesIO () serializer . serialize ( self . task , stream ) archive . writestr ( 'task.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . execution , stream ) archive . writestr ( 'execution.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . context , stream ) archive . writestr ( 'context.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . result , stream ) archive . writestr ( 'result.dat' , stream . getvalue ()) stream = io . BytesIO () serializer . serialize ( self . _moderator , stream ) archive . writestr ( 'moderator.dat' , stream . getvalue ()) self . attachments . store ( archive )","title":"Session"},{"location":"api/#bandsaw.session.Session.distribution_archive","text":"The DistributionArchive which can be used when transferring the session.","title":"distribution_archive"},{"location":"api/#bandsaw.session.Session.ids","text":"The ids of this session.","title":"ids"},{"location":"api/#bandsaw.session.Session.run_id","text":"The run id of the workflow.","title":"run_id"},{"location":"api/#bandsaw.session.Session.serializer","text":"The serializer that can be used for serializing values.","title":"serializer"},{"location":"api/#bandsaw.session.Session.session_id","text":"The id of this session as string.","title":"session_id"},{"location":"api/#bandsaw.session.Session.temp_dir","text":"Temporary directory where session specific files can be written to. This directory is meant for storing temporary files, that are used by the individual Advice instances. The directory is already created and will be automatically deleted with the end of the python interpreter, nonetheless, the advices writing files to the directory should if possible take care of removing them if no longer needed. Returns: Type Description pathlib.Path Path to the temporary directory.","title":"temp_dir"},{"location":"api/#bandsaw.session.Session.__init__","text":"Create a new session. Source code in bandsaw/session.py def __init__ ( self , task = None , execution = None , configuration = None , advice_chain = 'default' , ): \"\"\" Create a new session. \"\"\" self . task = task self . execution = execution self . context = {} self . result = None self . attachments = Attachments () self . configuration = configuration self . _advice_chain = advice_chain self . _moderator = None self . _ids = None self . _temp_dir = None","title":"__init__()"},{"location":"api/#bandsaw.session.Session.conclude","text":"Conclude the process of advising with a Result . This can be used in two cases: Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given result will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there after(session) method. Concluding AFTER the task was actually executed. This will just change the result of the session and continue will all following advices. Parameters: Name Type Description Default result bandsaw.result.Result The result to conclude with. required Source code in bandsaw/session.py def conclude ( self , result ): \"\"\" Conclude the process of advising with a `Result`. This can be used in two cases: 1. Concluding BEFORE the task was actually executed. This will skip all subsequent advices defined later in the advice chain and will skip the task execution. The given `result` will then be used as preliminary result. All advices that are defined before the calling advice in the advice chain will still be called with there `after(session)` method. 2. Concluding AFTER the task was actually executed. This will just change the `result` of the session and continue will all following advices. Args: result (bandsaw.result.Result): The result to conclude with. \"\"\" self . result = result self . _moderator . skip ( self )","title":"conclude()"},{"location":"api/#bandsaw.session.Session.initiate","text":"Start the process of advising an execution. Returns: Type Description bandsaw.result.Result The final result of the execution after all advices. Source code in bandsaw/session.py def initiate ( self ): \"\"\" Start the process of advising an execution. Returns: bandsaw.result.Result: The final result of the execution after all advices. \"\"\" self . _moderator = _Moderator ( self . configuration . get_advice_chain ( self . _advice_chain ) ) logger . debug ( \"running extensions before advice\" ) for extension in self . configuration . extensions : extension . on_session_created ( self ) self . proceed () if not self . _moderator . is_finished : raise RuntimeError ( f \"Not all advice has been applied. \" f \"Misbehaving advice { self . _moderator . current_advice } \" ) logger . debug ( \"running extensions after advice\" ) for extension in self . configuration . extensions : extension . on_session_finished ( self ) return self . result","title":"initiate()"},{"location":"api/#bandsaw.session.Session.proceed","text":"Continue the process of advising with the next advice. Source code in bandsaw/session.py def proceed ( self ): \"\"\" Continue the process of advising with the next advice. \"\"\" self . _moderator . next ( self )","title":"proceed()"},{"location":"api/#bandsaw.session.Session.restore","text":"Resume a prior suspended session. Source code in bandsaw/session.py def restore ( self , stream ): \"\"\" Resume a prior suspended session. \"\"\" self . _load_from_zip ( stream ) return self","title":"restore()"},{"location":"api/#bandsaw.session.Session.save","text":"Suspend the session to be resumed later or elsewhere. Source code in bandsaw/session.py def save ( self , stream ): \"\"\" Suspend the session to be resumed later or elsewhere. \"\"\" self . _store_as_zip ( stream )","title":"save()"},{"location":"api/#bandsaw.tasks","text":"Contains classes and functions representing different types of tasks","title":"tasks"},{"location":"api/#bandsaw.tasks.Task","text":"Base-class for different types of Tasks that can be executed Attributes: Name Type Description task_id str A unique identifier for the individual tasks. advice_parameters dict A dictionary with additional arguments provided at task definition. source str The python source code as string which defines the task. bytecode bytes The compiled byte code of the task definition. Source code in bandsaw/tasks.py class Task ( SerializableValue , abc . ABC ): \"\"\"Base-class for different types of `Tasks` that can be executed Attributes: task_id (str): A unique identifier for the individual tasks. advice_parameters (dict): A dictionary with additional arguments provided at task definition. source (str): The python source code as string which defines the task. bytecode (bytes): The compiled byte code of the task definition. \"\"\" # For different types of callable # https://stackoverflow.com/questions/19314405/how-to-detect-is-decorator-has-been-applied-to-method-or-function def __init__ ( self , task_id , advice_parameters ): self . task_id = task_id self . _advice_parameters = advice_parameters @property def advice_parameters ( self ): \"\"\"Additional parameters for advices defined at task definition.\"\"\" return dict ( self . _advice_parameters ) @property @abc . abstractmethod def source ( self ): \"\"\"The python source code as `str` which defines the task.\"\"\" @property @abc . abstractmethod def bytecode ( self ): \"\"\"The compiled byte code of the task definition as `bytes`.\"\"\" @property @abc . abstractmethod def signature ( self ): \"\"\"The signature() of the callable representing this task.\"\"\" @abc . abstractmethod def _execute ( self , args , kwargs ): \"\"\" Execute the task with the given arguments. Args: args: The positional arguments to use during execution. kwargs: The keyword arguments to use during execution. Returns: Any: The returned value from the task. Raises: Any: During the execution the task can raise arbitrary exceptions. \"\"\" def execute ( self , execution ): \"\"\" Execute the task with the arguments specified by the execution. Args: execution (bandsaw.execution.Execution): The definition which contains how the task should be executed. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( execution . args , execution . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result @classmethod def create_task ( cls , obj , advice_parameters = None ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. advice_parameters (dict): A dictionary containing additional arguments to be used by the advices. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if advice_parameters is None : advice_parameters = {} if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj , advice_parameters ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name , advice_parameters ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" )","title":"Task"},{"location":"api/#bandsaw.tasks.Task.advice_parameters","text":"Additional parameters for advices defined at task definition.","title":"advice_parameters"},{"location":"api/#bandsaw.tasks.Task.bytecode","text":"The compiled byte code of the task definition as bytes .","title":"bytecode"},{"location":"api/#bandsaw.tasks.Task.signature","text":"The signature() of the callable representing this task.","title":"signature"},{"location":"api/#bandsaw.tasks.Task.source","text":"The python source code as str which defines the task.","title":"source"},{"location":"api/#bandsaw.tasks.Task.create_task","text":"Factory for creating a task for different Python objects. Parameters: Name Type Description Default obj Any Python object that should be run as a task. required advice_parameters dict A dictionary containing additional arguments to be used by the advices. None Returns: Type Description bandsaw.tasks.Task Instance of Task class that allows to execute the task. Exceptions: Type Description TypeError If there is no support for this type of python object. Source code in bandsaw/tasks.py @classmethod def create_task ( cls , obj , advice_parameters = None ): \"\"\" Factory for creating a task for different Python objects. Args: obj (Any): Python object that should be run as a task. advice_parameters (dict): A dictionary containing additional arguments to be used by the advices. Returns: bandsaw.tasks.Task: Instance of `Task` class that allows to execute the task. Raises: TypeError: If there is no support for this type of python object. \"\"\" if advice_parameters is None : advice_parameters = {} if isinstance ( obj , types . FunctionType ): if '.<locals>.' in obj . __qualname__ : return _FunctionWithClosureTask ( obj , advice_parameters ) function_name , module_name = object_as_import ( obj ) return _FunctionTask ( function_name , module_name , advice_parameters ) raise TypeError ( f \"Unsupported task object of type { type ( obj ) } \" )","title":"create_task()"},{"location":"api/#bandsaw.tasks.Task.execute","text":"Execute the task with the arguments specified by the execution. Parameters: Name Type Description Default execution bandsaw.execution.Execution The definition which contains how the task should be executed. required Returns: Type Description bandsaw.result.Result A Result object with either the returned value from the task or an exception that was raised by the task. Source code in bandsaw/tasks.py def execute ( self , execution ): \"\"\" Execute the task with the arguments specified by the execution. Args: execution (bandsaw.execution.Execution): The definition which contains how the task should be executed. Returns: bandsaw.result.Result: A `Result` object with either the returned value from the task or an exception that was raised by the task. \"\"\" try : result_value = self . _execute ( execution . args , execution . kwargs ) result = Result ( value = result_value ) except Exception as error : # pylint: disable=W0703 # too general exception result = Result ( exception = error ) return result","title":"execute()"},{"location":"api/#bandsaw.tracking","text":"","title":"tracking"},{"location":"api/#bandsaw.tracking.backend","text":"Interface for tracking backends","title":"backend"},{"location":"api/#bandsaw.tracking.backend.Backend","text":"Base class for backend implementations Source code in bandsaw/tracking/backend.py class Backend : \"\"\"Base class for backend implementations\"\"\" def track_run ( self , ids , run_info ): \"\"\" Track a run Args: ids (bandsaw.session.Ids): Ids where the run was first used. run_info (Dict[str,Any]): A dictionary containing tracking information for this run. \"\"\" def track_distribution_archive ( self , distribution_archive ): \"\"\" Track a distribution archive. Args: distribution_archive (bandsaw.distribution.DistributionArchive): The archive which should be tracked. \"\"\" def track_task ( self , ids , task_info ): \"\"\" Track a task. Args: ids (bandsaw.session.Ids): Ids where task was first used. task_info (Dict[str,Any]): A dictionary containing tracking information for a task. \"\"\" def track_execution ( self , ids , execution_info ): \"\"\" Track an execution. Args: ids (bandsaw.session.Ids): Ids where task was first used. execution_info (Dict[str,Any]): A dictionary containing tracking information for the execution. \"\"\" def track_session ( self , ids , session_info ): \"\"\" Track a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. session_info (Dict[str,Any]): A dictionary containing tracking information for this session. \"\"\" def track_result ( self , ids , result_info ): \"\"\" Track the result of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. result_info (Dict[str,Any]): A dictionary containing tracking information for this result. \"\"\" def track_attachments ( self , ids , attachments ): \"\"\" Track the attachments of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. attachments (bandsaw.session.Attachments): An instance of `Attachments` which gives access to the files that were attached to a session. \"\"\"","title":"Backend"},{"location":"api/#bandsaw.tracking.backend.Backend.track_attachments","text":"Track the attachments of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required attachments bandsaw.session.Attachments An instance of Attachments which gives access to the files that were attached to a session. required Source code in bandsaw/tracking/backend.py def track_attachments ( self , ids , attachments ): \"\"\" Track the attachments of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. attachments (bandsaw.session.Attachments): An instance of `Attachments` which gives access to the files that were attached to a session. \"\"\"","title":"track_attachments()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_distribution_archive","text":"Track a distribution archive. Parameters: Name Type Description Default distribution_archive bandsaw.distribution.DistributionArchive The archive which should be tracked. required Source code in bandsaw/tracking/backend.py def track_distribution_archive ( self , distribution_archive ): \"\"\" Track a distribution archive. Args: distribution_archive (bandsaw.distribution.DistributionArchive): The archive which should be tracked. \"\"\"","title":"track_distribution_archive()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_execution","text":"Track an execution. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required execution_info Dict[str,Any] A dictionary containing tracking information for the execution. required Source code in bandsaw/tracking/backend.py def track_execution ( self , ids , execution_info ): \"\"\" Track an execution. Args: ids (bandsaw.session.Ids): Ids where task was first used. execution_info (Dict[str,Any]): A dictionary containing tracking information for the execution. \"\"\"","title":"track_execution()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_result","text":"Track the result of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required result_info Dict[str,Any] A dictionary containing tracking information for this result. required Source code in bandsaw/tracking/backend.py def track_result ( self , ids , result_info ): \"\"\" Track the result of a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. result_info (Dict[str,Any]): A dictionary containing tracking information for this result. \"\"\"","title":"track_result()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_run","text":"Track a run Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where the run was first used. required run_info Dict[str,Any] A dictionary containing tracking information for this run. required Source code in bandsaw/tracking/backend.py def track_run ( self , ids , run_info ): \"\"\" Track a run Args: ids (bandsaw.session.Ids): Ids where the run was first used. run_info (Dict[str,Any]): A dictionary containing tracking information for this run. \"\"\"","title":"track_run()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_session","text":"Track a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required session_info Dict[str,Any] A dictionary containing tracking information for this session. required Source code in bandsaw/tracking/backend.py def track_session ( self , ids , session_info ): \"\"\" Track a session. Args: ids (bandsaw.session.Ids): Ids where task was first used. session_info (Dict[str,Any]): A dictionary containing tracking information for this session. \"\"\"","title":"track_session()"},{"location":"api/#bandsaw.tracking.backend.Backend.track_task","text":"Track a task. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required task_info Dict[str,Any] A dictionary containing tracking information for a task. required Source code in bandsaw/tracking/backend.py def track_task ( self , ids , task_info ): \"\"\" Track a task. Args: ids (bandsaw.session.Ids): Ids where task was first used. task_info (Dict[str,Any]): A dictionary containing tracking information for a task. \"\"\"","title":"track_task()"},{"location":"api/#bandsaw.tracking.filesystem","text":"Tracking backend using filesystem","title":"filesystem"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend","text":"Tracking backend that stores data in the local file system. Source code in bandsaw/tracking/filesystem.py class FileSystemBackend ( Backend ): \"\"\"Tracking backend that stores data in the local file system.\"\"\" def __init__ ( self , directory ): \"\"\" Create a new backend. Args: directory (str): Directory where the tracking data will be stored. \"\"\" self . directory = pathlib . Path ( directory ) logger . info ( \"Tracking sessions in directory ' %s '\" , self . directory ) super () . __init__ () def track_run ( self , ids , run_info ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True ) run_info_path = run_dir / 'run-info.json' with run_info_path . open ( 'w' ) as stream : json . dump ( run_info , stream ) def track_task ( self , ids , task_info ): task_dir = self . directory / 'tasks' / ids . task_id task_dir . mkdir ( parents = True , exist_ok = True ) task_info_path = task_dir / 'task-info.json' with task_info_path . open ( 'w' ) as stream : json . dump ( task_info , stream ) def track_execution ( self , ids , execution_info ): execution_dir = self . directory / 'tasks' / ids . task_id / ids . execution_id execution_dir . mkdir ( parents = True , exist_ok = True ) execution_info_path = execution_dir / 'execution-info.json' with execution_info_path . open ( 'w' ) as stream : json . dump ( execution_info , stream ) def track_session ( self , ids , session_info ): self . _store_session_info ( ids , session_info ) self . _store_session_for_run ( ids ) def track_result ( self , ids , result_info ): self . _store_session_result ( ids , result_info ) def track_attachments ( self , ids , attachments ): self . _store_session_attachments ( ids , attachments ) def _store_session_for_run ( self , ids ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True , exist_ok = True ) run_session_file = run_dir / str ( ids ) run_session_file . touch () def _store_session_info ( self , ids , session_info ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) session_dir . mkdir ( parents = True , exist_ok = True ) session_info_file = session_dir / 'session-info.json' with session_info_file . open ( 'w' ) as stream : json . dump ( session_info , stream ) def _store_session_result ( self , ids , result_info ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) session_dir . mkdir ( parents = True , exist_ok = True ) session_info_file = session_dir / 'result-info.json' with session_info_file . open ( 'w' ) as stream : json . dump ( result_info , stream ) def _store_session_attachments ( self , ids , attachments ): session_dir = ( self . directory / 'tasks' / ids . task_id / ids . execution_id / ids . run_id ) attachments_dir = session_dir / 'attachments' attachments_dir . mkdir ( parents = True ) for name , attachment in attachments . items (): attachment_path = attachments_dir / name with attachment . open () as input_stream : with attachment_path . open ( 'wb' ) as output_stream : shutil . copyfileobj ( input_stream , output_stream )","title":"FileSystemBackend"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.__init__","text":"Create a new backend. Parameters: Name Type Description Default directory str Directory where the tracking data will be stored. required Source code in bandsaw/tracking/filesystem.py def __init__ ( self , directory ): \"\"\" Create a new backend. Args: directory (str): Directory where the tracking data will be stored. \"\"\" self . directory = pathlib . Path ( directory ) logger . info ( \"Tracking sessions in directory ' %s '\" , self . directory ) super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_attachments","text":"Track the attachments of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required attachments bandsaw.session.Attachments An instance of Attachments which gives access to the files that were attached to a session. required Source code in bandsaw/tracking/filesystem.py def track_attachments ( self , ids , attachments ): self . _store_session_attachments ( ids , attachments )","title":"track_attachments()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_execution","text":"Track an execution. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required execution_info Dict[str,Any] A dictionary containing tracking information for the execution. required Source code in bandsaw/tracking/filesystem.py def track_execution ( self , ids , execution_info ): execution_dir = self . directory / 'tasks' / ids . task_id / ids . execution_id execution_dir . mkdir ( parents = True , exist_ok = True ) execution_info_path = execution_dir / 'execution-info.json' with execution_info_path . open ( 'w' ) as stream : json . dump ( execution_info , stream )","title":"track_execution()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_result","text":"Track the result of a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required result_info Dict[str,Any] A dictionary containing tracking information for this result. required Source code in bandsaw/tracking/filesystem.py def track_result ( self , ids , result_info ): self . _store_session_result ( ids , result_info )","title":"track_result()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_run","text":"Track a run Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where the run was first used. required run_info Dict[str,Any] A dictionary containing tracking information for this run. required Source code in bandsaw/tracking/filesystem.py def track_run ( self , ids , run_info ): run_dir = self . directory / 'runs' / ids . run_id run_dir . mkdir ( parents = True ) run_info_path = run_dir / 'run-info.json' with run_info_path . open ( 'w' ) as stream : json . dump ( run_info , stream )","title":"track_run()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_session","text":"Track a session. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required session_info Dict[str,Any] A dictionary containing tracking information for this session. required Source code in bandsaw/tracking/filesystem.py def track_session ( self , ids , session_info ): self . _store_session_info ( ids , session_info ) self . _store_session_for_run ( ids )","title":"track_session()"},{"location":"api/#bandsaw.tracking.filesystem.FileSystemBackend.track_task","text":"Track a task. Parameters: Name Type Description Default ids bandsaw.session.Ids Ids where task was first used. required task_info Dict[str,Any] A dictionary containing tracking information for a task. required Source code in bandsaw/tracking/filesystem.py def track_task ( self , ids , task_info ): task_dir = self . directory / 'tasks' / ids . task_id task_dir . mkdir ( parents = True , exist_ok = True ) task_info_path = task_dir / 'task-info.json' with task_info_path . open ( 'w' ) as stream : json . dump ( task_info , stream )","title":"track_task()"},{"location":"api/#bandsaw.tracking.tracker","text":"Contains Advice that tracks task executions in a local file system.","title":"tracker"},{"location":"api/#bandsaw.tracking.tracker.TrackerExtension","text":"Advice that tracks task executions and their data in the file system. Attributes: Name Type Description _backend bandsaw.tracking.backend.Backend The backend implementation to use. Source code in bandsaw/tracking/tracker.py class TrackerExtension ( Extension ): \"\"\" Advice that tracks task executions and their data in the file system. Attributes: _backend (bandsaw.tracking.backend.Backend): The backend implementation to use. \"\"\" def __init__ ( self , backend ): \"\"\" Advice that tracks task executions and their data in the file system. Args: backend (bandsaw.tracking.backend.Backend): The backend implementation to use. Raises: TypeError: If `backend` does not inherit from `Backend` base class. ValueError: If no backend is given. \"\"\" if backend is None : raise ValueError ( \"Backend must be set.\" ) if not isinstance ( backend , Backend ): raise TypeError ( \"`backend` is not of type `Backend`.\" ) self . _backend = backend logger . info ( \"Tracking sessions using backend ' %s '\" , self . _backend ) self . _tracked_runs = set () self . _tracked_tasks = set () self . _tracked_executions = set () self . _tracked_sessions = set () self . _tracked_results = set () self . _tracked_attachments = set () super () . __init__ () def on_session_created ( self , session ): self . _track_run ( session ) self . _track_task ( session ) self . _track_execution ( session ) self . _track_session ( session ) def on_session_finished ( self , session ): self . _track_result ( session ) self . _track_attachments ( session ) def _track_run ( self , session ): if session . run_id not in self . _tracked_runs : self . _backend . track_run ( session . ids , { 'id' : session . run_id }) self . _tracked_runs . add ( session . run_id ) def _track_task ( self , session ): if session . task . task_id not in self . _tracked_tasks : self . _backend . track_task ( session . ids , self . _create_task_info ( session )) self . _tracked_tasks . add ( session . task . task_id ) def _track_execution ( self , session ): combined_id = session . task . task_id + '_' + session . execution . execution_id if combined_id not in self . _tracked_executions : self . _backend . track_execution ( session . ids , self . _create_execution_info ( session ) ) self . _tracked_executions . add ( combined_id ) def _track_session ( self , session ): if session . session_id not in self . _tracked_sessions : self . _backend . track_session ( session . ids , self . _create_session_info ( session )) self . _tracked_sessions . add ( session . session_id ) def _track_result ( self , session ): if session . session_id not in self . _tracked_results : self . _backend . track_result ( session . ids , self . _create_result_info ( session )) self . _tracked_results . add ( session . session_id ) def _track_attachments ( self , session ): if session . session_id not in self . _tracked_attachments : self . _backend . track_attachments ( session . ids , session . attachments ) self . _tracked_attachments . add ( session . session_id ) @staticmethod def _create_run_info ( session ): run_info = { 'run' : { 'id' : session . run_id , }, 'configuration' : session . configuration . module_name , 'distribution_archive' : { 'modules' : session . distribution_archive . modules , 'id' : None , # session.distribution_archive.archive_id, }, } return run_info @staticmethod def _create_task_info ( session ): task_info = { 'task' : { 'id' : session . task . task_id , 'definition' : str ( session . task ), 'advice_parameters' : session . task . advice_parameters , }, } return task_info def _create_execution_info ( self , session ): def _argument_infos ( task , execution ): \"\"\" The names of the positional and keyword arguments for this task. Returns: tuple[List[str],Set[str]]: Tuple containing a list with the names of the positional arguments and a set with the names of the keyword arguments. \"\"\" signature = task . signature bound_args = signature . bind ( * execution . args , ** execution . kwargs ) bound_args . apply_defaults () all_infos = [] for name , value in bound_args . arguments . items (): info = value_info ( value ) info [ 'name' ] = name all_infos . append ( info ) return all_infos execution_info = self . _create_task_info ( session ) execution_info [ 'execution' ] = { 'id' : session . execution . execution_id , 'arguments' : _argument_infos ( session . task , session . execution ), } return execution_info def _create_session_info ( self , session ): tracking_info = self . _create_execution_info ( session ) tracking_info . update ( self . _create_run_info ( session )) tracking_info . update ( { 'session' : { 'id' : str ( session . session_id ), }, 'task' : { 'id' : session . task . task_id , 'definition' : str ( session . task ), 'advice_parameters' : session . task . advice_parameters , }, } ) return tracking_info def _create_result_info ( self , session ): def _result_value_infos ( result_value ): \"\"\" The names of the positional and keyword arguments for this task. Returns: tuple[List[str],Set[str]]: Tuple containing a list with the names of the positional arguments and a set with the names of the keyword arguments. \"\"\" result_value_infos = [] if isinstance ( result_value , dict ): for name , value in result_value . items (): info = value_info ( value ) info [ 'key' ] = name result_value_infos . append ( info ) elif isinstance ( result_value , list ): for index , value in enumerate ( result_value ): info = value_info ( value ) info [ 'index' ] = index result_value_infos . append ( info ) else : info = value_info ( result_value ) result_value_infos = info return result_value_infos result = session . result result_info = self . _create_session_info ( session ) result_info [ 'result' ] = {} if result . exception : result_info [ 'result' ][ 'exception' ] = type ( result . exception ) . __name__ result_info [ 'result' ][ 'message' ] = str ( result . exception ) else : result_info [ 'result' ][ 'value' ] = _result_value_infos ( result . value ) return result_info","title":"TrackerExtension"},{"location":"api/#bandsaw.tracking.tracker.TrackerExtension.__init__","text":"Advice that tracks task executions and their data in the file system. Parameters: Name Type Description Default backend bandsaw.tracking.backend.Backend The backend implementation to use. required Exceptions: Type Description TypeError If backend does not inherit from Backend base class. ValueError If no backend is given. Source code in bandsaw/tracking/tracker.py def __init__ ( self , backend ): \"\"\" Advice that tracks task executions and their data in the file system. Args: backend (bandsaw.tracking.backend.Backend): The backend implementation to use. Raises: TypeError: If `backend` does not inherit from `Backend` base class. ValueError: If no backend is given. \"\"\" if backend is None : raise ValueError ( \"Backend must be set.\" ) if not isinstance ( backend , Backend ): raise TypeError ( \"`backend` is not of type `Backend`.\" ) self . _backend = backend logger . info ( \"Tracking sessions using backend ' %s '\" , self . _backend ) self . _tracked_runs = set () self . _tracked_tasks = set () self . _tracked_executions = set () self . _tracked_sessions = set () self . _tracked_results = set () self . _tracked_attachments = set () super () . __init__ ()","title":"__init__()"},{"location":"api/#bandsaw.tracking.tracker.TrackerExtension.on_session_created","text":"Called before bandsaw advises a task. This is called before any advice is applied. Parameters: Name Type Description Default session bandsaw.session.Session The new session. required Source code in bandsaw/tracking/tracker.py def on_session_created ( self , session ): self . _track_run ( session ) self . _track_task ( session ) self . _track_execution ( session ) self . _track_session ( session )","title":"on_session_created()"},{"location":"api/#bandsaw.tracking.tracker.TrackerExtension.on_session_finished","text":"Called after bandsaw advised a task. This is called after all advices have been applied and the final result is available. Parameters: Name Type Description Default session bandsaw.session.Session The session. required Source code in bandsaw/tracking/tracker.py def on_session_finished ( self , session ): self . _track_result ( session ) self . _track_attachments ( session )","title":"on_session_finished()"},{"location":"api/#bandsaw.user","text":"Contains functions related to users","title":"user"},{"location":"api/#bandsaw.user.get_current_username","text":"Returns the name of the user which is currently running the python process. Returns: Type Description str The name of the user on the local system. Source code in bandsaw/user.py def get_current_username (): \"\"\" Returns the name of the user which is currently running the python process. Returns: str: The name of the user on the local system. \"\"\" return pwd . getpwuid ( os . getuid ())[ 0 ]","title":"get_current_username()"},{"location":"changelog/","text":"Changelog \ud83d\udd17 0.3: Tracking, metrics and logging \ud83d\udd17 New TrackerExtension to keep track of workflow runs, executions of tasks, their results and attached files. Add new MetricsAdvice that gathers metrics when executing tasks Support for file attachments on a session LoggingAdvice adds per-session log file as attachment JsonFormatter for storing log items in a structured format new session id to uniquely identify sessions Fix: Specifying advice chain in @task decorator was broken 0.2: Remote execution of tasks \ud83d\udd17 Distribute task executions to remote machines via SSH Renamed \"Run\" which contains arguments for executing a task to \"Execution\" Ability to parameterize task to be used by advices Introduce run id as unique identifier for individual workflow runs 0.1: Initial release of the package. \ud83d\udd17 Support for free functions as tasks Ability to run tasks in subprocesses Ability to execute tasks with different python interpreters Simple file system cache for caching task results","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#03-tracking-metrics-and-logging","text":"New TrackerExtension to keep track of workflow runs, executions of tasks, their results and attached files. Add new MetricsAdvice that gathers metrics when executing tasks Support for file attachments on a session LoggingAdvice adds per-session log file as attachment JsonFormatter for storing log items in a structured format new session id to uniquely identify sessions Fix: Specifying advice chain in @task decorator was broken","title":"0.3: Tracking, metrics and logging"},{"location":"changelog/#02-remote-execution-of-tasks","text":"Distribute task executions to remote machines via SSH Renamed \"Run\" which contains arguments for executing a task to \"Execution\" Ability to parameterize task to be used by advices Introduce run id as unique identifier for individual workflow runs","title":"0.2: Remote execution of tasks"},{"location":"changelog/#01-initial-release-of-the-package","text":"Support for free functions as tasks Ability to run tasks in subprocesses Ability to execute tasks with different python interpreters Simple file system cache for caching task results","title":"0.1: Initial release of the package."},{"location":"faq/","text":"FAQ \ud83d\udd17 Why do I have to configure bandsaw in a separate module? \ud83d\udd17 Since bandsaw can be integrated in arbitrary python scripts, we need to make sure that as soon as the bandsaw.task decorator is used first time, it is properly configured. By using a separate module, that bandsaw can import as needed, the library doesn't depend on the user setting the configuration upfront.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-do-i-have-to-configure-bandsaw-in-a-separate-module","text":"Since bandsaw can be integrated in arbitrary python scripts, we need to make sure that as soon as the bandsaw.task decorator is used first time, it is properly configured. By using a separate module, that bandsaw can import as needed, the library doesn't depend on the user setting the configuration upfront.","title":"Why do I have to configure bandsaw in a separate module?"},{"location":"getting_started/","text":"Getting started \ud83d\udd17 Install the library \ud83d\udd17 Install the latest version from PyPI using pip: pip install bandsaw Define the individual tasks of your workflow \ud83d\udd17 Import the @task decorator from the bandsaw package and decorate a function with it: import bandsaw ... @bandsaw . task def my_function ( x ): ... return x Configure bandsaw \ud83d\udd17 Create a new python module bandsaw_config and add first advice that just adds some additional logging when a task is executed: import bandsaw configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . log . LoggingAdvice (), ) Run your workflow \ud83d\udd17 When you now run your workflow, bandsaw intercepts the execution of my_function and its LoggingAdvice prints out additional log messages before() and after() it, e.g.: $ python my_script.py ... 2021 -10-27 13 :13:51,940 2290 bandsaw.advices.log INFO: BEFORE 0d268ac0..4213:76560cb4..a37d with context {} ... 2021 -10-27 13 :13:52,127 2290 bandsaw.advices.log INFO: AFTER 0d268ac0..4213:76560cb4..a37d with context {} ... The log messages contain the task_id (0d268ac0..4213), which is derived from the code that is decorated, and the run_id (76560cb4..a37d), derived from the arguments that my_function was called with. Where to go from here? \ud83d\udd17 Read the user guide for some more in-depth explanation about bandsaw and its concepts. Alternatively, bandsaw brings with it a couple of useful advice classes, that can be used just by adding them to its configuration: Running tasks in a subprocess or with a different python interpreter: bandsaw.advices.subprocess.SubprocessAdvice Caching the result of a task: bandsaw.advices.cache.CachingAdvice Running tasks on a different machine using SSH: bandsaw.advices.remote.SshAdvice Capturing the resource usage of a task: bandsaw.advices.metrics.MetricsAdvice Running tasks on asynchronously (Coming soon): bandsaw.advices.async.AsyncAdvice Creating your own advice: How to write your own advice?","title":"Getting started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#install-the-library","text":"Install the latest version from PyPI using pip: pip install bandsaw","title":"Install the library"},{"location":"getting_started/#define-the-individual-tasks-of-your-workflow","text":"Import the @task decorator from the bandsaw package and decorate a function with it: import bandsaw ... @bandsaw . task def my_function ( x ): ... return x","title":"Define the individual tasks of your workflow"},{"location":"getting_started/#configure-bandsaw","text":"Create a new python module bandsaw_config and add first advice that just adds some additional logging when a task is executed: import bandsaw configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . log . LoggingAdvice (), )","title":"Configure bandsaw"},{"location":"getting_started/#run-your-workflow","text":"When you now run your workflow, bandsaw intercepts the execution of my_function and its LoggingAdvice prints out additional log messages before() and after() it, e.g.: $ python my_script.py ... 2021 -10-27 13 :13:51,940 2290 bandsaw.advices.log INFO: BEFORE 0d268ac0..4213:76560cb4..a37d with context {} ... 2021 -10-27 13 :13:52,127 2290 bandsaw.advices.log INFO: AFTER 0d268ac0..4213:76560cb4..a37d with context {} ... The log messages contain the task_id (0d268ac0..4213), which is derived from the code that is decorated, and the run_id (76560cb4..a37d), derived from the arguments that my_function was called with.","title":"Run your workflow"},{"location":"getting_started/#where-to-go-from-here","text":"Read the user guide for some more in-depth explanation about bandsaw and its concepts. Alternatively, bandsaw brings with it a couple of useful advice classes, that can be used just by adding them to its configuration: Running tasks in a subprocess or with a different python interpreter: bandsaw.advices.subprocess.SubprocessAdvice Caching the result of a task: bandsaw.advices.cache.CachingAdvice Running tasks on a different machine using SSH: bandsaw.advices.remote.SshAdvice Capturing the resource usage of a task: bandsaw.advices.metrics.MetricsAdvice Running tasks on asynchronously (Coming soon): bandsaw.advices.async.AsyncAdvice Creating your own advice: How to write your own advice?","title":"Where to go from here?"},{"location":"user_guide/","text":"User guide \ud83d\udd17 This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the bandsaw library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own advices or extensions. Concepts \ud83d\udd17 First we start with some high-level concepts that we use throughout the library. The purpose of this sections is to explain the structure of bandsaw and introduce a common set of terms that helps to talk about the underlying ideas Workflow \ud83d\udd17 The fundamental basis in bandsaw is the idea of a workflow. We think of a workflow as a single python script, that contains code for all individual steps that are performed in a defined sequence. The individual steps can have dependencies on external inputs and on results of other steps, so that they form a directed acyclic graph. Those steps are referred to as Tasks within bandsaw. Every single run of a workflow is assigned a unique identifier, called a \"run id\". Tasks \ud83d\udd17 Tasks are pieces of code, that are used to process data. Task instances can be created by calling the create_task(cls, obj) class function in the Task class. At the moment, bandsaw supports only free functions defined on module level as tasks. Usually, tasks are defined by adding the @bandsaw.task decorator to the code that should be executed as a task. @bandsaw . task def my_function ( x ): return x Each task has a unique task_id that is derived from the code that is executed. This can be used to differentiate between different tasks. Task can be given additional advice parameters, that influence how they are executed. These advice parameters can be given as keyword arguments to the decorator: @bandsaw . task ( my = 'argument' ) def my_function ( x ): return x Executions \ud83d\udd17 Tasks can take arbitrary arguments, which means we can have multiple executions of the same task, that differ in the given arguments. This is captured by a Execution object, which encapsulates the arguments for a specific task execution. Similar to the task_id , each execution has a separate execution_id that differentiates between different executions based on their arguments. Advice \ud83d\udd17 Objects that implement the Advice protocol are the mechanism that allows bandsaw to influence the execution of the task. Each advice class can implement two different methods, before(self, session) and after(self, session) . The before() method is called before the task is actually executed and allows the advice to make changes to the way the task is executed, e.g. running the task on a different system or returning a result early without executing the task at all. The after() method is called after the task was actually executed and returned a result. This allows an advice to make changes to the result or use it in a different way than just returning it. Both methods decide on what happens after by calling the appropriate method on the current session , the sole argument both methods are taking. Session \ud83d\udd17 A Session is the object, that manages the process of executing a task for a specific execution. It defines the different actions that advices can take when their before() or after() methods are called. When a task is being called within a workflow, a new Session object is instantiated with the task, an execution object containing the tasks arguments and a list of advices, called the \"advice chain\", that should be used for advising the execution. Each session has a unique session_id that is derived from its task, the execution of the task and the current run_id . This makes sure, that the same task with the same arguments yields different session ids across multiple runs. before() executing a task. \ud83d\udd17 The session calls the before() methods of all advices one after another in the order that the advices are defined in the advice chain. Each Advice has to tell the session to either continue with the next advice by calling session.proceed() or return early by skipping the following advices AND the actual task execution by calling session.conclude(result) and providing a Result that should be used instead. After the advice has concluded with a result, the only advices whose after() methods will be called are the advices, that come before in the advice chain. Executing the task \ud83d\udd17 If all advices of the advice chain decided to proceed() , the session will execute that task and keep the value it returns. If an exception or error is raised during the execution it will be stored in the Result instance in the session. after() executing a task \ud83d\udd17 After the task has been executed, the session begins to call the after() methods of the advices in the REVERSED order from the advice chain. This means the advice that was called last for before() is called first for after() . Now each advice can decide how to continue. Similar to before() there are two possibilities: continue with the current result and the next advice by calling session.proceed() or return a different result and continue with that by calling session.conclude(result) with a different Result instance. All following advices will be called using after() with a session containing the new result. Once all advices have finished, the session will unpack the result and either return its value to the workflow or re-raise the error. Serializing the session \ud83d\udd17 In order to move the execution of a task across different python interpreters, an advice can use the capability of a Session to serialize its state to a stream and recreate it at a later point in time or on a different platform. For this the session contains two methods, save(stream) and restore(stream) . Both methods will (de-)serialize the complete session including context, task, execution and result. The only thing missing here are the objects from the advice chain, since bandsaw can't enforce them to be serializable. This means, that the same advice chain with the same name must be available from the configuration at the time, the session is restored. For an example, how transfer to a different python interpreter can be implemented, please look at the implementation of the SubprocessAdvice . Temporary directory \ud83d\udd17 Often advices need to create temporary files. To make sure, these temporary files are automatically cleaned up, once a session is finished, each session contains its own temporary directory in its temp_dir property. All files and directories created in this directory are automatically deleted when no longer needed. Attachments \ud83d\udd17 The session allows advices to store additional data with the result by using its attachments property, which contains an object of type 'Attachments' . Adding a new file as an attachment is done by assigning a file path to a new item whose name is the name of the attachment: >>> session . attachments [ 'my.attachment' ] = '/path/to/file' Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Adding a new attachment raises different exceptions in case of an error: KeyError if an attachment with the same name already exists. TypeError if the value that is assigned is neither a str or a pathlib.Path . ValueError if the assigned file path does not exist or isn't a file. Once an attachment has been assigned, it can be accessed like a normal item in a dict by its name as a key, but instead of a file path, an instance of type Attachment is returned. This type allows only read access to the data using its open() method: attachment = session . attachments [ 'my.attachment' ] print ( attachment . size ) with attachment . open () as stream : binary_data = stream . readall () Since Attachments implements abc.Mapping one can iterate over all attachments and test for the existence of a particular attachment using the in notation: for name , attachment in session . attachments . items (): print ( name ) with attachment . open () as stream : ... if 'my.attachment' in session . attachments : ... If a session is serialized, its attachments are automatically included. This requires that the attached files still exist at the time of the serialization. Since serialization of the session is often done by other advices than the ones that created the attachments, advices shouldn't remove files that they have added as an attachment. To make sure that these files are eventually cleaned up, they should be located within the session's temporary directory. Configuration \ud83d\udd17 Bandsaw needs configuration to know which advices to apply to the individual tasks. This configuration is given in form of an object of the bandsaw.config.Configuration class. Just creating a new Configuration object will create an empty, but working configuration, that actually does nothing and executes tasks without any changes. import bandsaw configuration = bandsaw . Configuration () The class has all the required methods to configure the different aspects of bandsaw. Advice chains \ud83d\udd17 An advice chain is a sequence of objects implementing the Advice protocol, that should be used for advising task executions. An advice chain is added to the configuration using the add_device_chain(*advices, name='default') method. It takes instances of Advice as positional arguments with an optional name keyword argument. ... configuration . add_device_chain ( bandsaw . advices . log . LoggingAdvice (), ) Each advice chain has a name, that can be used to choose which chain to use per task. If no name is given, the chain with name 'default' is configured. Already existing chains will be overwritten. So if you configure two different advice chains, with no or the same name, the latter will replace the former. Serializer \ud83d\udd17 In order to transfer tasks between different python interpreters, bandsaw needs the capability to serialize tasks, their arguments and internal classes. For this bandsaw defines a Serializer base class, that can be implemented to support different types of serialization. Which serializer to use, can be configured as part of the configuration: from bandsaw.serialization.json import JsonSerializer ... configuration . set_serializer ( JsonSerializer ()) Bandsaw comes with two different serialization formats: Pickle \ud83d\udd17 The PickleSerializer has the advantage, that it works out of the box with most standard python types. It uses the standard python pickle library to serialize python objects and should work across different python versions. If custom types need to be serialized (e.g. as part of some arguments to a task), that don't work with pickle, support for pickle can easily be added . One disadvantage of pickle is that sometimes the serialized representation of a value is not unique. Since bandsaw uses the serialized form of arguments to derive the execution_id of a execution, this can lead to inconsistencies, when the same arguments can lead to different execution_ids. Json \ud83d\udd17 The JsonSerializer uses JSON as format for the serialized data. The standard json library supports only primitive types like strings, dict, int etc. so for all complex types one need to explicitly add code to serialize them. Bandsaw implements support for serializing exceptions, tuples and all of its internal classes, so that they can be serialized to json. To serialize a custom type to json, bandsaw offers two options: Implement SerializableValue \ud83d\udd17 The easiest way to make your custom type json serializable is to inherit from the SerializableValue base class and implement the abstract methods serialized(self) and deserialize(cls, values) . serialized(self) must return a value that is json serializable (e.g. a dict containing only primitives). The class method deserialize(cls, values) is given this value and returns a new instance of the class. Create a ValueSerializer \ud83d\udd17 If the custom type can't be changed, there is the option to create a new ValueSerializer class that can serialize this type. It consists of 3 different methods: can_serialize_value(self, value) Has to return True if value is of the type that this particular serializer can serialize. serialize_value(self, value) Has to return the serialized representation of the type, consisting only of primitives that are json serializable. deserialize_value(self, representation) Has to return a new instance of custom_type from its serialized representation. Finally, the new ValueSerializer needs to be added to the json serializer as part of the configuration: configuration . serializer . value_serializers . append ( MyValueSerializer ()) How to use bandsaw \ud83d\udd17 Now with some knowledge about the different concepts within bandsaw at our hands, let's dive into the topic of how to put the library to good use. Install the library \ud83d\udd17 Use stable release from PyPI \ud83d\udd17 All stable versions of bandsaw are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install bandsaw Use from source \ud83d\udd17 Bandsaw's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/bandsaw.git $ cd bandsaw If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local bandsaw repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/bandsaw\" Defining the individual tasks of your workflow \ud83d\udd17 In order to use bandsaw in your workflow, you first have to import its package. import bandsaw ... Splitting up your workflow into individual tasks can be done by annotating the individual functions with the bandsaw.task decorator: @bandsaw . task def my_function ( x ): ... return x The decorator can be only applied to free functions in the current implementation, so it isn't possible to decorate methods of classes for now : class MyClass : @bandsaw . task def my_method ( self , x ): return x Configure bandsaw \ud83d\udd17 Bandsaw loads its configuration automatically at the time it is needed. This happens by dynamically importing a python module that contains an instance of the class Configuration assigned to the variable configuration . import bandsaw configuration = bandsaw . Configuration () Bandsaw expects the configuration to be found in the python module bandsaw_config . The name of the module can be changed in two ways: Set the BANDSAW_CONFIG environment variable to a different module name. Bandsaw reads the name of the module containing the configuration from this variable if it is set. So by setting it to e.g. my_config it will import my_config and take the configuration from it instead. Add an additional keyword argument to the @task decorator that contains the name of the configuration to use for this task: @bandsaw . task ( config = 'my_config_module' ) def my_function ( x ): ... return x By adding the config keyword argument we can choose the configuration we want to use per task. The existence of the configuration is checked as soon as the decorator is being applied. If no configuration could be loaded, an error is raised , usually at module import time. Choose the advice chain \ud83d\udd17 Each task can define, which advice chain should be used. This can be done, by adding a keyword argument chain to the task decorator: @bandsaw . task ( chain = 'my_chain' ) def my_function ( x ): ... return x If no chain exists with the specified name, a KeyError is raised . Executing the workflow \ud83d\udd17 Bandsaw doesn't depend on a special tool or script to execute the workflow, but is only added in form of a library. Therefore, the workflow script itself is executed like a normal python script: $ python my_workflow.py Extending bandsaw \ud83d\udd17 Bandsaw is extensible and allows developers to add new functionality in various ways: Implementing custom advices \ud83d\udd17 Advices are the main building blocks for adding new functionality. Implementing an advice is easy, the only necessary work is to adhere to a protocol and follow some simple rules. The protocol is defined in Advice and consists of two methods, before(self, session) and after(self, session) . Advices have to call the session. When called via before() and after() , the advice is responsible for telling the session how to continue. They must call once either session.proceed() or session.conclude() . Failure to do so, will lead to a RuntimeError raised by the session. Advices shouldn't keep state themselves. Advice instances are used for multiple tasks. Therefore, their implementation shouldn't store any task specific state themselves. If task specific state is necessary, it can be easily added to the context of the session. Advices may be instantiated multiple times and on different machines. Everytime a task is transferred to a different python interpreter, its configuration and with it the configured advices are instantiated again, even if they aren't actually called. Therefore, advices shouldn't do much work or interact with their environment at instantiation time, but only when they are actually called via after() or before() . Usually they can assume that both methods are called in the same environment for the same task.","title":"User guide"},{"location":"user_guide/#user-guide","text":"This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the bandsaw library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own advices or extensions.","title":"User guide"},{"location":"user_guide/#concepts","text":"First we start with some high-level concepts that we use throughout the library. The purpose of this sections is to explain the structure of bandsaw and introduce a common set of terms that helps to talk about the underlying ideas","title":"Concepts"},{"location":"user_guide/#workflow","text":"The fundamental basis in bandsaw is the idea of a workflow. We think of a workflow as a single python script, that contains code for all individual steps that are performed in a defined sequence. The individual steps can have dependencies on external inputs and on results of other steps, so that they form a directed acyclic graph. Those steps are referred to as Tasks within bandsaw. Every single run of a workflow is assigned a unique identifier, called a \"run id\".","title":"Workflow"},{"location":"user_guide/#tasks","text":"Tasks are pieces of code, that are used to process data. Task instances can be created by calling the create_task(cls, obj) class function in the Task class. At the moment, bandsaw supports only free functions defined on module level as tasks. Usually, tasks are defined by adding the @bandsaw.task decorator to the code that should be executed as a task. @bandsaw . task def my_function ( x ): return x Each task has a unique task_id that is derived from the code that is executed. This can be used to differentiate between different tasks. Task can be given additional advice parameters, that influence how they are executed. These advice parameters can be given as keyword arguments to the decorator: @bandsaw . task ( my = 'argument' ) def my_function ( x ): return x","title":"Tasks"},{"location":"user_guide/#executions","text":"Tasks can take arbitrary arguments, which means we can have multiple executions of the same task, that differ in the given arguments. This is captured by a Execution object, which encapsulates the arguments for a specific task execution. Similar to the task_id , each execution has a separate execution_id that differentiates between different executions based on their arguments.","title":"Executions"},{"location":"user_guide/#advice","text":"Objects that implement the Advice protocol are the mechanism that allows bandsaw to influence the execution of the task. Each advice class can implement two different methods, before(self, session) and after(self, session) . The before() method is called before the task is actually executed and allows the advice to make changes to the way the task is executed, e.g. running the task on a different system or returning a result early without executing the task at all. The after() method is called after the task was actually executed and returned a result. This allows an advice to make changes to the result or use it in a different way than just returning it. Both methods decide on what happens after by calling the appropriate method on the current session , the sole argument both methods are taking.","title":"Advice"},{"location":"user_guide/#session","text":"A Session is the object, that manages the process of executing a task for a specific execution. It defines the different actions that advices can take when their before() or after() methods are called. When a task is being called within a workflow, a new Session object is instantiated with the task, an execution object containing the tasks arguments and a list of advices, called the \"advice chain\", that should be used for advising the execution. Each session has a unique session_id that is derived from its task, the execution of the task and the current run_id . This makes sure, that the same task with the same arguments yields different session ids across multiple runs.","title":"Session"},{"location":"user_guide/#before-executing-a-task","text":"The session calls the before() methods of all advices one after another in the order that the advices are defined in the advice chain. Each Advice has to tell the session to either continue with the next advice by calling session.proceed() or return early by skipping the following advices AND the actual task execution by calling session.conclude(result) and providing a Result that should be used instead. After the advice has concluded with a result, the only advices whose after() methods will be called are the advices, that come before in the advice chain.","title":"before() executing a task."},{"location":"user_guide/#executing-the-task","text":"If all advices of the advice chain decided to proceed() , the session will execute that task and keep the value it returns. If an exception or error is raised during the execution it will be stored in the Result instance in the session.","title":"Executing the task"},{"location":"user_guide/#after-executing-a-task","text":"After the task has been executed, the session begins to call the after() methods of the advices in the REVERSED order from the advice chain. This means the advice that was called last for before() is called first for after() . Now each advice can decide how to continue. Similar to before() there are two possibilities: continue with the current result and the next advice by calling session.proceed() or return a different result and continue with that by calling session.conclude(result) with a different Result instance. All following advices will be called using after() with a session containing the new result. Once all advices have finished, the session will unpack the result and either return its value to the workflow or re-raise the error.","title":"after() executing a task"},{"location":"user_guide/#serializing-the-session","text":"In order to move the execution of a task across different python interpreters, an advice can use the capability of a Session to serialize its state to a stream and recreate it at a later point in time or on a different platform. For this the session contains two methods, save(stream) and restore(stream) . Both methods will (de-)serialize the complete session including context, task, execution and result. The only thing missing here are the objects from the advice chain, since bandsaw can't enforce them to be serializable. This means, that the same advice chain with the same name must be available from the configuration at the time, the session is restored. For an example, how transfer to a different python interpreter can be implemented, please look at the implementation of the SubprocessAdvice .","title":"Serializing the session"},{"location":"user_guide/#temporary-directory","text":"Often advices need to create temporary files. To make sure, these temporary files are automatically cleaned up, once a session is finished, each session contains its own temporary directory in its temp_dir property. All files and directories created in this directory are automatically deleted when no longer needed.","title":"Temporary directory"},{"location":"user_guide/#attachments","text":"The session allows advices to store additional data with the result by using its attachments property, which contains an object of type 'Attachments' . Adding a new file as an attachment is done by assigning a file path to a new item whose name is the name of the attachment: >>> session . attachments [ 'my.attachment' ] = '/path/to/file' Attachments can only be added, but neither deleted nor overwritten. Their names must be valid file names without directories. Adding a new attachment raises different exceptions in case of an error: KeyError if an attachment with the same name already exists. TypeError if the value that is assigned is neither a str or a pathlib.Path . ValueError if the assigned file path does not exist or isn't a file. Once an attachment has been assigned, it can be accessed like a normal item in a dict by its name as a key, but instead of a file path, an instance of type Attachment is returned. This type allows only read access to the data using its open() method: attachment = session . attachments [ 'my.attachment' ] print ( attachment . size ) with attachment . open () as stream : binary_data = stream . readall () Since Attachments implements abc.Mapping one can iterate over all attachments and test for the existence of a particular attachment using the in notation: for name , attachment in session . attachments . items (): print ( name ) with attachment . open () as stream : ... if 'my.attachment' in session . attachments : ... If a session is serialized, its attachments are automatically included. This requires that the attached files still exist at the time of the serialization. Since serialization of the session is often done by other advices than the ones that created the attachments, advices shouldn't remove files that they have added as an attachment. To make sure that these files are eventually cleaned up, they should be located within the session's temporary directory.","title":"Attachments"},{"location":"user_guide/#configuration","text":"Bandsaw needs configuration to know which advices to apply to the individual tasks. This configuration is given in form of an object of the bandsaw.config.Configuration class. Just creating a new Configuration object will create an empty, but working configuration, that actually does nothing and executes tasks without any changes. import bandsaw configuration = bandsaw . Configuration () The class has all the required methods to configure the different aspects of bandsaw.","title":"Configuration"},{"location":"user_guide/#advice-chains","text":"An advice chain is a sequence of objects implementing the Advice protocol, that should be used for advising task executions. An advice chain is added to the configuration using the add_device_chain(*advices, name='default') method. It takes instances of Advice as positional arguments with an optional name keyword argument. ... configuration . add_device_chain ( bandsaw . advices . log . LoggingAdvice (), ) Each advice chain has a name, that can be used to choose which chain to use per task. If no name is given, the chain with name 'default' is configured. Already existing chains will be overwritten. So if you configure two different advice chains, with no or the same name, the latter will replace the former.","title":"Advice chains"},{"location":"user_guide/#serializer","text":"In order to transfer tasks between different python interpreters, bandsaw needs the capability to serialize tasks, their arguments and internal classes. For this bandsaw defines a Serializer base class, that can be implemented to support different types of serialization. Which serializer to use, can be configured as part of the configuration: from bandsaw.serialization.json import JsonSerializer ... configuration . set_serializer ( JsonSerializer ()) Bandsaw comes with two different serialization formats:","title":"Serializer"},{"location":"user_guide/#pickle","text":"The PickleSerializer has the advantage, that it works out of the box with most standard python types. It uses the standard python pickle library to serialize python objects and should work across different python versions. If custom types need to be serialized (e.g. as part of some arguments to a task), that don't work with pickle, support for pickle can easily be added . One disadvantage of pickle is that sometimes the serialized representation of a value is not unique. Since bandsaw uses the serialized form of arguments to derive the execution_id of a execution, this can lead to inconsistencies, when the same arguments can lead to different execution_ids.","title":"Pickle"},{"location":"user_guide/#json","text":"The JsonSerializer uses JSON as format for the serialized data. The standard json library supports only primitive types like strings, dict, int etc. so for all complex types one need to explicitly add code to serialize them. Bandsaw implements support for serializing exceptions, tuples and all of its internal classes, so that they can be serialized to json. To serialize a custom type to json, bandsaw offers two options:","title":"Json"},{"location":"user_guide/#implement-serializablevalue","text":"The easiest way to make your custom type json serializable is to inherit from the SerializableValue base class and implement the abstract methods serialized(self) and deserialize(cls, values) . serialized(self) must return a value that is json serializable (e.g. a dict containing only primitives). The class method deserialize(cls, values) is given this value and returns a new instance of the class.","title":"Implement SerializableValue"},{"location":"user_guide/#create-a-valueserializer","text":"If the custom type can't be changed, there is the option to create a new ValueSerializer class that can serialize this type. It consists of 3 different methods: can_serialize_value(self, value) Has to return True if value is of the type that this particular serializer can serialize. serialize_value(self, value) Has to return the serialized representation of the type, consisting only of primitives that are json serializable. deserialize_value(self, representation) Has to return a new instance of custom_type from its serialized representation. Finally, the new ValueSerializer needs to be added to the json serializer as part of the configuration: configuration . serializer . value_serializers . append ( MyValueSerializer ())","title":"Create a ValueSerializer"},{"location":"user_guide/#how-to-use-bandsaw","text":"Now with some knowledge about the different concepts within bandsaw at our hands, let's dive into the topic of how to put the library to good use.","title":"How to use bandsaw"},{"location":"user_guide/#install-the-library","text":"","title":"Install the library"},{"location":"user_guide/#use-stable-release-from-pypi","text":"All stable versions of bandsaw are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install bandsaw","title":"Use stable release from PyPI"},{"location":"user_guide/#use-from-source","text":"Bandsaw's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/bandsaw.git $ cd bandsaw If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local bandsaw repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/bandsaw\"","title":"Use from source"},{"location":"user_guide/#defining-the-individual-tasks-of-your-workflow","text":"In order to use bandsaw in your workflow, you first have to import its package. import bandsaw ... Splitting up your workflow into individual tasks can be done by annotating the individual functions with the bandsaw.task decorator: @bandsaw . task def my_function ( x ): ... return x The decorator can be only applied to free functions in the current implementation, so it isn't possible to decorate methods of classes for now : class MyClass : @bandsaw . task def my_method ( self , x ): return x","title":"Defining the individual tasks of your workflow"},{"location":"user_guide/#configure-bandsaw","text":"Bandsaw loads its configuration automatically at the time it is needed. This happens by dynamically importing a python module that contains an instance of the class Configuration assigned to the variable configuration . import bandsaw configuration = bandsaw . Configuration () Bandsaw expects the configuration to be found in the python module bandsaw_config . The name of the module can be changed in two ways: Set the BANDSAW_CONFIG environment variable to a different module name. Bandsaw reads the name of the module containing the configuration from this variable if it is set. So by setting it to e.g. my_config it will import my_config and take the configuration from it instead. Add an additional keyword argument to the @task decorator that contains the name of the configuration to use for this task: @bandsaw . task ( config = 'my_config_module' ) def my_function ( x ): ... return x By adding the config keyword argument we can choose the configuration we want to use per task. The existence of the configuration is checked as soon as the decorator is being applied. If no configuration could be loaded, an error is raised , usually at module import time.","title":"Configure bandsaw"},{"location":"user_guide/#choose-the-advice-chain","text":"Each task can define, which advice chain should be used. This can be done, by adding a keyword argument chain to the task decorator: @bandsaw . task ( chain = 'my_chain' ) def my_function ( x ): ... return x If no chain exists with the specified name, a KeyError is raised .","title":"Choose the advice chain"},{"location":"user_guide/#executing-the-workflow","text":"Bandsaw doesn't depend on a special tool or script to execute the workflow, but is only added in form of a library. Therefore, the workflow script itself is executed like a normal python script: $ python my_workflow.py","title":"Executing the workflow"},{"location":"user_guide/#extending-bandsaw","text":"Bandsaw is extensible and allows developers to add new functionality in various ways:","title":"Extending bandsaw"},{"location":"user_guide/#implementing-custom-advices","text":"Advices are the main building blocks for adding new functionality. Implementing an advice is easy, the only necessary work is to adhere to a protocol and follow some simple rules. The protocol is defined in Advice and consists of two methods, before(self, session) and after(self, session) . Advices have to call the session. When called via before() and after() , the advice is responsible for telling the session how to continue. They must call once either session.proceed() or session.conclude() . Failure to do so, will lead to a RuntimeError raised by the session. Advices shouldn't keep state themselves. Advice instances are used for multiple tasks. Therefore, their implementation shouldn't store any task specific state themselves. If task specific state is necessary, it can be easily added to the context of the session. Advices may be instantiated multiple times and on different machines. Everytime a task is transferred to a different python interpreter, its configuration and with it the configured advices are instantiated again, even if they aren't actually called. Therefore, advices shouldn't do much work or interact with their environment at instantiation time, but only when they are actually called via after() or before() . Usually they can assume that both methods are called in the same environment for the same task.","title":"Implementing custom advices"},{"location":"advices/async/","text":"Running tasks asynchronously (Planned) \ud83d\udd17 This feature is currently not available but planned for the next future. The main use-case for this are processes that take a long time to compute. In this case, driving the process from the local machine and running the individual tasks synchronously would require the developer machine to stay online the whole time to communicate the results between the individual tasks and start the individual tasks as needed. In the asynchronous case, all tasks are scheduled before and an executor on the individual computation platforms takes care of running them as appropriate. The drawback of this is, that we don't have access to the actual results within the workflow that defines the process, but we only have futures that are passed between the individual tasks. This feature is planned to be available in Q1 of the year 2022.","title":"Async"},{"location":"advices/async/#running-tasks-asynchronously-planned","text":"This feature is currently not available but planned for the next future. The main use-case for this are processes that take a long time to compute. In this case, driving the process from the local machine and running the individual tasks synchronously would require the developer machine to stay online the whole time to communicate the results between the individual tasks and start the individual tasks as needed. In the asynchronous case, all tasks are scheduled before and an executor on the individual computation platforms takes care of running them as appropriate. The drawback of this is, that we don't have access to the actual results within the workflow that defines the process, but we only have futures that are passed between the individual tasks. This feature is planned to be available in Q1 of the year 2022.","title":"Running tasks asynchronously (Planned)"},{"location":"advices/caching/","text":"Caching task results in the file system \ud83d\udd17 The python module bandsaw.advices.cache contains the CachingAdvice class, which allows to store results of already calculated tasks in the file system so that they can be reused in later executions. Configuration \ud83d\udd17 directory (str) \ud83d\udd17 The directory, where the results will be stored. If the directory doesn't exist, it will be created the first time, a result is being stored. Example configuration \ud83d\udd17 import bandsaw.advices.cache configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . cache . CachingAdvice ( directory = '/my/cache/directory' , ) )","title":"Caching"},{"location":"advices/caching/#caching-task-results-in-the-file-system","text":"The python module bandsaw.advices.cache contains the CachingAdvice class, which allows to store results of already calculated tasks in the file system so that they can be reused in later executions.","title":"Caching task results in the file system"},{"location":"advices/caching/#configuration","text":"","title":"Configuration"},{"location":"advices/caching/#directory-str","text":"The directory, where the results will be stored. If the directory doesn't exist, it will be created the first time, a result is being stored.","title":"directory (str)"},{"location":"advices/caching/#example-configuration","text":"import bandsaw.advices.cache configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . cache . CachingAdvice ( directory = '/my/cache/directory' , ) )","title":"Example configuration"},{"location":"advices/logging/","text":"Keep logs of task executions \ud83d\udd17 The python module bandsaw.advices.log contains the LoggingAdvice class, which allows to keep the log output of task executions as attachment in a session. The advice adds an own Handler to the logging.root logger and stores log messages emitted during task execution in its own log file. The handler can use its own formatter and supports using a different logging level. The log messages are written into an attachment in the session with the name session.log . Configuration \ud83d\udd17 level (int) \ud83d\udd17 The level of the log messages, that should be kept. If not set or set to None , which messages are kept depends only on the configured level of the used loggers. formatter (logging.Formatter) \ud83d\udd17 The formatter to use for writing our the individual log messages. This defaults to an own bandsaw.advices.log.JsonFormatter that writes log messages as individual json objects (one per line), but custom formatter can be used as well. Example configuration \ud83d\udd17 import logging import bandsaw.advices.log configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . log . LoggingAdvice ( level = logging . INFO , ) ) JsonFormatter \ud83d\udd17 The JsonFormatter writes log messages as line-wise json that makes its easier to process the logs later-on without having to parse user-defined text formats. Description of the individual fields \ud83d\udd17 Field Type Optional Description timestamp string no Times are ISO-Format and always in UTC. logger string no The name of the logger that created the message. level string no The level of the message (usually INFO, DEBUG, WARN, ERROR, but can be custom). message string no The text content of the log message. threadId int no The ID of the thread where the message was emitted. threadName string no The name of the thread where the message was emitted. processId int no The process ID of the process which emitted the message. processName string no The name of the process which emitted the message. module string no The name of the module based on the filename. function string no Name of the function which emitted the log message. path string no Path to the python file where the message originated. line_no int no Number of the line where the log message was created. traceback string yes Stacktrace of the exception. (missing if no exception is logged) exception string yes String representation of the exception. (missing if no exception is logged) sessionId string yes (bandsaw specific) ID of the session in which the log message was created. runId string yes (bandsaw specific) ID of the run in which the log message was created. taskId string yes (bandsaw specific) ID of the task which was executed. executionId string yes (bandsaw specific) ID of the execution of the task. Example of normal log message \ud83d\udd17 { \"timestamp\" : \"2021-12-22T14:13:30.840811+00:00\" , \"logger\" : \"bandsaw.advices.metrics\" , \"level\" : \"INFO\" , \"message\" : \"Measurement id ea1a9e07d0c48896 with tags {'run_id': '55e85c2e-6331-11ec-8e2d-48f17f64520d', 'task_id': 'd24d5c98e4f63e66', 'execution_id': 'dd999d9ace267e13', 'session_id': 'ea1a9e07d0c48896'}\" , \"threadId\" : 140239061456704 , \"threadName\" : \"MainThread\" , \"processId\" : 16365 , \"processName\" : \"MainProcess\" , \"module\" : \"metrics\" , \"function\" : \"before\" , \"path\" : \"/home/bandsaw/dd999d9ace267e13/distribution-zy0tybls.pyz/bandsaw/advices/metrics.py\" , \"line_no\" : 50 , \"sessionId\" : \"ea1a9e07d0c48896\" , \"runId\" : \"55e85c2e-6331-11ec-8e2d-48f17f64520d\" , \"taskId\" : \"d24d5c98e4f63e66\" , \"executionId\" : \"dd999d9ace267e13\" } Example of log message with exception \ud83d\udd17 { \"timestamp\" : \"2021-12-22T14:18:31.821401+00:00\" , \"logger\" : \"my.logger\" , \"level\" : \"ERROR\" , \"message\" : \"Error greeting\" , \"threadId\" : 140626754463552 , \"threadName\" : \"MainThread\" , \"processId\" : 16632 , \"processName\" : \"MainProcess\" , \"module\" : \"demo\" , \"function\" : \"greet\" , \"path\" : \"/home/bandsaw/76560cb43662cc8f/distribution-f_say9mc.pyz/demo.py\" , \"line_no\" : 20 , \"traceback\" : \"File \\\"/home/bandsaw/76560cb43662cc8f/distribution-f_say9mc.pyz/demo.py\\\", line 18, in greet\\n raise ValueError(os.getpid())\" , \"exception\" : \"ValueError: 16632\" , \"sessionId\" : \"2573b136fd2b4f8e\" , \"runId\" : \"0939cef2-6332-11ec-8e2d-48f17f64520d\" , \"taskId\" : \"0d268ac06a82654e\" , \"executionId\" : \"76560cb43662cc8f\" }","title":"Loggging"},{"location":"advices/logging/#keep-logs-of-task-executions","text":"The python module bandsaw.advices.log contains the LoggingAdvice class, which allows to keep the log output of task executions as attachment in a session. The advice adds an own Handler to the logging.root logger and stores log messages emitted during task execution in its own log file. The handler can use its own formatter and supports using a different logging level. The log messages are written into an attachment in the session with the name session.log .","title":"Keep logs of task executions"},{"location":"advices/logging/#configuration","text":"","title":"Configuration"},{"location":"advices/logging/#level-int","text":"The level of the log messages, that should be kept. If not set or set to None , which messages are kept depends only on the configured level of the used loggers.","title":"level (int)"},{"location":"advices/logging/#formatter-loggingformatter","text":"The formatter to use for writing our the individual log messages. This defaults to an own bandsaw.advices.log.JsonFormatter that writes log messages as individual json objects (one per line), but custom formatter can be used as well.","title":"formatter (logging.Formatter)"},{"location":"advices/logging/#example-configuration","text":"import logging import bandsaw.advices.log configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . log . LoggingAdvice ( level = logging . INFO , ) )","title":"Example configuration"},{"location":"advices/logging/#jsonformatter","text":"The JsonFormatter writes log messages as line-wise json that makes its easier to process the logs later-on without having to parse user-defined text formats.","title":"JsonFormatter"},{"location":"advices/logging/#description-of-the-individual-fields","text":"Field Type Optional Description timestamp string no Times are ISO-Format and always in UTC. logger string no The name of the logger that created the message. level string no The level of the message (usually INFO, DEBUG, WARN, ERROR, but can be custom). message string no The text content of the log message. threadId int no The ID of the thread where the message was emitted. threadName string no The name of the thread where the message was emitted. processId int no The process ID of the process which emitted the message. processName string no The name of the process which emitted the message. module string no The name of the module based on the filename. function string no Name of the function which emitted the log message. path string no Path to the python file where the message originated. line_no int no Number of the line where the log message was created. traceback string yes Stacktrace of the exception. (missing if no exception is logged) exception string yes String representation of the exception. (missing if no exception is logged) sessionId string yes (bandsaw specific) ID of the session in which the log message was created. runId string yes (bandsaw specific) ID of the run in which the log message was created. taskId string yes (bandsaw specific) ID of the task which was executed. executionId string yes (bandsaw specific) ID of the execution of the task.","title":"Description of the individual fields"},{"location":"advices/logging/#example-of-normal-log-message","text":"{ \"timestamp\" : \"2021-12-22T14:13:30.840811+00:00\" , \"logger\" : \"bandsaw.advices.metrics\" , \"level\" : \"INFO\" , \"message\" : \"Measurement id ea1a9e07d0c48896 with tags {'run_id': '55e85c2e-6331-11ec-8e2d-48f17f64520d', 'task_id': 'd24d5c98e4f63e66', 'execution_id': 'dd999d9ace267e13', 'session_id': 'ea1a9e07d0c48896'}\" , \"threadId\" : 140239061456704 , \"threadName\" : \"MainThread\" , \"processId\" : 16365 , \"processName\" : \"MainProcess\" , \"module\" : \"metrics\" , \"function\" : \"before\" , \"path\" : \"/home/bandsaw/dd999d9ace267e13/distribution-zy0tybls.pyz/bandsaw/advices/metrics.py\" , \"line_no\" : 50 , \"sessionId\" : \"ea1a9e07d0c48896\" , \"runId\" : \"55e85c2e-6331-11ec-8e2d-48f17f64520d\" , \"taskId\" : \"d24d5c98e4f63e66\" , \"executionId\" : \"dd999d9ace267e13\" }","title":"Example of normal log message"},{"location":"advices/logging/#example-of-log-message-with-exception","text":"{ \"timestamp\" : \"2021-12-22T14:18:31.821401+00:00\" , \"logger\" : \"my.logger\" , \"level\" : \"ERROR\" , \"message\" : \"Error greeting\" , \"threadId\" : 140626754463552 , \"threadName\" : \"MainThread\" , \"processId\" : 16632 , \"processName\" : \"MainProcess\" , \"module\" : \"demo\" , \"function\" : \"greet\" , \"path\" : \"/home/bandsaw/76560cb43662cc8f/distribution-f_say9mc.pyz/demo.py\" , \"line_no\" : 20 , \"traceback\" : \"File \\\"/home/bandsaw/76560cb43662cc8f/distribution-f_say9mc.pyz/demo.py\\\", line 18, in greet\\n raise ValueError(os.getpid())\" , \"exception\" : \"ValueError: 16632\" , \"sessionId\" : \"2573b136fd2b4f8e\" , \"runId\" : \"0939cef2-6332-11ec-8e2d-48f17f64520d\" , \"taskId\" : \"0d268ac06a82654e\" , \"executionId\" : \"76560cb43662cc8f\" }","title":"Example of log message with exception"},{"location":"advices/metrics/","text":"Gathering metrics for task executions \ud83d\udd17 In order to get better insight into bottlenecks and consumption of computing resources Bandsaw provides the bandsaw.advices.metrics.MetricsAdvice , that allows to track metrics like CPU load or memory usage while tasks are executed. This enables developers to discover hotspots and bottlenecks within their workflow and identify optimization potential. The advice uses the Multimeter library for collecting the values. It uses the library to write the metrics into a file and attaches the result under the name 'metrics. ' to the session. The extension of the filename depends on the file format that is being configured. Configuration \ud83d\udd17 meter (multimeter.Multimeter) \ud83d\udd17 meter is a required positional argument. It contains the pre-configured Multimeter instance that will be used for measuring the metrics during task execution. The Multimeter is configured by its constructor . In order to gather any value, it must be given atleast 1 probe, e.g. ResourceProbe . For more information on how it is being used, please refer to https://docs.kant.ai/multimeter/latest/user_guide/#multimeter . directory (str) \ud83d\udd17 The directory where the files with the gathered metrics are written to. For each session a separate file is being created with the name . where ' ' depends on the file format. If this directory is not set or None , the files are written to the session specific temporary directory. file_format (multimeter.FileFormat) \ud83d\udd17 The file format which is used for writing the results. Multimeter supports multiple file formats that can be used. Defaults to multimeter.JsonFormat . For more information refer to https://docs.kant.ai/multimeter/latest/storages/file/ . Example configuration \ud83d\udd17 import bandsaw import multimeter from bandsaw.advices.metrics import MetricsAdvice configuration = bandsaw . Configuration () . add_advice_chain ( MetricsAdvice ( multimeter . Multimeter ( multimeter . ResourceProbe ()), directory = '/my/metric/directory' , file_format = multimeter . JsonFormat (), ) )","title":"Metrics"},{"location":"advices/metrics/#gathering-metrics-for-task-executions","text":"In order to get better insight into bottlenecks and consumption of computing resources Bandsaw provides the bandsaw.advices.metrics.MetricsAdvice , that allows to track metrics like CPU load or memory usage while tasks are executed. This enables developers to discover hotspots and bottlenecks within their workflow and identify optimization potential. The advice uses the Multimeter library for collecting the values. It uses the library to write the metrics into a file and attaches the result under the name 'metrics. ' to the session. The extension of the filename depends on the file format that is being configured.","title":"Gathering metrics for task executions"},{"location":"advices/metrics/#configuration","text":"","title":"Configuration"},{"location":"advices/metrics/#meter-multimetermultimeter","text":"meter is a required positional argument. It contains the pre-configured Multimeter instance that will be used for measuring the metrics during task execution. The Multimeter is configured by its constructor . In order to gather any value, it must be given atleast 1 probe, e.g. ResourceProbe . For more information on how it is being used, please refer to https://docs.kant.ai/multimeter/latest/user_guide/#multimeter .","title":"meter (multimeter.Multimeter)"},{"location":"advices/metrics/#directory-str","text":"The directory where the files with the gathered metrics are written to. For each session a separate file is being created with the name . where ' ' depends on the file format. If this directory is not set or None , the files are written to the session specific temporary directory.","title":"directory (str)"},{"location":"advices/metrics/#file_format-multimeterfileformat","text":"The file format which is used for writing the results. Multimeter supports multiple file formats that can be used. Defaults to multimeter.JsonFormat . For more information refer to https://docs.kant.ai/multimeter/latest/storages/file/ .","title":"file_format (multimeter.FileFormat)"},{"location":"advices/metrics/#example-configuration","text":"import bandsaw import multimeter from bandsaw.advices.metrics import MetricsAdvice configuration = bandsaw . Configuration () . add_advice_chain ( MetricsAdvice ( multimeter . Multimeter ( multimeter . ResourceProbe ()), directory = '/my/metric/directory' , file_format = multimeter . JsonFormat (), ) )","title":"Example configuration"},{"location":"advices/remote/","text":"Running tasks on remote machines using SSH \ud83d\udd17 The bandsaw.advices.ssh.SshAdvice allows to run tasks on a different machine than where the workflow defining the whole process is being run. Internally it uses the ssh command line tools to transfer the task over to another machine, spawns a new python interpreter, runs the task and returns the result back to the calling machine. Configuration \ud83d\udd17 directory (str) \ud83d\udd17 The directory, where the temporary files like the session or the result will be stored before transferring them to or from a remote machine. If the directory doesn't exist, it will be created when first being used. If no directory is given, a temporary directory is used. add_remote() \ud83d\udd17 Defining the remote machine is done by calling add_remote(remote) on the advice and providing an instance of the bandsaw.advices.ssh.Remote class. The class contains all the information necessary for executing a task remotely and is initialized using its constructor: host \ud83d\udd17 The hostname of the machine, where the tasks should be run. It could be an ip address, too, but it must be set. port \ud83d\udd17 The port to which SSH should connect to as int . If not set, the default port 22 for ssh is used. key_file \ud83d\udd17 key_file should be the path to file, which contains the key that will be used for authentication. If this is not configured, ssh will use the default. Warning Due to its automatic nature, bandsaw doesn't know how to handle passwords. Therefore, it doesn't support authentication via password or keyfiles that use a passphrase (without using a ssh-agent). user \ud83d\udd17 The username of the user, that is being used on the remote machine. If this is not configured, bandsaw uses the name of the local user, that runs the python interpreter. interpreter \ud83d\udd17 An instance of bandsaw.interpreter.Interpreter which contains the path on the remote machine to a python interpreter as well as additions to the PYTHONPATH on the remote machine, e.g. if non-standard libraries are used. directory \ud83d\udd17 Path to a directory on the remote machine, where temporary files will be stored. If not specified, '/tmp' is as default. Example configuration with a single remote \ud83d\udd17 import bandsaw from bandsaw.advices.ssh import SshAdvice , Remote configuration = bandsaw . Configuration () . add_advice_chain ( SshAdvice () . add_remote ( Remote ( host = 'my.remote.machine.tld' , port = '22' , key_file = '/path/to/my/key' , user = 'my_remote_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/my/remote/directory' , ), ), ) Example configuration with multiple remotes \ud83d\udd17 The advice supports multiple different remote machines that can be used for executing tasks. Each definition of a remote machine has to be added by a add_remote(remote) call to the SshAdvice class: import bandsaw from bandsaw.advices.ssh import SshAdvice , Remote configuration = bandsaw . Configuration () . add_advice_chain ( SshAdvice () . add_remote ( Remote ( host = 'my.remote.machine.tld' , port = '22' , key_file = '/path/to/my/key' , user = 'my_remote_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/my/remote/directory' , ), name = 'remote-1' , ) . add_remote ( Remote ( host = 'my.other.machine.tld' , port = '2222' , key_file = '/different/key' , user = 'my_other_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/tmp/directory' , ), name = 'remote-2' , ), ) Besides the Remote instance, the add_remote() method takes an additional argument name which allows referring to a specific remote configuration. If no name is given 'default' is used. Which remote configuration should be used can be configured per task. Each task definition can take additional task arguments in form of keyword arguments: @bandsaw . task ( ssh = { 'remote' : 'remote-2' }) def greet ( recipient ): return f \"Hello { recipient } \" The SshAdvice expects a dictionary for the task keyword argument ssh . This dict contains then the task specific SSH configuration. Currently, the only supported key is 'remote' whose value must be the name of one of the remotes defined by add_remote() . If no task keyword argument 'ssh' is given, or its value doesn't contain 'remote', the default name for the remote is 'default'.","title":"Remote"},{"location":"advices/remote/#running-tasks-on-remote-machines-using-ssh","text":"The bandsaw.advices.ssh.SshAdvice allows to run tasks on a different machine than where the workflow defining the whole process is being run. Internally it uses the ssh command line tools to transfer the task over to another machine, spawns a new python interpreter, runs the task and returns the result back to the calling machine.","title":"Running tasks on remote machines using SSH"},{"location":"advices/remote/#configuration","text":"","title":"Configuration"},{"location":"advices/remote/#directory-str","text":"The directory, where the temporary files like the session or the result will be stored before transferring them to or from a remote machine. If the directory doesn't exist, it will be created when first being used. If no directory is given, a temporary directory is used.","title":"directory (str)"},{"location":"advices/remote/#add_remote","text":"Defining the remote machine is done by calling add_remote(remote) on the advice and providing an instance of the bandsaw.advices.ssh.Remote class. The class contains all the information necessary for executing a task remotely and is initialized using its constructor:","title":"add_remote()"},{"location":"advices/remote/#host","text":"The hostname of the machine, where the tasks should be run. It could be an ip address, too, but it must be set.","title":"host"},{"location":"advices/remote/#port","text":"The port to which SSH should connect to as int . If not set, the default port 22 for ssh is used.","title":"port"},{"location":"advices/remote/#key_file","text":"key_file should be the path to file, which contains the key that will be used for authentication. If this is not configured, ssh will use the default. Warning Due to its automatic nature, bandsaw doesn't know how to handle passwords. Therefore, it doesn't support authentication via password or keyfiles that use a passphrase (without using a ssh-agent).","title":"key_file"},{"location":"advices/remote/#user","text":"The username of the user, that is being used on the remote machine. If this is not configured, bandsaw uses the name of the local user, that runs the python interpreter.","title":"user"},{"location":"advices/remote/#interpreter","text":"An instance of bandsaw.interpreter.Interpreter which contains the path on the remote machine to a python interpreter as well as additions to the PYTHONPATH on the remote machine, e.g. if non-standard libraries are used.","title":"interpreter"},{"location":"advices/remote/#directory","text":"Path to a directory on the remote machine, where temporary files will be stored. If not specified, '/tmp' is as default.","title":"directory"},{"location":"advices/remote/#example-configuration-with-a-single-remote","text":"import bandsaw from bandsaw.advices.ssh import SshAdvice , Remote configuration = bandsaw . Configuration () . add_advice_chain ( SshAdvice () . add_remote ( Remote ( host = 'my.remote.machine.tld' , port = '22' , key_file = '/path/to/my/key' , user = 'my_remote_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/my/remote/directory' , ), ), )","title":"Example configuration with a single remote"},{"location":"advices/remote/#example-configuration-with-multiple-remotes","text":"The advice supports multiple different remote machines that can be used for executing tasks. Each definition of a remote machine has to be added by a add_remote(remote) call to the SshAdvice class: import bandsaw from bandsaw.advices.ssh import SshAdvice , Remote configuration = bandsaw . Configuration () . add_advice_chain ( SshAdvice () . add_remote ( Remote ( host = 'my.remote.machine.tld' , port = '22' , key_file = '/path/to/my/key' , user = 'my_remote_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/my/remote/directory' , ), name = 'remote-1' , ) . add_remote ( Remote ( host = 'my.other.machine.tld' , port = '2222' , key_file = '/different/key' , user = 'my_other_user' , interpreter = bandsaw . Interpreter ( path = [], executable = '/my/remote/path/to/python3' , ), directory = '/tmp/directory' , ), name = 'remote-2' , ), ) Besides the Remote instance, the add_remote() method takes an additional argument name which allows referring to a specific remote configuration. If no name is given 'default' is used. Which remote configuration should be used can be configured per task. Each task definition can take additional task arguments in form of keyword arguments: @bandsaw . task ( ssh = { 'remote' : 'remote-2' }) def greet ( recipient ): return f \"Hello { recipient } \" The SshAdvice expects a dictionary for the task keyword argument ssh . This dict contains then the task specific SSH configuration. Currently, the only supported key is 'remote' whose value must be the name of one of the remotes defined by add_remote() . If no task keyword argument 'ssh' is given, or its value doesn't contain 'remote', the default name for the remote is 'default'.","title":"Example configuration with multiple remotes"},{"location":"advices/subprocess/","text":"Running tasks in subprocesses \ud83d\udd17 The python module bandsaw.advices.subprocess contains the SubprocessAdvice class, which allows running task computations in a subprocess. Additionally, the subprocess can use a different python interpreter than the one, that is used for running the rest of the recipe. This can be used for bringing together tasks with conflicting dependencies or different python versions. Configuration \ud83d\udd17 directory (str) \ud83d\udd17 The directory, where the intermediate results and temporary data to communicate with the subprocess will be written to. Can be None , in which case a temporary directory will be used. interpreter (bandsaw.interpreter.Interpreter) \ud83d\udd17 The python interpreter to use for executing the task. If None , the same interpreter will be used, that is executing the workflow. Example configuration \ud83d\udd17 import bandsaw.advices.subprocess import bandsaw.interpreter configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . subprocess . SubprocessAdvice ( directory = '/my/subprocess/directory' , interpreter = bandsaw . interpreter . Interpreter ( path = [ '/my/other/interpreter' , '/python/path' ], executable = '/path/to/the/other/python' , ) ) )","title":"Subprocess"},{"location":"advices/subprocess/#running-tasks-in-subprocesses","text":"The python module bandsaw.advices.subprocess contains the SubprocessAdvice class, which allows running task computations in a subprocess. Additionally, the subprocess can use a different python interpreter than the one, that is used for running the rest of the recipe. This can be used for bringing together tasks with conflicting dependencies or different python versions.","title":"Running tasks in subprocesses"},{"location":"advices/subprocess/#configuration","text":"","title":"Configuration"},{"location":"advices/subprocess/#directory-str","text":"The directory, where the intermediate results and temporary data to communicate with the subprocess will be written to. Can be None , in which case a temporary directory will be used.","title":"directory (str)"},{"location":"advices/subprocess/#interpreter-bandsawinterpreterinterpreter","text":"The python interpreter to use for executing the task. If None , the same interpreter will be used, that is executing the workflow.","title":"interpreter (bandsaw.interpreter.Interpreter)"},{"location":"advices/subprocess/#example-configuration","text":"import bandsaw.advices.subprocess import bandsaw.interpreter configuration = bandsaw . Configuration () . add_advice_chain ( bandsaw . advices . subprocess . SubprocessAdvice ( directory = '/my/subprocess/directory' , interpreter = bandsaw . interpreter . Interpreter ( path = [ '/my/other/interpreter' , '/python/path' ], executable = '/path/to/the/other/python' , ) ) )","title":"Example configuration"},{"location":"extensions/extension/","text":"Extensions \ud83d\udd17 Besides advices, bandsaw allows to extend its functionality by using its bandsaw.extensions.Extension concept. The base class defines a set of methods, that can be implemented to be notified by bandsaw about certain events. Interface \ud83d\udd17 At the moment the base class defines the following methods: on_init() \ud83d\udd17 def on_init ( self , configuration ): ... on_init() is called by bandsaw when the configuration, that contains this extension is completely initialized. This happens only once per run (per interpreter) and is done before every other extension methods, so it can be used for one-time setting up the extension. Warning Even though an extension is initialized only once in a single interpreter, it can be called multiple times in multiple python interpreters, e.g. when a session is transferred to a different machine. on_session_created() \ud83d\udd17 def on_session_created ( self , session ): ... on_session_created() is called when bandsaw created a new session for executing a task. The session is given to the extension and can be modified by it e.g. by setting additional context. The task of the session has not been computed at this time and neither were advices applied. Methods that change the state of session in relation to its execution, like initiate() , proceed() or conclude() must not be called by an extension. on_session_finished() \ud83d\udd17 def on_session_finished ( self , session ): ... on_session_finished() is called when bandsaw has finished executing a task. The result has been computed and all advices have been applied at this point. The extension can use the given session, to extract information about the execution, but modifications of the session don't have any effect. Methods that change the state of session in relation to its execution, like initiate() , proceed() or conclude() must not be called by an extension. Configuration \ud83d\udd17 All extensions have to be added to the bandsaw configuration in order to be used. import bandsaw configuration = bandsaw . Configuration () ... # Here the rest of the configuration and advice chains configuration . add_extension ( MyExtension ( possible = 'config' ))","title":"Interface"},{"location":"extensions/extension/#extensions","text":"Besides advices, bandsaw allows to extend its functionality by using its bandsaw.extensions.Extension concept. The base class defines a set of methods, that can be implemented to be notified by bandsaw about certain events.","title":"Extensions"},{"location":"extensions/extension/#interface","text":"At the moment the base class defines the following methods:","title":"Interface"},{"location":"extensions/extension/#on_init","text":"def on_init ( self , configuration ): ... on_init() is called by bandsaw when the configuration, that contains this extension is completely initialized. This happens only once per run (per interpreter) and is done before every other extension methods, so it can be used for one-time setting up the extension. Warning Even though an extension is initialized only once in a single interpreter, it can be called multiple times in multiple python interpreters, e.g. when a session is transferred to a different machine.","title":"on_init()"},{"location":"extensions/extension/#on_session_created","text":"def on_session_created ( self , session ): ... on_session_created() is called when bandsaw created a new session for executing a task. The session is given to the extension and can be modified by it e.g. by setting additional context. The task of the session has not been computed at this time and neither were advices applied. Methods that change the state of session in relation to its execution, like initiate() , proceed() or conclude() must not be called by an extension.","title":"on_session_created()"},{"location":"extensions/extension/#on_session_finished","text":"def on_session_finished ( self , session ): ... on_session_finished() is called when bandsaw has finished executing a task. The result has been computed and all advices have been applied at this point. The extension can use the given session, to extract information about the execution, but modifications of the session don't have any effect. Methods that change the state of session in relation to its execution, like initiate() , proceed() or conclude() must not be called by an extension.","title":"on_session_finished()"},{"location":"extensions/extension/#configuration","text":"All extensions have to be added to the bandsaw configuration in order to be used. import bandsaw configuration = bandsaw . Configuration () ... # Here the rest of the configuration and advice chains configuration . add_extension ( MyExtension ( possible = 'config' ))","title":"Configuration"},{"location":"extensions/tracker/","text":"Tracking the runs of the workflow \ud83d\udd17 Since most of the time workflows are run multiple times, it can be useful to have a history of past runs and their results. For this bandsaw comes with a bandsaw.tracking.tracker.TrackerExtension . This extension tracks information about the different parts of a workflow, be it the run itself or the executed tasks with their result. This information is then send to a backend where the data is stored and can be accessed and integrated into ones own process and monitoring solution. Currently, the only available backend is the bandsaw.tracking.filesystem.FileSystemBackend which stores the data in json format in a local directory. Configuration \ud83d\udd17 backend (bandsaw.tracking.backend.Backend) \ud83d\udd17 backend is a required positional argument. It contains the pre-configured backend instance that will be used for storing the tracking information. The object has to inherit from type bandsaw.tracking.backend.Backend . Example configuration \ud83d\udd17 import bandsaw from bandsaw.tracking.tracker import TrackerExtension from bandsaw.tracking.filesystem import FileSystemBackend tracking_directory = '/path/to/my/tracking/directory' configuration = bandsaw . Configuration () configuration . add_extension ( TrackerExtension ( FileSystemBackend ( tracking_directory ))) Backends \ud83d\udd17 All backends need to inherit from the base class bandsaw.tracking.backend.Backend which defines the interface that is being expected from the tracker extension. It defines a set of methods which take the information about the workflow: def track_run ( self , ids , run_info ): pass def track_task ( self , ids , task_info ): pass def track_execution ( self , ids , execution_info ): pass def track_session ( self , ids , session_info ): pass def track_result ( self , ids , result_info ): pass def track_attachments ( self , ids , attachments ): pass def track_distribution_archive ( self , distribution_archive ): pass All *_infos that are passed over are dictionaries which contain the information. FileSystemBackend \ud83d\udd17 The first available backend is the bandsaw.tracking.filesystem.FileSystemBackend which writes the info objects to the file system. For this it takes a path to a directory as configuration, where the individual *-info.json files are stored. The directory layout follows a specific schema: .tracking/ \u251c\u2500\u2500 runs \u2502 \u251c\u2500\u2500 025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 0d268ac06a82654e_76560cb43662cc8f_025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u2514\u2500\u2500 run-info.json \u2502 \u2514\u2500\u2500 6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u251c\u2500\u2500 0d268ac06a82654e_76560cb43662cc8f_6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u2514\u2500\u2500 run-info.json \u2514\u2500\u2500 tasks \u2514\u2500\u2500 0d268ac06a82654e \u251c\u2500\u2500 76560cb43662cc8f \u2502 \u251c\u2500\u2500 025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 attachments \u2502 \u2502 \u2502 \u251c\u2500\u2500 metrics.json \u2502 \u2502 \u2502 \u2514\u2500\u2500 session.log \u2502 \u2502 \u251c\u2500\u2500 result-info.json \u2502 \u2502 \u2514\u2500\u2500 session-info.json \u2502 \u251c\u2500\u2500 6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 attachments \u2502 \u2502 \u2502 \u251c\u2500\u2500 metrics.json \u2502 \u2502 \u2502 \u2514\u2500\u2500 session.log \u2502 \u2502 \u251c\u2500\u2500 result-info.json \u2502 \u2502 \u2514\u2500\u2500 session-info.json \u2502 \u2514\u2500\u2500 execution-info.json \u2514\u2500\u2500 task-info.json tasks contains on its level a single directory for each individual task whose name is the task_id of the containing task. The task directory contains a single task-info.json file, which contains a json object with some information about this specific tasks. Every execution of this task is stored in a separate subdirectory named with the execution_id of the corresponding execution. These directories contain a execution-info.json file with meta information about the arguments used in this execution and subdirectories named by the run_id for every specific run, where the task was executed with these specific arguments. This directory contains then an session-info.json with information about the session of this execution and the result-info.json which describes the computed result. If attachments where created by the advice chain while executing the task, those are stored in the attachments directory. Additionally, in the root of the tracking directory a directory runs stores information about the executed sessions for each individual run. Every run has their own specific directory named by its run_id This directory contains a run-info.json and empty files named with the session_ids of every session that was computed during this run. Example JSON info file format \ud83d\udd17 All *-info.json files have the same format and share some of their content. An example can be found below. Most files contain only a subset of this example data. { \"task\" : { \"id\" : \"0d268ac06a82654e\" , \"definition\" : \"demo.greet\" , \"advice_parameters\" : {} }, \"execution\" : { \"id\" : \"76560cb43662cc8f\" , \"arguments\" : [ { \"type\" : \"str\" , \"value\" : \"Christoph\" , \"size\" : \"9\" , \"name\" : \"recipient\" } ] }, \"run\" : { \"id\" : \"6aa525e8-698f-11ec-8e2d-48f17f64520d\" }, \"configuration\" : \"bandsaw_config\" , \"distribution_archive\" : { \"modules\" : [ \"__main__\" , \"bandsaw\" , \"bandsaw_config\" , \"multimeter\" ], \"id\" : null }, \"session\" : { \"id\" : \"0d268ac06a82654e_76560cb43662cc8f_6aa525e8-698f-11ec-8e2d-48f17f64520d\" }, \"result\" : { \"value\" : { \"type\" : \"int\" , \"value\" : \"16421\" } } }","title":"Tracker"},{"location":"extensions/tracker/#tracking-the-runs-of-the-workflow","text":"Since most of the time workflows are run multiple times, it can be useful to have a history of past runs and their results. For this bandsaw comes with a bandsaw.tracking.tracker.TrackerExtension . This extension tracks information about the different parts of a workflow, be it the run itself or the executed tasks with their result. This information is then send to a backend where the data is stored and can be accessed and integrated into ones own process and monitoring solution. Currently, the only available backend is the bandsaw.tracking.filesystem.FileSystemBackend which stores the data in json format in a local directory.","title":"Tracking the runs of the workflow"},{"location":"extensions/tracker/#configuration","text":"","title":"Configuration"},{"location":"extensions/tracker/#backend-bandsawtrackingbackendbackend","text":"backend is a required positional argument. It contains the pre-configured backend instance that will be used for storing the tracking information. The object has to inherit from type bandsaw.tracking.backend.Backend .","title":"backend (bandsaw.tracking.backend.Backend)"},{"location":"extensions/tracker/#example-configuration","text":"import bandsaw from bandsaw.tracking.tracker import TrackerExtension from bandsaw.tracking.filesystem import FileSystemBackend tracking_directory = '/path/to/my/tracking/directory' configuration = bandsaw . Configuration () configuration . add_extension ( TrackerExtension ( FileSystemBackend ( tracking_directory )))","title":"Example configuration"},{"location":"extensions/tracker/#backends","text":"All backends need to inherit from the base class bandsaw.tracking.backend.Backend which defines the interface that is being expected from the tracker extension. It defines a set of methods which take the information about the workflow: def track_run ( self , ids , run_info ): pass def track_task ( self , ids , task_info ): pass def track_execution ( self , ids , execution_info ): pass def track_session ( self , ids , session_info ): pass def track_result ( self , ids , result_info ): pass def track_attachments ( self , ids , attachments ): pass def track_distribution_archive ( self , distribution_archive ): pass All *_infos that are passed over are dictionaries which contain the information.","title":"Backends"},{"location":"extensions/tracker/#filesystembackend","text":"The first available backend is the bandsaw.tracking.filesystem.FileSystemBackend which writes the info objects to the file system. For this it takes a path to a directory as configuration, where the individual *-info.json files are stored. The directory layout follows a specific schema: .tracking/ \u251c\u2500\u2500 runs \u2502 \u251c\u2500\u2500 025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 0d268ac06a82654e_76560cb43662cc8f_025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u2514\u2500\u2500 run-info.json \u2502 \u2514\u2500\u2500 6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u251c\u2500\u2500 0d268ac06a82654e_76560cb43662cc8f_6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u2514\u2500\u2500 run-info.json \u2514\u2500\u2500 tasks \u2514\u2500\u2500 0d268ac06a82654e \u251c\u2500\u2500 76560cb43662cc8f \u2502 \u251c\u2500\u2500 025c8e7e-6992-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 attachments \u2502 \u2502 \u2502 \u251c\u2500\u2500 metrics.json \u2502 \u2502 \u2502 \u2514\u2500\u2500 session.log \u2502 \u2502 \u251c\u2500\u2500 result-info.json \u2502 \u2502 \u2514\u2500\u2500 session-info.json \u2502 \u251c\u2500\u2500 6aa525e8-698f-11ec-8e2d-48f17f64520d \u2502 \u2502 \u251c\u2500\u2500 attachments \u2502 \u2502 \u2502 \u251c\u2500\u2500 metrics.json \u2502 \u2502 \u2502 \u2514\u2500\u2500 session.log \u2502 \u2502 \u251c\u2500\u2500 result-info.json \u2502 \u2502 \u2514\u2500\u2500 session-info.json \u2502 \u2514\u2500\u2500 execution-info.json \u2514\u2500\u2500 task-info.json tasks contains on its level a single directory for each individual task whose name is the task_id of the containing task. The task directory contains a single task-info.json file, which contains a json object with some information about this specific tasks. Every execution of this task is stored in a separate subdirectory named with the execution_id of the corresponding execution. These directories contain a execution-info.json file with meta information about the arguments used in this execution and subdirectories named by the run_id for every specific run, where the task was executed with these specific arguments. This directory contains then an session-info.json with information about the session of this execution and the result-info.json which describes the computed result. If attachments where created by the advice chain while executing the task, those are stored in the attachments directory. Additionally, in the root of the tracking directory a directory runs stores information about the executed sessions for each individual run. Every run has their own specific directory named by its run_id This directory contains a run-info.json and empty files named with the session_ids of every session that was computed during this run.","title":"FileSystemBackend"},{"location":"extensions/tracker/#example-json-info-file-format","text":"All *-info.json files have the same format and share some of their content. An example can be found below. Most files contain only a subset of this example data. { \"task\" : { \"id\" : \"0d268ac06a82654e\" , \"definition\" : \"demo.greet\" , \"advice_parameters\" : {} }, \"execution\" : { \"id\" : \"76560cb43662cc8f\" , \"arguments\" : [ { \"type\" : \"str\" , \"value\" : \"Christoph\" , \"size\" : \"9\" , \"name\" : \"recipient\" } ] }, \"run\" : { \"id\" : \"6aa525e8-698f-11ec-8e2d-48f17f64520d\" }, \"configuration\" : \"bandsaw_config\" , \"distribution_archive\" : { \"modules\" : [ \"__main__\" , \"bandsaw\" , \"bandsaw_config\" , \"multimeter\" ], \"id\" : null }, \"session\" : { \"id\" : \"0d268ac06a82654e_76560cb43662cc8f_6aa525e8-698f-11ec-8e2d-48f17f64520d\" }, \"result\" : { \"value\" : { \"type\" : \"int\" , \"value\" : \"16421\" } } }","title":"Example JSON info file format"}]}